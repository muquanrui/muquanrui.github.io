<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>设计模式 | Quanrui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Quanrui's Blog" />
  
  <meta name="description" content="1 概述1.1 简介设计模式（Design Pattern）代表了开发的最佳实践，通常被有经验的面向对象软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Quanrui&#39;s Blog">
<meta property="og:description" content="1 概述1.1 简介设计模式（Design Pattern）代表了开发的最佳实践，通常被有经验的面向对象软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代">
<meta property="og:locale">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-71b22158f5b09dffa57a123d72ec4653_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-5c69cd9ff703377f7bbf37cee8199451_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-e39bdff5514c38e7797848372ac51365_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/16e6ec5ae3c30a3a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-b421c9c15219feba7dd9cf7681070682_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-e6a48521352fff8270e753ea4a79d9fb_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-04064db11797cf36229d67407fea1b83_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-616c153ec74d496a811ac50c83c3653c_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-3f331f3dc075abb4215413014688638f_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-431e044bbf26778a20dd788968e22aac_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-82cb160ed1566d1d04ea320575b54d5f_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-e651244eeca9c0881cbdd2add429e850_1440w.webp">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/image-20221015224041919.png">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/1419489-20190628144601084-563759643.png">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/1419489-20190628154133368-906051111.png">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/1419489-20190628170705865-1781414242.png">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/20210315-builder-pattern.svg">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/image-20221018134740838.png">
<meta property="og:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/image-20221018134943141.png">
<meta property="article:published_time" content="2022-10-15T13:41:58.000Z">
<meta property="article:modified_time" content="2022-10-28T15:59:17.689Z">
<meta property="article:author" content="MU Quanrui">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/images/v2-71b22158f5b09dffa57a123d72ec4653_1440w.webp">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  
<link rel="stylesheet" href="/css/style.css">


 <!--加载prettify代码高亮样式-->
<link href="/google-code-prettify/tranquil-heart.css" type="text/css" rel="stylesheet" />

  
<script src="/js/pace.min.js"></script>

  

  
  


  <!--加载条样式-->
  <style>
    .pace .pace-progress {
    	background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);
    	height: 3px;
    }
    .pace .pace-progress-inner {
     	box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
    	border-top-color: #1E92FB;	/*上边框颜色*/
    	border-left-color: #1E92FB;	/*左边框颜色*/
    }
  </style>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div id="background"></div><!--背景颜色/图片-->
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">

        <div id="header-menu" class="header-menu-pos animated">


<a target="_blank" rel="noopener" href="https://github.com/VorSonnenaufgang" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FFA500; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Quanrui&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/categories">
                        <i class="fa fa-book"></i>
                        <span>Categories</span>
                    </a>
                    
                    <a  href="/tags">
                        <i class="fa fa-tags"></i>
                        <span>Tags</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Quanrui&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        Carpe diem.
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//muquanrui.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/VorSonnenaufgang">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="CSDN" target="_blank" href="//blog.csdn.net/vorsonnenaufgang">
                            <i class="fa fa-copyright fa-2x"></i></a>
                    
                        <a title="Google" target="_blank" href="//google.com">
                            <i class="fa fa-google fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Java/设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      设计模式
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/方法论/">方法论</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-10-15
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>          
        </li>
      </ul>
       <span class="post-count">文章字数:28.8k字 &nbsp &nbsp  
         阅读时长:114分钟</span>
    </div>
  
        
          
      </header>
    

    <div class="article-entry post-content" itemprop="articleBody">

    
    



      
            
            <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>设计模式（Design Pattern）代表了开发的最佳实践，通常被有经验的面向对象软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。</p>
<h2 id="1-2-原则和类型"><a href="#1-2-原则和类型" class="headerlink" title="1.2 原则和类型"></a>1.2 原则和类型</h2><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有7大原则， 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>单一职责原则（Single Responsibility Principle）</li>
<li>接口隔离原则（Interface Segregation Principle）</li>
<li>依赖倒转原则（Dependence Inversion Principle）</li>
<li>里氏替换原则（Liskov Substitution Principle）</li>
<li>开闭原则（Open Close Principle）</li>
<li>迪米特法则，又称最少知道原则（Demeter Principle）</li>
<li>合成复用原则（Composite Reuse Principle）</li>
</ol>
<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。    </p>
<ol>
<li>单例模式（Singleton Pattern）</li>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
</ol>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<ol>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ol>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>这些设计模式特别关注对象之间的通信。    </p>
<ol>
<li>模板方法模式（Template Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>责任链模式（Chain of Responsibility Pattern）</li>
</ol>
<h1 id="2-UML类图"><a href="#2-UML类图" class="headerlink" title="2 UML类图"></a>2 UML类图</h1><p>UML，Unified modeling language UML (统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果。UML图有很多种，但是并非必须掌握所有的UML图，才能完整系统分析和设计工作。一般说来，在UML图中，只要掌握类图、用例图、时序图的使用，就能完成大部分的工作。</p>
<p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p>
<h2 id="2-1-表示具体类"><a href="#2-1-表示具体类" class="headerlink" title="2.1 表示具体类"></a>2.1 表示具体类</h2><p>具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：</p>
<ul>
<li>“+” 表示 public；</li>
<li>“-” 表示 private；</li>
<li>“#” 表示 protected；</li>
<li>不带符号表示 default。</li>
</ul>
<img src="images/v2-71b22158f5b09dffa57a123d72ec4653_1440w.webp" alt="img" style="zoom:50%;" />

<h2 id="2-2-表示抽象类"><a href="#2-2-表示抽象类" class="headerlink" title="2.2 表示抽象类"></a>2.2 表示抽象类</h2><p>抽象类在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示。</p>
<img src="images/v2-5c69cd9ff703377f7bbf37cee8199451_1440w.webp" alt="img" style="zoom:50%;" />

<h2 id="2-3-表示接口"><a href="#2-3-表示接口" class="headerlink" title="2.3 表示接口"></a>2.3 表示接口</h2><p>接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 &lt;<interface>&gt; 表示，下面是接口的名字，第二层是方法。此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线），圆圈旁为接口名称，接口方法在实现类中出现。</p>
<img src="images/v2-e39bdff5514c38e7797848372ac51365_1440w.webp" alt="img" style="zoom:50%;" />

<p><img src="images/16e6ec5ae3c30a3a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.png" alt="img"></p>
<h2 id="2-4-表示包"><a href="#2-4-表示包" class="headerlink" title="2.4 表示包"></a>2.4 表示包</h2><p>类和接口一般都出现在包中。</p>
<img src="images/v2-b421c9c15219feba7dd9cf7681070682_1440w.webp" alt="img" style="zoom:50%;" />

<h2 id="2-5-表示关系"><a href="#2-5-表示关系" class="headerlink" title="2.5 表示关系"></a>2.5 表示关系</h2><p>类和类、类和接口、接口和接口之间存在一定关系，UML类图中一般会有连线指明它们之间的关系。关系共有六种类型，分别是实现关系、泛化关系、关联关系、依赖关系、聚合关系、组合关系。</p>
<img src="images/v2-e6a48521352fff8270e753ea4a79d9fb_1440w.webp" alt="img" style="zoom:50%;" />

<h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系（Generalization）是指对象与对象之间的继承关系。如果对象A和对象B之间的“is a”关系成立，那么二者之间就存在继承关系。</p>
<p>对象B是父对象，对象A是子对象。例如，一个年薪制员工“is a”员工，很显然年薪制员工Salary对象和员工Employee对象之间存在继承关系，Employee对象是父对象，Salary对象是子对象。</p>
<p>在UML类图中，泛化关系用空心三角和实线组成的箭头表示，从子类指向父类。</p>
<p>在Java代码中，对象之间的泛化关系可以直接翻译为关键字 extends。</p>
<img src="images/v2-04064db11797cf36229d67407fea1b83_1440w.webp" alt="img" style="zoom:50%;" />

<h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系（Implementation）是指接口及其实现类之间的关系。</p>
<p>在UML类图中，实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口。</p>
<p>在Java代码中，实现关系可以直接翻译为关键字 implements。</p>
<img src="images/v2-616c153ec74d496a811ac50c83c3653c_1440w.webp" alt="img" style="zoom:50%;" />

<h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。</p>
<p>关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</p>
<p>在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象，这就是导航性（Navigatity）。</p>
<p>在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用作为自己的成员变量，也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。</p>
<img src="images/v2-3f331f3dc075abb4215413014688638f_1440w.webp" alt="img" style="zoom:50%;" />

<p>一个对象可以持有其它对象的数组或者集合。在UML中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。多重性允许的表达式示例如下：</p>
<ul>
<li>数字 ：精确的数量</li>
<li>* 或者 0..* ：表示0到多个</li>
<li>0..1 ：表示0或者1个，在Java中经常用一个空引用来实现</li>
<li>1..* ：表示1到多个</li>
</ul>
<p>关联关系又分为依赖关联、聚合关联和组合关联三种类型。</p>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖（Dependency）关系是一种弱关联关系。只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。</p>
<p>如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。</p>
<p>在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用。</p>
<p>依赖关系在Java中的具体代码表现形式为B为A的构造器或方法中的局部变量、方法或构造器的参数、方法的返回值，或者A调用B的静态方法。</p>
<img src="images/v2-431e044bbf26778a20dd788968e22aac_1440w.webp" alt="img" style="zoom:50%;" />

<h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系，此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。</p>
<p>例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。</p>
<p>在UML图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方。</p>
<img src="images/v2-82cb160ed1566d1d04ea320575b54d5f_1440w.webp" alt="img" style="zoom:50%;" />

<h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。</p>
<p>如果A组合B，则A需要知道B的生存周期，即可能A负责生成或者释放B，或者A通过某种途径知道B的生成和释放。例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。</p>
<p>在UML图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方。</p>
<img src="images/v2-e651244eeca9c0881cbdd2add429e850_1440w.webp" alt="img" style="zoom:50%;" />

<p>在Java代码形式上，聚合和组合关系中的部分对象是整体对象的一个成员变量。但是，在实际应用开发时，两个对象之间的关系到底是聚合还是组合，有时候很难区别。在Java中，仅从类代码本身是区分不了聚合和组合的。如果一定要区分，那么如果在删除整体对象的时候，必须删掉部分对象，那么就是组合关系，否则可能就是聚合关系。从业务角度上来看，如果作为整体的对象必须要部分对象的参与，才能完成自己的职责，那么二者之间就是组合关系，否则就是聚合关系。</p>
<p>例如，汽车与轮胎，汽车作为整体，轮胎作为部分。如果用在二手车销售业务环境下，二者之间就是聚合关系。因为轮胎作为汽车的一个组成部分，它和汽车可以分别生产以后装配起来使用，但汽车可以换新轮胎，轮胎也可以卸下来给其它汽车使用。如果用在驾驶系统业务环境上，汽车如果没有轮胎，就无法完成行驶任务，二者之间就是一个组合关系。再比如网上书店业务中的订单和订单项之间的关系，如果订单没有订单项，也就无法完成订单的业务，所以二者之间是组合关系。而购物车和商品之间的关系，因为商品的生命周期并不被购物车控制，商品可以被多个购物车共享，因此，二者之间是聚合关系。</p>
<h1 id="3-设计模式七大原则"><a href="#3-设计模式七大原则" class="headerlink" title="3 设计模式七大原则"></a>3 设计模式七大原则</h1><h2 id="3-1-单一职责原则"><a href="#3-1-单一职责原则" class="headerlink" title="3.1 单一职责原则"></a>3.1 单一职责原则</h2><p>对类来说的，一个类应该只负责一项职责。</p>
<p>如类 A 负责两个不同职责：职责 1，职责2。当职责1需求变更而改变 A 时，可能造成职责2执行错误，所以需要将类 A 的粒度分解为A1，A2。</p>
<h2 id="3-2-接口隔离原则"><a href="#3-2-接口隔离原则" class="headerlink" title="3.2 接口隔离原则"></a>3.2 接口隔离原则</h2><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在范围最小的接口上。</p>
<img src="images/image-20221015224041919.png" alt="image-20221015224041919" style="zoom:50%;" />

<p>类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口Interface1 对于类A和类C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法。</p>
<p>按隔离原则应当这样处理：将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)，类 A 和类C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p>介绍：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是面向接口编程</li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类</li>
<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</li>
</ol>
<p>依赖关系传递的三种方式：</p>
<ol>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方法传递</li>
</ol>
<h2 id="3-4-里氏替换原则"><a href="#3-4-里氏替换原则" class="headerlink" title="3.4 里氏替换原则"></a>3.4 里氏替换原则</h2><p>引入：</p>
<ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li>
<li>问题提出：在编程中，如何正确的使用继承? </li>
</ol>
<p>介绍：</p>
<ol>
<li>里氏替换原则(Liskov Substitution Principle)在 1988 年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>如果对每个类型为 T1 的对象 o1，都有类型为 T2 的对象 o2，使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</li>
<li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法</li>
<li>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。</li>
</ol>
<h2 id="3-5-开闭原则"><a href="#3-5-开闭原则" class="headerlink" title="3.5 开闭原则"></a>3.5 开闭原则</h2><p>介绍：</p>
<ol>
<li>编程中最基础、最重要的设计原则</li>
<li>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。</li>
<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</li>
<li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则</li>
</ol>
<h2 id="3-6-迪米特法则"><a href="#3-6-迪米特法则" class="headerlink" title="3.6 迪米特法则"></a>3.6 迪米特法则</h2><p>介绍：</p>
<ol>
<li>一个对象应该对其他对象保持最少的了解</li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：只与直接的朋友通信</li>
<li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<h2 id="3-7-合成复用原则"><a href="#3-7-合成复用原则" class="headerlink" title="3.7 合成复用原则"></a>3.7 合成复用原则</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承：</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ol>
<h1 id="4-单例模式"><a href="#4-单例模式" class="headerlink" title="4 单例模式"></a>4 单例模式</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>单例模式（Singleton Pattern）属于创建型模式，是 Java 中最简单的设计模式之一。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意：</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：当您想控制实例数目，节省系统资源的时候。</p>
<p>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>应用实例：</p>
<ul>
<li>一个班级只有一个班主任。</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ul>
<p>优点：</p>
<ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>使用场景：</p>
<ul>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
<li>Spring中的bean默认为单例模式。</li>
</ul>
<h2 id="4-2-实现：不推荐使用"><a href="#4-2-实现：不推荐使用" class="headerlink" title="4.2 实现：不推荐使用"></a>4.2 实现：不推荐使用</h2><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><pre><code class="java">class Singleton &#123;
    // 1. 构造器私有化，外部不能new
    private Singleton() &#123;
    &#125;

    // 2. 本类内部创建对象实例
    private final static Singleton instance = new Singleton();

    // 3. 对外提供一个公有静态方法返回实例对象
    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
 * 2) 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费
 * 3) 这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果
 * 4) 结论：这种单例模式可用，可能造成内存浪费
 */</code></pre>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><pre><code class="java">class Singleton &#123;
    // 1. 构造器私有化，外部不能new
    private Singleton() &#123;
    &#125;


    private static Singleton instance;

    // 2. 静态代码块中创建对象实例
    static &#123;
        instance = new Singleton();
    &#125;

    // 3. 对外提供一个公有静态方法返回实例对象
    public static Singleton getInstance() &#123;
        return instance;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
 * 2) 结论：这种单例模式可用，但是可能造成内存浪费
 */</code></pre>
<h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><pre><code class="java">class Singleton &#123;

    private static Singleton instance;

    private Singleton() &#123;
    &#125;

    // 提供一个静态公有方法，调用该方法时采取进行实例化
    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) 起到了 Lazy Loading 的效果，但是只能在单线程下使用。
 * 2) 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式
 * 3) 结论：在实际开发中，不要使用这种方式.
 */</code></pre>
<h3 id="懒汉式（线程安全，同步方法）"><a href="#懒汉式（线程安全，同步方法）" class="headerlink" title="懒汉式（线程安全，同步方法）"></a>懒汉式（线程安全，同步方法）</h3><pre><code class="java">class Singleton &#123;

    private static Singleton instance;

    private Singleton() &#123;
    &#125;

    // 提供一个静态公有方法，调用该方法时采取进行实例化
    // 加锁
    public static synchronized Singleton getInstance() &#123;
        if (instance == null) &#123;
            instance = new Singleton();
        &#125;
        return instance;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) 解决了线程安全问题
 * 2) 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低
 * 3) 结论：在实际开发中，不推荐使用这种方式
 */</code></pre>
<h3 id="懒汉式（线程安全，同步代码块）"><a href="#懒汉式（线程安全，同步代码块）" class="headerlink" title="懒汉式（线程安全，同步代码块）"></a>懒汉式（线程安全，同步代码块）</h3><pre><code class="java">class Singleton &#123;

    private static Singleton instance;

    private Singleton() &#123;
    &#125;

    // 提供一个静态公有方法，调用该方法时采取进行实例化
    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            // 加锁
            synchronized (Singleton.class) &#123;
                instance = new Singleton();
            &#125;
        &#125;
        return instance;
    &#125;
&#125;

/**
 * 和type3一样存在线程安全问题，不推荐
 */</code></pre>
<h2 id="4-3-实现：推荐使用"><a href="#4-3-实现：推荐使用" class="headerlink" title="4.3 实现：推荐使用"></a>4.3 实现：推荐使用</h2><h3 id="双重检查（线程安全，推荐使用）"><a href="#双重检查（线程安全，推荐使用）" class="headerlink" title="双重检查（线程安全，推荐使用）"></a>双重检查（线程安全，推荐使用）</h3><pre><code class="java">class Singleton &#123;

    // volatile保证可见性
    private static volatile Singleton instance;

    private Singleton() &#123;
    &#125;

    // 提供一个静态公有方法，调用该方法时采取进行实例化
    public static Singleton getInstance() &#123;
        if (instance == null) &#123;
            // 加锁
            synchronized (Singleton.class) &#123;
                // 第二次检查
                if (instance == null) &#123;
                    instance = new Singleton();
                &#125;
            &#125;
        &#125;
        return instance;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。
 * 2) 这样，实例化代码只用执行一次，后面再次访问时，判断 if (singleton == null)，直接return 实例化对象，也避免的反复进行方法同步.
 * 3) 线程安全；延迟加载；效率较高
 * 4) 结论：在实际开发中，推荐使用这种单例设计模式
 */</code></pre>
<h3 id="静态内部类（线程安全，推荐使用）"><a href="#静态内部类（线程安全，推荐使用）" class="headerlink" title="静态内部类（线程安全，推荐使用）"></a>静态内部类（线程安全，推荐使用）</h3><pre><code class="java">class Singleton &#123;

    private static volatile Singleton instance;

    private Singleton() &#123;
    &#125;

    // 写一个静态内部类，该类中有一个静态属性Singleton
    private static class SingletonInstance &#123;
        private static final Singleton INSTANCE = new Singleton();
    &#125;

    public static Singleton getInstance() &#123;
        return SingletonInstance.INSTANCE;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
 * 2) 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。
 * 3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
 * 4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高
 * 5) 结论：推荐使用.
 */</code></pre>
<h3 id="枚举（线程安全，推荐使用）"><a href="#枚举（线程安全，推荐使用）" class="headerlink" title="枚举（线程安全，推荐使用）"></a>枚举（线程安全，推荐使用）</h3><pre><code class="java">enum Singleton &#123;
    INSTANCE;
    public void whateverMethod() &#123;
    &#125;
&#125;

/**
 * 优缺点说明：
 * 1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
 * 2) 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式
 * 3) 结论：推荐使用
 */</code></pre>
<h1 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5 工厂模式"></a>5 工厂模式</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>工厂模式（Factory Pattern）属于创建型模式，是 Java 中最常用的设计模式之一。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>主要解决：主要解决接口选择的问题。</p>
<p>何时使用：我们明确地计划不同条件下创建不同实例时。</p>
<p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p>关键代码：创建过程在其子类执行。</p>
<p>应用实例： </p>
<ul>
<li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</li>
<li>Spring 换数据库只需换驱动就可以。</li>
</ul>
<p>优点： </p>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。 </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p>使用场景： </p>
<ul>
<li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</li>
<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</li>
<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</li>
</ul>
<p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h2 id="5-2-实现：简单工厂模式"><a href="#5-2-实现：简单工厂模式" class="headerlink" title="5.2 实现：简单工厂模式"></a>5.2 实现：简单工厂模式</h2><p>Simple Factory，该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：</p>
<p><img src="images/1419489-20190628144601084-563759643.png" alt="img"></p>
<p>以生产手机为例，首先定义产品相关接口和类：</p>
<pre><code class="java">/**
 * Phone类：手机标准规范类（AbstractProduct）
 */
public interface Phone &#123;
    void make();
&#125;

/**
 * MiPhone类：制造小米手机（Product1）
 */
public class MiPhone implements Phone&#123;
    public MiPhone() &#123;
        this.make();
    &#125;
    @Override
    public void make() &#123;
        System.out.println(&quot;make xiaomi phone!&quot;);
    &#125;
&#125;

/**
 * IPhone类：制造苹果手机（Product2）
 */
public class IPhone implements Phone&#123;
    public IPhone() &#123;
        this.make();
    &#125;
    @Override
    public void make() &#123;
        System.out.println(&quot;make iphone!&quot;);
    &#125;
&#125;</code></pre>
<p>下面创建简单工厂并测试：</p>
<pre><code class="java">/**
 * PhoneFactory类：手机代工厂（Factory）
 */
public class PhoneFactory &#123;
    public Phone makePhone(String phoneType) &#123;
        if (phoneType.equalsIgnoreCase(&quot;MiPhone&quot;)) &#123;
            return new MiPhone();
        &#125;
        if (phoneType.equalsIgnoreCase(&quot;iPhone&quot;)) &#123;
            return new IPhone();
        &#125;
        return null;
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">/**
 * Test
 */
public class SimpleFactoryTest &#123;
    public static void main(String[] args) &#123;
        PhoneFactory factory = new PhoneFactory();
        Phone miPhone = factory.makePhone(&quot;MiPhone&quot;);            // make xiaomi phone!
        IPhone iPhone = (IPhone)factory.makePhone(&quot;iPhone&quot;);    // make iphone!
    &#125;
&#125;</code></pre>
<h2 id="5-3-实现：工厂方法模式"><a href="#5-3-实现：工厂方法模式" class="headerlink" title="5.3 实现：工厂方法模式"></a>5.3 实现：工厂方法模式</h2><p>Factory Method，和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p>
<p><img src="images/1419489-20190628154133368-906051111.png" alt="img"></p>
<p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂，这样不用通过指定类型来创建对象了。</p>
<p>接下来继续使用生产手机的例子来讲解该模式。其中和产品相关的Phone类、MiPhone类和IPhone类的定义不变。</p>
<p>创建工厂方法并测试：</p>
<pre><code class="java">/**
 * AbstractFactory类：生产不同产品的工厂的抽象类
 */
public interface AbstractFactory &#123;
    Phone makePhone();
&#125;

/**
 * XiaoMiFactory类：生产小米手机的工厂（ConcreteFactory1）
 */
public class XiaoMiFactory implements AbstractFactory&#123;

    @Override
    public Phone makePhone() &#123;
        return new MiPhone();
    &#125;
&#125;

/**
 * AppleFactory类：生产苹果手机的工厂（ConcreteFactory2）
 */
public class AppleFactory implements AbstractFactory&#123;
    @Override
    public Phone makePhone() &#123;
        return new IPhone();
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">/**
 * Test
 */
public class FactoryMethodTest &#123;
    public static void main(String[] args) &#123;
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        appleFactory.makePhone();        // make iphone!
    &#125;
&#125;</code></pre>
<h2 id="5-4-实现：抽象工厂模式"><a href="#5-4-实现：抽象工厂模式" class="headerlink" title="5.4 实现：抽象工厂模式"></a>5.4 实现：抽象工厂模式</h2><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品Phone（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p>
<p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC，但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p>
<p>Abstract Factory模式，通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。其UML类图如下：</p>
<p><img src="images/1419489-20190628170705865-1781414242.png" alt="img"></p>
<p>新增PC产品的接口和类：</p>
<pre><code class="java">/**
 * PC类：定义PC产品的接口(AbstractPC)
 */
public interface PC &#123;
    void make();
&#125;

/**
 * MiPC类：定义小米电脑产品(MIPC)
 */
public class MiPC implements PC &#123;
    public MiPC() &#123;
        this.make();
    &#125;
    @Override
    public void make() &#123;
        System.out.println(&quot;make xiaomi PC!&quot;);
    &#125;
&#125;

/**
 * MAC类：定义苹果电脑产品(MAC)
 */
public class MAC implements PC &#123;
    public MAC() &#123;
        this.make();
    &#125;
    @Override
    public void make() &#123;
        System.out.println(&quot;make MAC!&quot;);
    &#125;
&#125;</code></pre>
<p>下面需要修改工厂相关的类的定义使之成为抽象工厂：</p>
<pre><code class="java">/**
 * AbstractFactory类：增加PC产品制造接口
 */
public interface AbstractFactory &#123;
    Phone makePhone();
    PC makePC();
&#125;

/**
 * XiaoMiFactory类：增加小米PC的制造（ConcreteFactory1）
 */
public class XiaoMiFactory implements AbstractFactory &#123;

    @Override
    public Phone makePhone() &#123;
        return new MiPhone();
    &#125;

    @Override
    public PC makePC() &#123;
        return new MiPC();
    &#125;
&#125;

/**
 * AppleFactory类：增加苹果PC的制造（ConcreteFactory2）
 */
public class AppleFactory implements AbstractFactory &#123;
    @Override
    public Phone makePhone() &#123;
        return new IPhone();
    &#125;

    @Override
    public PC makePC() &#123;
        return new MAC();
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">/**
 * Test
 */
public class AbstractFactoryTest &#123;
    public static void main(String[] args) &#123;
        AbstractFactory miFactory = new XiaoMiFactory();
        AbstractFactory appleFactory = new AppleFactory();
        miFactory.makePhone();            // make xiaomi phone!
        miFactory.makePC();                // make xiaomi PC!
        appleFactory.makePhone();        // make iphone!
        appleFactory.makePC();            // make MAC!
    &#125;
&#125;</code></pre>
<h1 id="6-原型模式"><a href="#6-原型模式" class="headerlink" title="6 原型模式"></a>6 原型模式</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><p>原型模式（Prototype Pattern）属于创建型模式，用于创建重复的对象，同时又能保证性能。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>主要解决：在运行期建立和删除原型。</p>
<p>何时使用： </p>
<ul>
<li>当一个系统应该独立于它的产品创建，构成和表示时。 </li>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。 </li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时。 </li>
<li>当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
</ul>
<p>如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<p>关键代码： </p>
<ul>
<li>实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，或通过序列化的方式来实现深拷贝。 </li>
<li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</li>
</ul>
<p>应用实例： </p>
<ul>
<li>细胞分裂。 </li>
<li>JAVA 中的 Object clone() 方法。</li>
</ul>
<p>优点： </p>
<ul>
<li>性能提高。 </li>
<li>逃避构造函数的约束。</li>
</ul>
<p>缺点： </p>
<ul>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 </li>
<li>必须实现 Cloneable 接口。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>资源优化场景。 </li>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 </li>
<li>性能和安全要求的场景。 </li>
<li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 </li>
<li>一个对象多个修改者的场景。 </li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 </li>
<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。</li>
<li>Spring指定bean的type为prototype</li>
</ul>
<p>注意事项：与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写 clone 方法，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h2 id="6-2-实现：浅拷贝"><a href="#6-2-实现：浅拷贝" class="headerlink" title="6.2 实现：浅拷贝"></a>6.2 实现：浅拷贝</h2><p>克隆羊问题，首先创建Sheep类并重写clone方法：</p>
<pre><code class="java">public class Sheep implements Cloneable &#123;
    private String name;
    private int age;
    private String color;
    private String address = &quot;蒙古羊&quot;;
    public Sheep friend; // 对象, 克隆会如何处理？
    public Sheep(String name, int age, String color) &#123;
        super();
        this.name = name;
        this.age = age;
        this.color = color;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getColor() &#123;
        return color;
    &#125;
    public void setColor(String color) &#123;
        this.color = color;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Sheep [name=&quot; + name + &quot;, age=&quot; + age + &quot;, color=&quot; + color + &quot;, address=&quot; + address + &quot;]&quot;;
    &#125;
    //克隆该实例，使用默认的clone方法来完成
    @Override
    protected Object clone()  &#123;
        Sheep sheep = null;
        try &#123;
            sheep = (Sheep)super.clone();
        &#125; catch (Exception e) &#123;
            System.out.println(e.getMessage());
        &#125;
        return sheep;
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;原型模式完成对象的创建&quot;);
        // TODO Auto-generated method stub
        Sheep sheep = new Sheep(&quot;tom&quot;, 1, &quot;白色&quot;);

        sheep.friend = new Sheep(&quot;jack&quot;, 2, &quot;黑色&quot;);

        Sheep sheep2 = (Sheep)sheep.clone(); //克隆
        Sheep sheep3 = (Sheep)sheep.clone(); //克隆
        Sheep sheep4 = (Sheep)sheep.clone(); //克隆
        Sheep sheep5 = (Sheep)sheep.clone(); //克隆

        System.out.println(&quot;sheep2 =&quot; + sheep2 + &quot;sheep2.friend=&quot; + sheep2.friend.hashCode());
        System.out.println(&quot;sheep3 =&quot; + sheep3 + &quot;sheep3.friend=&quot; + sheep3.friend.hashCode());
        System.out.println(&quot;sheep4 =&quot; + sheep4 + &quot;sheep4.friend=&quot; + sheep4.friend.hashCode());
        System.out.println(&quot;sheep5 =&quot; + sheep5 + &quot;sheep5.friend=&quot; + sheep5.friend.hashCode());
    &#125;
&#125;</code></pre>
<h2 id="6-3-实现：深拷贝"><a href="#6-3-实现：深拷贝" class="headerlink" title="6.3 实现：深拷贝"></a>6.3 实现：深拷贝</h2><p>上面的测试中，会发现对于成员变量friend，克隆出来的羊都拿到的是同一个对象，说明对于他们内部为引用类型的属性，并没有进行拷贝，而只是让引用变量指向了同一个对象。</p>
<p>对于浅拷贝：</p>
<ul>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li>
<li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li>
</ul>
<p>对于深拷贝：</p>
<ul>
<li>复制对象的所有基本数据类型的成员变量值。</li>
<li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝。</li>
</ul>
<p>深拷贝实现方式：</p>
<ol>
<li><p>重写 clone 方法来实现深拷贝</p>
</li>
<li><p>通过对象序列化实现深拷贝(推荐)</p>
</li>
</ol>
<pre><code class="java">public class DeepCloneableTarget implements Serializable, Cloneable &#123;
    private static final long serialVersionUID = 1L;

    private String cloneName;

    private String cloneClass;

    // 构造器
    public DeepCloneableTarget(String cloneName, String cloneClass) &#123;
        this.cloneName = cloneName;
        this.cloneClass = cloneClass;
    &#125;

    // 因为该类的属性，都是String , 因此我们这里使用默认的clone完成即可
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        return super.clone();
    &#125;
&#125;

public class DeepProtoType implements Serializable, Cloneable&#123;

    public String name; // String 属性
    public DeepCloneableTarget deepCloneableTarget; // 引用类型
    public DeepProtoType() &#123;
        super();
    &#125;

    // 深拷贝 - 方式 1 使用clone 方法
    @Override
    protected Object clone() throws CloneNotSupportedException &#123;
        Object deep = null;
        // 这里完成对基本数据类型(属性)和String的克隆
        deep = super.clone(); 
        // 对引用类型的属性，进行单独处理
        DeepProtoType deepProtoType = (DeepProtoType)deep;
        deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();
        // TODO Auto-generated method stub
        return deepProtoType;
    &#125;

    // 深拷贝 - 方式2 通过对象的序列化实现 (推荐)
    public Object deepClone() &#123;
        // 创建流对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        try &#123;
            // 序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this); //当前这个对象以对象流的方式输出
            // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            DeepProtoType copyObj = (DeepProtoType)ois.readObject();
            return copyObj;
        &#125; catch (Exception e) &#123;
            // TODO: handle exception
            e.printStackTrace();
            return null;
        &#125; finally &#123;
            // 关闭流
            try &#123;
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            &#125; catch (Exception e2) &#123;
                // TODO: handle exception
                System.out.println(e2.getMessage());
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="7-建造者模式"><a href="#7-建造者模式" class="headerlink" title="7 建造者模式"></a>7 建造者模式</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p>建造者模式（Builder Pattern）属于创建型模式，使用多个简单的对象一步一步构建成一个复杂的对象。</p>
<p>一个 Builder 类会一步一步构造最终的对象，该 Builder 类是独立于其他对象的。</p>
<p>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p>主要解决：在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>何时使用：一些基本部件不会变，而其组合经常变化的时候。</p>
<p>如何解决：将变与不变分离开。</p>
<p>关键代码：</p>
<ul>
<li>Builder：创建和提供实例</li>
<li>Director：管理建造出来的实例的依赖关系</li>
</ul>
<p>应用实例： </p>
<ul>
<li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</li>
<li>JAVA 中的 StringBuilder。</li>
</ul>
<p>优点：</p>
<ul>
<li>建造者独立，易扩展。</li>
<li>便于控制细节风险。</li>
</ul>
<p>缺点： </p>
<ul>
<li>产品必须有共同点，范围有限制。 </li>
<li>如内部变化复杂，会有很多的建造类。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>需要生成的对象具有复杂的内部结构。 </li>
<li>要生成的对象内部属性本身相互依赖。</li>
</ul>
<p>注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<h2 id="7-2-实现"><a href="#7-2-实现" class="headerlink" title="7.2 实现"></a>7.2 实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo 类使用 MealBuilder 来创建一个 Meal。</p>
<p><img src="images/20210315-builder-pattern.svg" alt="建造者模式的 UML 图"></p>
<p>创建一个表示食物条目和食物包装的接口:</p>
<pre><code class="java">public interface Item &#123;
   public String name();
   public Packing packing();
   public float price();    
&#125;

public interface Packing &#123;
   public String pack();
&#125;</code></pre>
<p>创建实现 Packing 接口的实体类：</p>
<pre><code class="java">public class Wrapper implements Packing &#123;

   @Override
   public String pack() &#123;
      return &quot;Wrapper&quot;;
   &#125;
&#125;

public class Bottle implements Packing &#123;

   @Override
   public String pack() &#123;
      return &quot;Bottle&quot;;
   &#125;
&#125;</code></pre>
<p>创建实现 Item 接口的抽象类，该类提供了默认的功能：</p>
<pre><code class="java">public abstract class Burger implements Item &#123;

   @Override
   public Packing packing() &#123;
      return new Wrapper();
   &#125;

   @Override
   public abstract float price();
&#125;

public abstract class ColdDrink implements Item &#123;

    @Override
    public Packing packing() &#123;
       return new Bottle();
    &#125;

    @Override
    public abstract float price();
&#125;</code></pre>
<p>创建扩展了 Burger 和 ColdDrink 的实体类：</p>
<pre><code class="java">public class VegBurger extends Burger &#123;

   @Override
   public float price() &#123;
      return 25.0f;
   &#125;

   @Override
   public String name() &#123;
      return &quot;Veg Burger&quot;;
   &#125;
&#125;

public class ChickenBurger extends Burger &#123;

   @Override
   public float price() &#123;
      return 50.5f;
   &#125;

   @Override
   public String name() &#123;
      return &quot;Chicken Burger&quot;;
   &#125;
&#125;

public class Coke extends ColdDrink &#123;

   @Override
   public float price() &#123;
      return 30.0f;
   &#125;

   @Override
   public String name() &#123;
      return &quot;Coke&quot;;
   &#125;
&#125;

public class Pepsi extends ColdDrink &#123;

   @Override
   public float price() &#123;
      return 35.0f;
   &#125;

   @Override
   public String name() &#123;
      return &quot;Pepsi&quot;;
   &#125;
&#125;</code></pre>
<p>创建一个 Meal 类，带有上面定义的 Item 对象：</p>
<pre><code class="java">public class Meal &#123;
   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    

   public void addItem(Item item)&#123;
      items.add(item);
   &#125;

   public float getCost()&#123;
      float cost = 0.0f;
      for (Item item : items) &#123;
         cost += item.price();
      &#125;        
      return cost;
   &#125;

   public void showItems()&#123;
      for (Item item : items) &#123;
         System.out.print(&quot;Item : &quot;+item.name());
         System.out.print(&quot;, Packing : &quot;+item.packing().pack());
         System.out.println(&quot;, Price : &quot;+item.price());
      &#125;        
   &#125;    
&#125;</code></pre>
<p>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象：</p>
<pre><code class="java">public class MealBuilder &#123;

   public Meal prepareVegMeal ()&#123;
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   &#125;   

   public Meal prepareNonVegMeal ()&#123;
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class BuilderPatternDemo &#123;
   public static void main(String[] args) &#123;
      MealBuilder mealBuilder = new MealBuilder();

      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println(&quot;Veg Meal&quot;);
      vegMeal.showItems();
      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());

      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println(&quot;\n\nNon-Veg Meal&quot;);
      nonVegMeal.showItems();
      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());
   &#125;
&#125;</code></pre>
<p>这里的实际Builder其实是Meal类，它负责创建和提供实例，但是核心确是担当Director的MealBuilder类，调用者直接使用它来点餐，然后它的内部去按照一定逻辑和顺序调用实际Builder的方法来完成客户的需求。</p>
<h1 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8 适配器模式"></a>8 适配器模式</h1><h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h2><p>适配器模式（Adapter Pattern）属于结构型模式，是作为两个不兼容的接口之间的桥梁，结合了两个独立接口的功能。</p>
<p>意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p>何时使用： </p>
<ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要。 </li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 </li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</li>
</ul>
<p>如何解决：继承或依赖（推荐）。</p>
<p>关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p>应用实例： </p>
<ul>
<li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 </li>
<li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 </li>
<li>在 LINUX 上运行 WINDOWS 程序。 </li>
<li>JAVA 中的 jdbc。</li>
</ul>
<p>优点： </p>
<ul>
<li>可以让任何两个没有关联的类一起运行。 </li>
<li>提高了类的复用。 </li>
<li>增加了类的透明度。 </li>
<li>灵活性好。</li>
</ul>
<p>缺点： </p>
<ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 </li>
<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li>
</ul>
<p>使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p>注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h2 id="8-2-实现"><a href="#8-2-实现" class="headerlink" title="8.2 实现"></a>8.2 实现</h2><p>直接拿Java里的Callable接口来看，我们已经有一个Task类，实现了Callable接口：</p>
<pre><code class="java">public class Task implements Callable&lt;Long&gt; &#123;
    private long num;
    public Task(long num) &#123;
        this.num = num;
    &#125;

    public Long call() throws Exception &#123;
        long r = 0;
        for (long n = 1; n &lt;= this.num; n++) &#123;
            r = r + n;
        &#125;
        System.out.println(&quot;Result: &quot; + r);
        return r;
    &#125;
&#125;</code></pre>
<p>现在，我们想通过一个线程去执行它：</p>
<pre><code class="java">Callable&lt;Long&gt; callable = new Task(123450000L);
Thread thread = new Thread(callable); // compile error!
thread.start();</code></pre>
<p>编译不过！因为Thread接收Runnable接口，但不接收Callable接口，肿么办？</p>
<p>不改写Task类的情况下，用一个Adapter，把这个Callable接口“变成”Runnable接口：</p>
<pre><code class="java">public class RunnableAdapter implements Runnable &#123;
    // 引用待转换接口:
    private Callable&lt;?&gt; callable;

    public RunnableAdapter(Callable&lt;?&gt; callable) &#123;
        this.callable = callable;
    &#125;

    // 实现指定接口:
    public void run() &#123;
        // 将指定接口调用委托给转换接口调用:
        try &#123;
            callable.call();
        &#125; catch (Exception e) &#123;
            throw new RuntimeException(e);
        &#125;
    &#125;
&#125;</code></pre>
<p>这样一来，Thread就可以接收这个RunnableAdapter，因为它实现了Runnable接口。Thread作为调用方，它会调用RunnableAdapter的run()方法，在这个run()方法内部，又调用了Callable的call()方法，相当于Thread通过一层转换，间接调用了Callable的call()方法。</p>
<pre><code class="java">Callable&lt;Long&gt; callable = new Task(123450000L);
Thread thread = new Thread(new RunnableAdapter(callable));
thread.start();</code></pre>
<p>事实上在JDK中是FutureTask完成了这个任务。</p>
<p>此外，Spring MVC中DispatcherServlet 调用 HandlerAdapter适配执行 Handler也使用了适配器模式。</p>
<h1 id="9-桥接模式"><a href="#9-桥接模式" class="headerlink" title="9 桥接模式"></a>9 桥接模式</h1><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h2><p>桥接（Bridge）属于结构型模式，用于把抽象化与实现化解耦，使得二者可以独立变化，它通过提供抽象化和实现化之间的桥接结构来实现二者的解耦。</p>
<p>意图：将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p>主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p>何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p>如何解决：把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p>关键代码：抽象类依赖实现类。</p>
<p>应用实例： </p>
<ul>
<li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 </li>
<li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</li>
</ul>
<p>优点： </p>
<ul>
<li>抽象和实现的分离。 </li>
<li>优秀的扩展能力。 </li>
<li>实现细节对客户透明。</li>
</ul>
<p>缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p>使用场景： </p>
<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 </li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 </li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
</ul>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h2 id="9-2-实现"><a href="#9-2-实现" class="headerlink" title="9.2 实现"></a>9.2 实现</h2><p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p>
<img src="images/image-20221018134740838.png" alt="image-20221018134740838" style="zoom:50%;" />

<p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。所以，桥接模式就是为了避免直接继承带来的子类爆炸。在桥接模式中，首先把Car按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。</p>
<img src="images/image-20221018134943141.png" alt="image-20221018134943141" style="zoom:50%;" />

<p>首先定义抽象类Car，它引用一个Engine：</p>
<pre><code class="java">public abstract class Car &#123;
    // 引用Engine:
    protected Engine engine;

    public Car(Engine engine) &#123;
        this.engine = engine;
    &#125;

    public abstract void drive();
&#125;</code></pre>
<p>Engine的定义如下：</p>
<pre><code class="java">public interface Engine &#123;
    void start();
&#125;</code></pre>
<p>紧接着，在一个“修正”的抽象类RefinedCar中定义一些额外操作：</p>
<pre><code class="java">public abstract class RefinedCar extends Car &#123;
    public RefinedCar(Engine engine) &#123;
        super(engine);
    &#125;

    public void drive() &#123;
        this.engine.start();
        System.out.println(&quot;Drive &quot; + getBrand() + &quot; car...&quot;);
    &#125;

    public abstract String getBrand();
&#125;</code></pre>
<p>这样一来，最终的不同品牌继承自RefinedCar，例如BossCar：</p>
<pre><code class="java">public class BossCar extends RefinedCar &#123;
    public BossCar(Engine engine) &#123;
        super(engine);
    &#125;

    public String getBrand() &#123;
        return &quot;Boss&quot;;
    &#125;
&#125;</code></pre>
<p>而针对每一种引擎，继承自Engine，例如HybridEngine：</p>
<pre><code class="java">public class HybridEngine implements Engine &#123;
    public void start() &#123;
        System.out.println(&quot;Start Hybrid Engine...&quot;);
    &#125;
&#125;</code></pre>
<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p>
<pre><code class="java">RefinedCar car = new BossCar(new HybridEngine());
car.drive();</code></pre>
<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对Engine派生一个新的子类，如果要增加一个品牌，只需要针对RefinedCar派生一个子类，任何RefinedCar的子类都可以和任何一种Engine自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>
<h1 id="10-装饰器模式"><a href="#10-装饰器模式" class="headerlink" title="10 装饰器模式"></a>10 装饰器模式</h1><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1 介绍"></a>10.1 介绍</h2><p>装饰器模式（Decorator Pattern）属于结构型模式，允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p>何时使用：在不想增加很多子类的情况下扩展类。</p>
<p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p>
<p>关键代码： </p>
<ul>
<li>Component 类充当抽象角色，不应该负责具体实现。 </li>
<li>修饰类引用和继承 Component 类，具体扩展类重写父类方法。</li>
</ul>
<p>应用实例： </p>
<ul>
<li>孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 </li>
<li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</li>
<li>Java的IO流充斥大量装饰器。</li>
</ul>
<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>缺点：多层装饰比较复杂。</p>
<p>使用场景： </p>
<ul>
<li>扩展一个类的功能。 </li>
<li>动态增加功能，动态撤销。</li>
</ul>
<p>注意事项：可代替继承。</p>
<h2 id="10-2-实现"><a href="#10-2-实现" class="headerlink" title="10.2 实现"></a>10.2 实现</h2><p>比如奶茶店有很多奶茶，我去点一杯波霸奶茶，奶茶里面可以加各种配料，我需要在我的波霸奶茶里面加珍珠、椰果配料，这时候就可以使用装饰器模式</p>
<p>抽象构件(Component)角色奶茶：</p>
<pre><code class="java">public interface IMilkytea &#123;

    void addDosing();

&#125;</code></pre>
<p>具体构件(ConcreteComponent)角色波霸奶茶：</p>
<pre><code class="java">public class BoBaMilkytea implements IMilkytea &#123;
    @Override
    public void addDosing() &#123;
        System.out.println(&quot;波霸奶茶&quot;);
    &#125;
&#125;</code></pre>
<p>装饰角色配料：</p>
<pre><code class="java">public abstract class Dosing implements IMilkytea&#123;

    protected  IMilkytea imilkytea;

    public Dosing(IMilkytea imilkytea) &#123;
        this.imilkytea = imilkytea;
    &#125;

    @Override
    public void addDosing() &#123;
        this.imilkytea.addDosing();
    &#125;
&#125;</code></pre>
<p>具体装饰角色珍珠、椰果：</p>
<pre><code class="java">public class NataDeCoCo extends Dosing&#123;
    public NataDeCoCo(IMilkytea imilkytea) &#123;
        super(imilkytea);
    &#125;

    @Override
    public void addDosing() &#123;
        super.addDosing();
        System.out.println(&quot;加椰果&quot;);
    &#125;
&#125;

public class Pearl extends Dosing&#123;
    public Pearl(IMilkytea imilkytea) &#123;
        super(imilkytea);
    &#125;

    @Override
    public void addDosing() &#123;
        super.addDosing();
        System.out.println(&quot;加珍珠&quot;);
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args) &#123;
        BoBaMilkytea boBaMilkytea = new BoBaMilkytea();
        Pearl pearl = new Pearl(boBaMilkytea);
        NataDeCoCo nataDeCoCo = new NataDeCoCo(pearl);
        nataDeCoCo.addDosing();
    &#125;
&#125;</code></pre>
<h1 id="11-组合模式"><a href="#11-组合模式" class="headerlink" title="11 组合模式"></a>11 组合模式</h1><h2 id="11-1-介绍"><a href="#11-1-介绍" class="headerlink" title="11.1 介绍"></a>11.1 介绍</h2><p>组合模式（Composite Pattern）属于结构型模式，又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>意图：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p>何时使用： </p>
<ul>
<li>您想表示对象的部分-整体层次结构（树形结构）。 </li>
<li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ul>
<p>如何解决：树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p>关键代码：树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p>应用实例： </p>
<ul>
<li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 </li>
</ul>
<p>优点： </p>
<ul>
<li>高层模块调用简单。 </li>
<li>节点自由增加。</li>
</ul>
<p>缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<p>使用场景：部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<p>注意事项：定义时为具体类。</p>
<h2 id="11-2-实现"><a href="#11-2-实现" class="headerlink" title="11.2 实现"></a>11.2 实现</h2><p>编写程序展示一个学校院系结构：需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。</p>
<p>抽象组合类OrganizationComponent：</p>
<pre><code class="java">public abstract class OrganizationComponent &#123;

    private String name; // 名字
    private String des; // 说明

    protected  void add(OrganizationComponent organizationComponent) &#123;
        //默认实现
        throw new UnsupportedOperationException();
    &#125;

    protected  void remove(OrganizationComponent organizationComponent) &#123;
        //默认实现
        throw new UnsupportedOperationException();
    &#125;

    //构造器
    public OrganizationComponent(String name, String des) &#123;
        super();
        this.name = name;
        this.des = des;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getDes() &#123;
        return des;
    &#125;

    public void setDes(String des) &#123;
        this.des = des;
    &#125;

    //方法print, 做成抽象的, 子类都需要实现
    protected abstract void print();


&#125;</code></pre>
<p>大学类University：</p>
<pre><code class="java">//University 就是 Composite , 可以管理College
public class University extends OrganizationComponent &#123;

    List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;();

    // 构造器
    public University(String name, String des) &#123;
        super(name, des);
        // TODO Auto-generated constructor stub
    &#125;

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) &#123;
        // TODO Auto-generated method stub
        organizationComponents.add(organizationComponent);
    &#125;

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) &#123;
        // TODO Auto-generated method stub
        organizationComponents.remove(organizationComponent);
    &#125;

    @Override
    public String getName() &#123;
        // TODO Auto-generated method stub
        return super.getName();
    &#125;

    @Override
    public String getDes() &#123;
        // TODO Auto-generated method stub
        return super.getDes();
    &#125;

    // print方法，就是输出University 包含的学院
    @Override
    protected void print() &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;--------------&quot; + getName() + &quot;--------------&quot;);
        //遍历 organizationComponents 
        for (OrganizationComponent organizationComponent : organizationComponents) &#123;
            organizationComponent.print();
        &#125;
    &#125;
&#125;</code></pre>
<p>学院College：</p>
<pre><code class="java">public class College extends OrganizationComponent &#123;

    //List 中 存放的Department
    List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;();

    // 构造器
    public College(String name, String des) &#123;
        super(name, des);
        // TODO Auto-generated constructor stub
    &#125;

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) &#123;
        // TODO Auto-generated method stub
        //  将来实际业务中，Colleage 的 add 和  University add 不一定完全一样
        organizationComponents.add(organizationComponent);
    &#125;

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) &#123;
        // TODO Auto-generated method stub
        organizationComponents.remove(organizationComponent);
    &#125;

    @Override
    public String getName() &#123;
        // TODO Auto-generated method stub
        return super.getName();
    &#125;

    @Override
    public String getDes() &#123;
        // TODO Auto-generated method stub
        return super.getDes();
    &#125;

    // print方法，就是输出University 包含的学院
    @Override
    protected void print() &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;--------------&quot; + getName() + &quot;--------------&quot;);
        //遍历 organizationComponents 
        for (OrganizationComponent organizationComponent : organizationComponents) &#123;
            organizationComponent.print();
        &#125;
    &#125;
&#125;</code></pre>
<p>专业Department：</p>
<pre><code class="java">public class Department extends OrganizationComponent &#123;

    //没有集合

    public Department(String name, String des) &#123;
        super(name, des);
        // TODO Auto-generated constructor stub
    &#125;

    //add , remove 就不用写了，因为他是叶子节点

    @Override
    public String getName() &#123;
        // TODO Auto-generated method stub
        return super.getName();
    &#125;

    @Override
    public String getDes() &#123;
        // TODO Auto-generated method stub
        return super.getDes();
    &#125;

    @Override
    protected void print() &#123;
        // TODO Auto-generated method stub
        System.out.println(getName());
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class Client &#123;

    public static void main(String[] args) &#123;
        // TODO Auto-generated method stub

        //从大到小创建对象 学校
        OrganizationComponent university = new University(&quot;清华大学&quot;, &quot; 中国顶级大学 &quot;);

        //创建 学院
        OrganizationComponent computerCollege = new College(&quot;计算机学院&quot;, &quot; 计算机学院 &quot;);
        OrganizationComponent infoEngineercollege = new College(&quot;信息工程学院&quot;, &quot; 信息工程学院 &quot;);


        //创建各个学院下面的系(专业)
        computerCollege.add(new Department(&quot;软件工程&quot;, &quot; 软件工程不错 &quot;));
        computerCollege.add(new Department(&quot;网络工程&quot;, &quot; 网络工程不错 &quot;));
        computerCollege.add(new Department(&quot;计算机科学与技术&quot;, &quot; 计算机科学与技术是老牌的专业 &quot;));

        //
        infoEngineercollege.add(new Department(&quot;通信工程&quot;, &quot; 通信工程不好学 &quot;));
        infoEngineercollege.add(new Department(&quot;信息工程&quot;, &quot; 信息工程好学 &quot;));

        //将学院加入到 学校
        university.add(computerCollege);
        university.add(infoEngineercollege);

        //university.print();
        infoEngineercollege.print();
    &#125;

&#125;</code></pre>
<h1 id="12-外观模式"><a href="#12-外观模式" class="headerlink" title="12 外观模式"></a>12 外观模式</h1><h2 id="12-1-介绍"><a href="#12-1-介绍" class="headerlink" title="12.1 介绍"></a>12.1 介绍</h2><p>外观模式（Facade Pattern）属于结构型模式，隐藏系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p>意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>主要解决：降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p>
<p>何时使用： </p>
<ul>
<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 </li>
<li>定义系统的入口。</li>
</ul>
<p>如何解决：客户端不与系统耦合，外观类与系统耦合。</p>
<p>关键代码：在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<p>应用实例： </p>
<ul>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 </li>
<li>JAVA 的MVC三层开发模式。</li>
</ul>
<p>优点： </p>
<ul>
<li>减少系统相互依赖。 </li>
<li>提高灵活性。 </li>
<li>提高了安全性。</li>
</ul>
<p>缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p>使用场景： </p>
<ul>
<li>为复杂的模块或子系统提供外界访问的模块。 </li>
<li>子系统相对独立。 </li>
<li>预防低水平人员带来的风险。</li>
</ul>
<p>注意事项：在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<h2 id="12-2-实现"><a href="#12-2-实现" class="headerlink" title="12.2 实现"></a>12.2 实现</h2><p>家庭影院有多个设备，基于外观模式创建一个统一接口供调用者使用，以此来屏蔽内部系统操作的复杂性。</p>
<p>创建各种设备：</p>
<pre><code class="java">public class DVDPlayer &#123;

    //使用单例模式, 使用饿汉式
    private static DVDPlayer instance = new DVDPlayer();

    public static DVDPlayer getInstanc() &#123;
        return instance;
    &#125;

    public void on() &#123;
        System.out.println(&quot; dvd on &quot;);
    &#125;
    public void off() &#123;
        System.out.println(&quot; dvd off &quot;);
    &#125;

    public void play() &#123;
        System.out.println(&quot; dvd is playing &quot;);
    &#125;

    public void pause() &#123;
        System.out.println(&quot; dvd pause ..&quot;);
    &#125;    
&#125;

public class Projector &#123;

    private static Projector instance = new Projector();

    public static Projector getInstance() &#123;
        return instance;
    &#125;

    public void on() &#123;
        System.out.println(&quot; Projector on &quot;);
    &#125;

    public void off() &#123;
        System.out.println(&quot; Projector ff &quot;);
    &#125;

    public void focus() &#123;
        System.out.println(&quot; Projector is Projector  &quot;);
    &#125;  
&#125;

public class Screen &#123;

    private static Screen instance = new Screen();

    public static Screen getInstance() &#123;
        return instance;
    &#125;

    public void up() &#123;
        System.out.println(&quot; Screen up &quot;);
    &#125;

    public void down() &#123;
        System.out.println(&quot; Screen down &quot;);
    &#125;    
&#125;

public class Stereo &#123;

    private static Stereo instance = new Stereo();

    public static Stereo getInstance() &#123;
        return instance;
    &#125;

    public void on() &#123;
        System.out.println(&quot; Stereo on &quot;);
    &#125;

    public void off() &#123;
        System.out.println(&quot; Screen off &quot;);
    &#125;

    public void up() &#123;
        System.out.println(&quot; Screen up.. &quot;);
    &#125;    
&#125;

public class TheaterLight &#123;

    private static TheaterLight instance = new TheaterLight();

    public static TheaterLight getInstance() &#123;
        return instance;
    &#125;

    public void on() &#123;
        System.out.println(&quot; TheaterLight on &quot;);
    &#125;

    public void off() &#123;
        System.out.println(&quot; TheaterLight off &quot;);
    &#125;

    public void dim() &#123;
        System.out.println(&quot; TheaterLight dim.. &quot;);
    &#125;

    public void bright() &#123;
        System.out.println(&quot; TheaterLight bright.. &quot;);
    &#125;  
&#125;

public class Popcorn &#123;

    private static Popcorn instance = new Popcorn();

    public static Popcorn getInstance() &#123;
        return instance;
    &#125;

    public void on() &#123;
        System.out.println(&quot; popcorn on &quot;);
    &#125;

    public void off() &#123;
        System.out.println(&quot; popcorn ff &quot;);
    &#125;

    public void pop() &#123;
        System.out.println(&quot; popcorn is poping  &quot;);
    &#125;
&#125;</code></pre>
<p>创建外观类，负责各种设备的具体使用，并对外提供调用接口：</p>
<pre><code class="java">public class HomeTheaterFacade &#123;

    //定义各个子系统对象
    private TheaterLight theaterLight;
    private Popcorn popcorn;
    private Stereo stereo;
    private Projector projector;
    private Screen screen;
    private DVDPlayer dVDPlayer;


    //构造器
    public HomeTheaterFacade() &#123;
        super();
        this.theaterLight = TheaterLight.getInstance();
        this.popcorn = Popcorn.getInstance();
        this.stereo = Stereo.getInstance();
        this.projector = Projector.getInstance();
        this.screen = Screen.getInstance();
        this.dVDPlayer = DVDPlayer.getInstanc();
    &#125;

    //操作分成 4 步

    public void ready() &#123;
        popcorn.on();
        popcorn.pop();
        screen.down();
        projector.on();
        stereo.on();
        dVDPlayer.on();
        theaterLight.dim();
    &#125;

    public void play() &#123;
        dVDPlayer.play();
    &#125;

    public void pause() &#123;
        dVDPlayer.pause();
    &#125;

    public void end() &#123;
        popcorn.off();
        theaterLight.bright();
        screen.up();
        projector.off();
        stereo.off();
        dVDPlayer.off();
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) &#123;
        HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();
        homeTheaterFacade.ready();
        homeTheaterFacade.play();
        homeTheaterFacade.end();
    &#125;
&#125;</code></pre>
<h1 id="13-享元模式"><a href="#13-享元模式" class="headerlink" title="13 享元模式"></a>13 享元模式</h1><h2 id="13-1-介绍"><a href="#13-1-介绍" class="headerlink" title="13.1 介绍"></a>13.1 介绍</h2><p>享元模式（Flyweight Pattern）属于结构型模式，主要用于减少创建对象的数量，重用现有的同类对象，以减少内存占用和提高性能。</p>
<p>意图：运用共享技术有效地支持大量细粒度的对象。</p>
<p>主要解决：在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p>何时使用： </p>
<ul>
<li>系统中有大量对象。 </li>
<li>这些对象消耗大量内存。 </li>
<li>这些对象的状态大部分可以外部化。 </li>
<li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 </li>
<li>系统不依赖于这些对象身份，这些对象是不可分辨的。</li>
</ul>
<p>如何解决：用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p>关键代码：用 HashMap 等容器存储这些对象。</p>
<p>应用实例： </p>
<ul>
<li><p>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 </p>
</li>
<li><p>数据库连接池，线程池等。</p>
</li>
</ul>
<p>优点：大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p>缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p>使用场景： </p>
<ul>
<li>系统有大量相似对象。 </li>
<li>需要缓冲池的场景。</li>
</ul>
<p>注意事项： </p>
<ul>
<li>注意划分外部状态和内部状态，否则可能会引起线程安全问题。 </li>
<li>这些类必须有一个工厂对象加以控制。</li>
</ul>
<h2 id="13-2-实现"><a href="#13-2-实现" class="headerlink" title="13.2 实现"></a>13.2 实现</h2><p>假设我们需要创建一个新的网站，一般来说都不需要从头开始搭建，因为有现成的网站模版，我们只需要拿过来对其稍做修改，则可以上线发布新网站。</p>
<p>网站抽象类和具体的某个网站框架：</p>
<pre><code class="java">public abstract class WebSite &#123;
    public abstract void use(User user);
&#125;

public class ConcreteWebSite extends WebSite &#123;

    //共享的部分，内部状态
    private String type = &quot;&quot;; //网站发布的形式(类型)

    //构造器
    public ConcreteWebSite(String type) &#123;

        this.type = type;
    &#125;

    @Override
    public void use(User user) &#123;
        // TODO Auto-generated method stub
        System.out.println(&quot;网站的发布形式为:&quot; + type + &quot; 在使用中 .. 使用者是&quot; + user.getName());
    &#125;
&#125;</code></pre>
<p>网站工厂类，根据需要返回一个网站：</p>
<pre><code class="java">public class WebSiteFactory &#123;
    //集合， 充当池的作用
    private HashMap&lt;String, ConcreteWebSite&gt; pool = new HashMap&lt;&gt;();

    //根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回
    public WebSite getWebSiteCategory(String type) &#123;
        if(!pool.containsKey(type)) &#123;
            //就创建一个网站，并放入到池中
            pool.put(type, new ConcreteWebSite(type));
        &#125;
        return (WebSite)pool.get(type);
    &#125;

    //获取网站分类的总数 (池中有多少个网站类型)
    public int getWebSiteCount() &#123;
        return pool.size();
    &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class User &#123;
    private String name;

    public User(String name) &#123;
        super();
        this.name = name;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;

public class Client &#123;
    public static void main(String[] args) &#123;
        // 创建一个工厂类
        WebSiteFactory factory = new WebSiteFactory();

        // 客户要一个以新闻形式发布的网站
        WebSite webSite1 = factory.getWebSiteCategory(&quot;新闻&quot;);
        webSite1.use(new User(&quot;tom&quot;));

        // 客户要一个以博客形式发布的网站
        WebSite webSite2 = factory.getWebSiteCategory(&quot;博客&quot;);
        webSite2.use(new User(&quot;jack&quot;));

        // 客户要一个以博客形式发布的网站
        WebSite webSite3 = factory.getWebSiteCategory(&quot;博客&quot;);
        webSite3.use(new User(&quot;smith&quot;));

        // 客户要一个以博客形式发布的网站
        WebSite webSite4 = factory.getWebSiteCategory(&quot;博客&quot;);
        webSite4.use(new User(&quot;king&quot;));

        System.out.println(&quot;网站的分类共=&quot; + factory.getWebSiteCount());
    &#125;
&#125;</code></pre>
<h1 id="14-代理模式"><a href="#14-代理模式" class="headerlink" title="14 代理模式"></a>14 代理模式</h1><h2 id="14-1-介绍"><a href="#14-1-介绍" class="headerlink" title="14.1 介绍"></a>14.1 介绍</h2><p>在代理模式（Proxy Pattern）属于结构型模式，一个类代表另一个类的功能，在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>意图：为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p>何时使用：想在访问一个类时做一些控制。</p>
<p>如何解决：增加中间层。</p>
<p>关键代码：实现与被代理类组合。</p>
<p>应用实例： </p>
<ul>
<li>Windows 里面的快捷方式。 </li>
<li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 </li>
<li>买火车票不一定在火车站买，也可以去代售点。 </li>
<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 </li>
<li>spring aop。</li>
</ul>
<p>优点： </p>
<ul>
<li>职责清晰。 </li>
<li>高扩展性。 </li>
<li>智能化。</li>
</ul>
<p>缺点： </p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 </li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ul>
<p>使用场景：按职责来划分，通常有以下使用场景： </p>
<ul>
<li>远程代理。 </li>
<li>虚拟代理。 </li>
<li>Copy-on-Write 代理。 </li>
<li>保护（Protect or Access）代理。 </li>
<li>Cache代理。 </li>
<li>防火墙（Firewall）代理。 </li>
<li>同步化（Synchronization）代理。 </li>
<li>智能引用（Smart Reference）代理。</li>
</ul>
<p>注意事项： </p>
<ul>
<li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 </li>
<li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li>
</ul>
<h2 id="14-2-实现：静态代理"><a href="#14-2-实现：静态代理" class="headerlink" title="14.2 实现：静态代理"></a>14.2 实现：静态代理</h2><p>场景假设：电影是电影公司委托给影院进行播放的，但是影院可以在播放电影之前或之后，产生一些自己的经济收益，比如提供按摩椅，娃娃机，卖爆米花、饮料，在影片开始结束阶段都会播放广告等。</p>
<p>播放电影的接口：</p>
<pre><code class="java">public interface Movie &#123;
    void play();
&#125;</code></pre>
<p>实现了该接口，放映《美国队长》的被代理类：</p>
<pre><code class="java">public class CaptainAmericaMovie implements Movie &#123;
    @Override
    public void play() &#123;
        System.out.println(&quot;普通影厅正在播放的电影是《美国队长》&quot;);
    &#125;
&#125;</code></pre>
<p>实现了该接口，电影院放映电影的代理类：</p>
<pre><code class="java">public class MovieStaticProxy implements Movie &#123;
    Movie movie;

    public MovieStaticProxy(Movie movie) &#123;
        this.movie = movie;
    &#125;

    @Override
    public void play() &#123;
        playStart();
        movie.play();
        playEnd();
    &#125;

    public void playStart() &#123;
        System.out.println(&quot;电影开始前正在播放广告&quot;);
    &#125;
    public void playEnd() &#123;
        System.out.println(&quot;电影结束了，接续播放广告&quot;);
    &#125;
&#125;</code></pre>
<p>测试类：</p>
<pre><code class="java">public class StaticProxyTest &#123;
    public static void main(String[] args) &#123;
        Movie captainAmericaMovie = new CaptainAmericaMovie();
        Movie movieStaticProxy = new MovieStaticProxy(captainAmericaMovie);
        movieStaticProxy.play();
    &#125;
&#125;</code></pre>
<p>运行结果：</p>
<pre><code>电影开始前正在播放广告
正在播放的电影是《美国队长》
电影结束了，接续播放广告</code></pre>
<h2 id="14-3-实现：JDK动态代理"><a href="#14-3-实现：JDK动态代理" class="headerlink" title="14.3 实现：JDK动态代理"></a>14.3 实现：JDK动态代理</h2><p>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。<code>java.lang.reflect</code>包中的 <code>Proxy</code>类和<code>InvocationHandler</code>接口提供了生成动态代理类的能力。 </p>
<p>场景假设：刚看完《美国队长》不过瘾，还想继续去看一场《钢铁侠》。一直在普通影厅看电影觉得没啥意思，选择去VIP影厅体验一把。</p>
<p>VIP影厅播放电影的接口：</p>
<pre><code class="java">public interface VIPMovie &#123;
    void vipPlay();
&#125;</code></pre>
<p>VIP影厅播放《钢铁侠》的被代理类：</p>
<pre><code class="java">public class IronManVIPMovie implements VIPMovie &#123;
    @Override
    public void vipPlay() &#123;
        System.out.println(&quot;VIP影厅正在播放的电影是《钢铁侠》&quot;);
    &#125;
&#125;</code></pre>
<p>创建用来实现动态代理的Invocation Handler：</p>
<pre><code class="java">public class MyInvocationHandler implements InvocationHandler &#123;

    private Object object;

    public MyInvocationHandler(Object object) &#123;
        this.object = object;
    &#125;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        playStart();
        Object invoke = method.invoke(object, args);
        playEnd();
        return invoke;
    &#125;

    public void playStart() &#123;
        System.out.println(&quot;电影开始前正在播放广告&quot;);
    &#125;
    public void playEnd() &#123;
        System.out.println(&quot;电影结束了，接续播放广告&quot;);
    &#125;
&#125;</code></pre>
<p>测试类：（为了体现此时代理的动态性，我们可以用同样的Invocation Handler再看一遍之前普通影厅播放的美国队长）</p>
<pre><code class="java">public class DynamicProxyTest &#123;
    public static void main(String[] args) &#123;
        // VIP 影厅《钢铁侠》
        IronManVIPMovie ironManVIPMovie = new IronManVIPMovie();
        InvocationHandler invocationHandler = new MyInvocationHandler(ironManVIPMovie);
        VIPMovie dynamicProxy = (VIPMovie) Proxy.newProxyInstance(IronManVIPMovie.class.getClassLoader(), 
                                                                  IronManVIPMovie.class.getInterfaces(), 
                                                                  invocationHandler);
        dynamicProxy.vipPlay();

        // 普通影厅《美国队长》
        CaptainAmericaMovie captainAmericaMovie = new CaptainAmericaMovie();
        InvocationHandler invocationHandler1 = new MyInvocationHandler(captainAmericaMovie);
        Movie dynamicProxy1 = (Movie) Proxy.newProxyInstance(CaptainAmericaMovie.class.getClassLoader(), 
                                                             CaptainAmericaMovie.class.getInterfaces(), 
                                                             invocationHandler1);
        dynamicProxy1.play();
    &#125;
&#125;</code></pre>
<p>输出结果：</p>
<pre><code>电影开始前正在播放广告
VIP影厅正在播放的电影是《钢铁侠》
电影结束了，接续播放广告
电影开始前正在播放广告
正在播放的电影是《美国队长》
电影结束了，接续播放广告</code></pre>
<p>通过<code>Proxy.newProxyInstance()</code>方法，产生了Movie和VIPMovie两种接口实现类代理。<code>Proxy</code>是动态代理实现的关键，在生成代理类之前加上下面的代码可以查看通过反射动态生成的代理类：</p>
<pre><code class="java">public static void main(String[] args) &#123;
    System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);
    // VIP 影厅《钢铁侠》
    ...
    // 普通影厅《美国队长》
    ...
    System.out.println(&quot;VIP 影厅《钢铁侠》代理类：&quot;+dynamicProxy.getClass());
    System.out.println(&quot;普通影厅《美国队长》：&quot;+dynamicProxy1.getClass());
&#125;</code></pre>
<p>输出：</p>
<pre><code>IP 影厅《钢铁侠》代理类：class com.sun.proxy.$Proxy0
普通影厅《美国队长》：class com.sun.proxy.$Proxy1</code></pre>
<h2 id="14-4-实现：CGLIB动态代理"><a href="#14-4-实现：CGLIB动态代理" class="headerlink" title="14.4 实现：CGLIB动态代理"></a>14.4 实现：CGLIB动态代理</h2><p>CGLIB可以实现关于类的动态代理。CGLIB是一个强大、高性能、高质量的代码生成类库，它可以在运行期扩展Java类与实现Java接口：</p>
<ul>
<li>用CGLIB生成的代理类是被代理类的子类。</li>
<li>用CGLIB生成代理类不需要接口。</li>
<li>用CGLIB生成的代理类重写了父类的各个方法。</li>
<li>拦截器中的<code>intercept()</code>方法内容正好就是代理类中的方法体。</li>
</ul>
<p>引入CGLIB依赖：</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>放映《美国队长2》的被代理类：（注意：此时没有实现Movie接口）</p>
<pre><code class="java">public class CaptainAmerica2MovieImpl &#123;
    public void play()&#123;
        System.out.println(&quot;正在播放的电影是《美国队长2》&quot;);
    &#125;
&#125;</code></pre>
<p>创建一个自定义MethodInterceptor:</p>
<pre><code class="java">public class CglibProxyInterceptor implements MethodInterceptor &#123;
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        playStart();
        Object object = methodProxy.invokeSuper(o, objects);
        playEnd();
        return object;
    &#125;

    public void playStart() &#123;
        System.out.println(&quot;电影开始前正在播放广告&quot;);
    &#125;

    public void playEnd() &#123;
        System.out.println(&quot;电影结束了，接续播放广告&quot;);
    &#125;
&#125;</code></pre>
<p>测试类：</p>
<pre><code class="java">public class CglibProxyTest &#123;
    public static void main(String[] args) &#123;
        // 在指定目录下生成动态代理类
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;C:\\class&quot;);
        // 创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
        Enhancer enhancer = new Enhancer();
        // 设置目标类的字节码文件
        enhancer.setSuperclass(CaptainAmerica2MovieImpl.class);
        // 设置回调函数
        enhancer.setCallback(new CglibProxyInterceptor());
        //这里的creat方法就是正式创建代理类
        CaptainAmerica2MovieImpl captainAmerica2Movie = (CaptainAmerica2MovieImpl)enhancer.create();
        // 调用代理类的play方法
        captainAmerica2Movie.play();
        System.out.println(&quot;cglib动态代理《美国队长2》：&quot;+captainAmerica2Movie.getClass());
    &#125;
&#125;</code></pre>
<p>输出结果：</p>
<pre><code>电影开始前正在播放广告
正在播放的电影是《美国队长2》
电影结束了，接续播放广告
cglib动态代理《美国队长2》：class com.workit.demo.proxy.CaptainAmerica2MovieImpl$$EnhancerByCGLIB$$5c3ddcfe</code></pre>
<h1 id="15-模版方法模式"><a href="#15-模版方法模式" class="headerlink" title="15 模版方法模式"></a>15 模版方法模式</h1><h2 id="15-1-介绍"><a href="#15-1-介绍" class="headerlink" title="15.1 介绍"></a>15.1 介绍</h2><p>模板模式（Template Pattern）属于行为型模式，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>意图：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>主要解决：一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p>何时使用：有一些通用的方法。</p>
<p>如何解决：将这些通用算法抽象出来。</p>
<p>关键代码：在抽象类实现，其他步骤在子类实现。</p>
<p>应用实例： </p>
<ul>
<li>在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 </li>
<li>西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 </li>
<li>spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</li>
</ul>
<p>优点： </p>
<ul>
<li>封装不变部分，扩展可变部分。 </li>
<li>提取公共代码，便于维护。 </li>
<li>行为由父类控制，子类实现。</li>
</ul>
<p>缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p>使用场景： </p>
<ul>
<li>有多个子类共有的方法，且逻辑相同。 </li>
<li>重要的、复杂的方法，可以考虑作为模板方法。</li>
</ul>
<p>注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<h2 id="15-2-实现"><a href="#15-2-实现" class="headerlink" title="15.2 实现"></a>15.2 实现</h2><p>我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。</p>
<pre><code class="java">public abstract class Game &#123;
   abstract void initialize();
   abstract void startPlay();
   abstract void endPlay();

   //模板
   public final void play()&#123;

      //初始化游戏
      initialize();

      //开始游戏
      startPlay();

      //结束游戏
      endPlay();
   &#125;
&#125;

public class Cricket extends Game &#123;

   @Override
   void endPlay() &#123;
      System.out.println(&quot;Cricket Game Finished!&quot;);
   &#125;

   @Override
   void initialize() &#123;
      System.out.println(&quot;Cricket Game Initialized! Start playing.&quot;);
   &#125;

   @Override
   void startPlay() &#123;
      System.out.println(&quot;Cricket Game Started. Enjoy the game!&quot;);
   &#125;
&#125;

public class Football extends Game &#123;

   @Override
   void endPlay() &#123;
      System.out.println(&quot;Football Game Finished!&quot;);
   &#125;

   @Override
   void initialize() &#123;
      System.out.println(&quot;Football Game Initialized! Start playing.&quot;);
   &#125;

   @Override
   void startPlay() &#123;
      System.out.println(&quot;Football Game Started. Enjoy the game!&quot;);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class TemplatePatternDemo &#123;
   public static void main(String[] args) &#123;

      Game game = new Cricket();
      game.play();
      System.out.println();
      game = new Football();
      game.play();      
   &#125;
&#125;</code></pre>
<h1 id="16-命令模式"><a href="#16-命令模式" class="headerlink" title="16 命令模式"></a>16 命令模式</h1><h2 id="16-1-介绍"><a href="#16-1-介绍" class="headerlink" title="16.1 介绍"></a>16.1 介绍</h2><p>命令模式（Command Pattern）属于行为型模式，是一种数据驱动的设计模式，请求以命令的形式包裹在对象中，并传给调用对象，该对象执行命令。</p>
<p>意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p>何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p>如何解决：通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p>
<p>关键代码：定义三个角色：</p>
<ul>
<li>received 真正的命令执行对象 </li>
<li>Command </li>
<li>invoker 使用命令对象的入口</li>
</ul>
<p>应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p>优点： </p>
<ul>
<li>降低了系统耦合度。 </li>
<li>新的命令可以很容易添加到系统中去。</li>
</ul>
<p>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p>使用场景：认为是命令的地方都可以使用命令模式，比如： </p>
<ul>
<li>GUI 中每一个按钮都是一条命令。 </li>
<li>模拟 CMD。</li>
</ul>
<p>注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<h2 id="16-2-实现"><a href="#16-2-实现" class="headerlink" title="16.2 实现"></a>16.2 实现</h2><p>我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。</p>
<p>Broker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。</p>
<p>创建一个命令接口和请求类。</p>
<pre><code class="java">public interface Order &#123;
   void execute();
&#125;

public class Stock &#123;

   private String name = &quot;ABC&quot;;
   private int quantity = 10;

   public void buy()&#123;
      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, 
         Quantity: &quot; + quantity +&quot; ] bought&quot;);
   &#125;
   public void sell()&#123;
      System.out.println(&quot;Stock [ Name: &quot;+name+&quot;, 
         Quantity: &quot; + quantity +&quot; ] sold&quot;);
   &#125;
&#125;   </code></pre>
<p>创建实现了 Order 接口的实体类：</p>
<pre><code class="java">public class BuyStock implements Order &#123;
   private Stock abcStock;

   public BuyStock(Stock abcStock)&#123;
      this.abcStock = abcStock;
   &#125;

   public void execute() &#123;
      abcStock.buy();
   &#125;
&#125;

public class SellStock implements Order &#123;
   private Stock abcStock;

   public SellStock(Stock abcStock)&#123;
      this.abcStock = abcStock;
   &#125;

   public void execute() &#123;
      abcStock.sell();
   &#125;
&#125;</code></pre>
<p>创建命令调用类：</p>
<pre><code class="java">public class Broker &#123;
   private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); 

   public void takeOrder(Order order)&#123;
      orderList.add(order);      
   &#125;

   public void placeOrders()&#123;
      for (Order order : orderList) &#123;
         order.execute();
      &#125;
      orderList.clear();
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class CommandPatternDemo &#123;
   public static void main(String[] args) &#123;
      Stock abcStock = new Stock();

      BuyStock buyStockOrder = new BuyStock(abcStock);
      SellStock sellStockOrder = new SellStock(abcStock);

      Broker broker = new Broker();
      broker.takeOrder(buyStockOrder);
      broker.takeOrder(sellStockOrder);

      broker.placeOrders();
   &#125;
&#125;</code></pre>
<h1 id="17-访问者模式"><a href="#17-访问者模式" class="headerlink" title="17 访问者模式"></a>17 访问者模式</h1><h2 id="17-1-介绍"><a href="#17-1-介绍" class="headerlink" title="17.1 介绍"></a>17.1 介绍</h2><p>访问者模式（Visitor Pattern）属于行为型模式，我们使用了一个访问者类，它改变了元素类的执行算法，通过这种方式，元素的执行算法可以随着访问者改变而改变。</p>
<p>意图：主要将数据结构与数据操作分离。</p>
<p>主要解决：稳定的数据结构和易变的操作耦合问题。</p>
<p>何时使用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p>如何解决：在被访问的类里面加一个对外提供接待访问者的接口。</p>
<p>关键代码：在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<p>应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
<p>优点： </p>
<ul>
<li>符合单一职责原则。 </li>
<li>优秀的扩展性。 </li>
<li>灵活性。</li>
</ul>
<p>缺点： </p>
<ul>
<li>具体元素对访问者公布细节，违反了迪米特原则。 </li>
<li>具体元素变更比较困难。 </li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 </li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<p>注意事项：访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<h2 id="17-2-实现"><a href="#17-2-实现" class="headerlink" title="17.2 实现"></a>17.2 实现</h2><p>我们将创建一个定义接受操作的 ComputerPart 接口。Keyboard、Mouse、Monitor 和 Computer 是实现了 ComputerPart 接口的实体类。我们将定义另一个接口 ComputerPartVisitor，它定义了访问者类的操作。Computer 使用实体访问者来执行相应的动作。</p>
<p>定义一个表示元素的接口：</p>
<pre><code class="java">public interface ComputerPart &#123;
   public void accept(ComputerPartVisitor computerPartVisitor);
&#125;</code></pre>
<p>创建扩展了上述类的实体类：</p>
<pre><code class="java">public class Keyboard  implements ComputerPart &#123;

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      computerPartVisitor.visit(this);
   &#125;
&#125;

public class Monitor  implements ComputerPart &#123;

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      computerPartVisitor.visit(this);
   &#125;
&#125;

public class Mouse  implements ComputerPart &#123;

   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      computerPartVisitor.visit(this);
   &#125;
&#125;

public class Computer implements ComputerPart &#123;

   ComputerPart[] parts;

   public Computer()&#123;
      parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;      
   &#125; 


   @Override
   public void accept(ComputerPartVisitor computerPartVisitor) &#123;
      for (int i = 0; i &lt; parts.length; i++) &#123;
         parts[i].accept(computerPartVisitor);
      &#125;
      computerPartVisitor.visit(this);
   &#125;
&#125;</code></pre>
<p>定义一个表示访问者的接口：</p>
<pre><code class="java">public interface ComputerPartVisitor &#123;
   public void visit(Computer computer);
   public void visit(Mouse mouse);
   public void visit(Keyboard keyboard);
   public void visit(Monitor monitor);
&#125;</code></pre>
<p>创建实现了上述类的实体访问者：</p>
<pre><code class="java">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;

   @Override
   public void visit(Computer computer) &#123;
      System.out.println(&quot;Displaying Computer.&quot;);
   &#125;

   @Override
   public void visit(Mouse mouse) &#123;
      System.out.println(&quot;Displaying Mouse.&quot;);
   &#125;

   @Override
   public void visit(Keyboard keyboard) &#123;
      System.out.println(&quot;Displaying Keyboard.&quot;);
   &#125;

   @Override
   public void visit(Monitor monitor) &#123;
      System.out.println(&quot;Displaying Monitor.&quot;);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class VisitorPatternDemo &#123;
   public static void main(String[] args) &#123;

      ComputerPart computer = new Computer();
      computer.accept(new ComputerPartDisplayVisitor());
   &#125;
&#125;</code></pre>
<h1 id="18-迭代器模式"><a href="#18-迭代器模式" class="headerlink" title="18 迭代器模式"></a>18 迭代器模式</h1><h2 id="18-1-介绍"><a href="#18-1-介绍" class="headerlink" title="18.1 介绍"></a>18.1 介绍</h2><p>迭代器模式（Iterator Pattern）属于行为型模式，是 Java 中非常常用的设计模式，这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p>主要解决：不同的方式来遍历整个整合对象。</p>
<p>何时使用：遍历一个聚合对象。</p>
<p>如何解决：把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p>关键代码：定义接口：hasNext, next。</p>
<p>应用实例：JAVA 中的 iterator。</p>
<p>优点： </p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象。 </li>
<li>迭代器简化了聚合类。 </li>
<li>在同一个聚合上可以有多个遍历。 </li>
<li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li>
</ul>
<p>缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p>使用场景： </p>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。 </li>
<li>需要为聚合对象提供多种遍历方式。 </li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
<p>注意事项：迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h2 id="18-2-实现"><a href="#18-2-实现" class="headerlink" title="18.2 实现"></a>18.2 实现</h2><p>我们将创建一个叙述导航方法的 Iterator 接口和一个返回迭代器的 Container 接口。实现了 Container 接口的实体类将负责实现 Iterator 接口。</p>
<p>创建接口：</p>
<pre><code class="java">public interface Iterator &#123;
   public boolean hasNext();
   public Object next();
&#125;

public interface Container &#123;
   public Iterator getIterator();
&#125;</code></pre>
<p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 NameIterator：</p>
<pre><code class="java">public class NameRepository implements Container &#123;
   public String[] names = &#123;&quot;Robert&quot; , &quot;John&quot; ,&quot;Julie&quot; , &quot;Lora&quot;&#125;;

   @Override
   public Iterator getIterator() &#123;
      return new NameIterator();
   &#125;

   private class NameIterator implements Iterator &#123;

      int index;

      @Override
      public boolean hasNext() &#123;
         if(index &lt; names.length)&#123;
            return true;
         &#125;
         return false;
      &#125;

      @Override
      public Object next() &#123;
         if(this.hasNext())&#123;
            return names[index++];
         &#125;
         return null;
      &#125;     
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class IteratorPatternDemo &#123;

   public static void main(String[] args) &#123;
      NameRepository namesRepository = new NameRepository();

      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;
         String name = (String)iter.next();
         System.out.println(&quot;Name : &quot; + name);
      &#125;  
   &#125;
&#125;</code></pre>
<h1 id="19-观察者模式"><a href="#19-观察者模式" class="headerlink" title="19 观察者模式"></a>19 观察者模式</h1><h2 id="19-1-介绍"><a href="#19-1-介绍" class="headerlink" title="19.1 介绍"></a>19.1 介绍</h2><p>观察者模式（Observer Pattern）属于行为型模式，当对象间存在一对多关系时使用，比如当一个对象被修改时，则会自动通知依赖它的对象。</p>
<p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p>如何解决：使用面向对象技术，可以将这种依赖关系弱化。</p>
<p>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</p>
<p>应用实例： </p>
<ul>
<li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </li>
<li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</li>
</ul>
<p>优点： </p>
<ul>
<li>观察者和被观察者是抽象耦合的。 </li>
<li>建立一套触发机制。</li>
</ul>
<p>缺点： </p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p>注意事项： </p>
<ul>
<li>JAVA 中已经有了对观察者模式的支持类。 </li>
<li>避免循环引用。 </li>
<li>如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</li>
</ul>
<h2 id="19-2-实现"><a href="#19-2-实现" class="headerlink" title="19.2 实现"></a>19.2 实现</h2><p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。</p>
<p>创建 Subject 类：</p>
<pre><code class="java">public class Subject &#123;

   private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();
   private int state;

   public int getState() &#123;
      return state;
   &#125;

   public void setState(int state) &#123;
      this.state = state;
      notifyAllObservers();
   &#125;

   public void attach(Observer observer)&#123;
      observers.add(observer);      
   &#125;

   public void notifyAllObservers()&#123;
      for (Observer observer : observers) &#123;
         observer.update();
      &#125;
   &#125;  
&#125;</code></pre>
<p>创建 Observer 类：</p>
<pre><code class="java">public abstract class Observer &#123;
   protected Subject subject;
   public abstract void update();
&#125;</code></pre>
<p>创建实体观察者类：</p>
<pre><code class="java">public class BinaryObserver extends Observer&#123;

   public BinaryObserver(Subject subject)&#123;
      this.subject = subject;
      this.subject.attach(this);
   &#125;

   @Override
   public void update() &#123;
      System.out.println( &quot;Binary String: &quot; 
      + Integer.toBinaryString( subject.getState() ) ); 
   &#125;
&#125;

public class OctalObserver extends Observer&#123;

   public OctalObserver(Subject subject)&#123;
      this.subject = subject;
      this.subject.attach(this);
   &#125;

   @Override
   public void update() &#123;
     System.out.println( &quot;Octal String: &quot; 
     + Integer.toOctalString( subject.getState() ) ); 
   &#125;
&#125;

public class HexaObserver extends Observer&#123;

   public HexaObserver(Subject subject)&#123;
      this.subject = subject;
      this.subject.attach(this);
   &#125;

   @Override
   public void update() &#123;
      System.out.println( &quot;Hex String: &quot; 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class ObserverPatternDemo &#123;
   public static void main(String[] args) &#123;
      Subject subject = new Subject();

      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);

      System.out.println(&quot;First state change: 15&quot;);   
      subject.setState(15);
      System.out.println(&quot;Second state change: 10&quot;);  
      subject.setState(10);
   &#125;
&#125;</code></pre>
<h1 id="20-中介者模式"><a href="#20-中介者模式" class="headerlink" title="20 中介者模式"></a>20 中介者模式</h1><h2 id="20-1-介绍"><a href="#20-1-介绍" class="headerlink" title="20.1 介绍"></a>20.1 介绍</h2><p>中介者模式（Mediator Pattern）属于行为型模式，用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<p>意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>主要解决：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p>何时使用：多个类相互耦合，形成了网状结构。</p>
<p>如何解决：将上述网状结构分离为星型结构。</p>
<p>关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。</p>
<p>应用实例： </p>
<ul>
<li>中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 </li>
<li>机场调度系统。 </li>
<li>MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</li>
</ul>
<p>优点： </p>
<ul>
<li>降低了类的复杂度，将一对多转化成了一对一。 </li>
<li>各个类之间的解耦。 </li>
<li>符合迪米特原则。</li>
</ul>
<p>缺点：中介者会庞大，变得复杂难以维护。</p>
<p>使用场景： </p>
<ul>
<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 </li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<p>注意事项：不应当在职责混乱的时候使用。</p>
<h2 id="20-2-实现"><a href="#20-2-实现" class="headerlink" title="20.2 实现"></a>20.2 实现</h2><p>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。</p>
<p>创建中介类：</p>
<pre><code class="java">public class ChatRoom &#123;
   public static void showMessage(User user, String message)&#123;
      System.out.println(new Date().toString()
         + &quot; [&quot; + user.getName() +&quot;] : &quot; + message);
   &#125;
&#125;</code></pre>
<p>创建 user 类：</p>
<pre><code class="java">public class User &#123;
   private String name;

   public String getName() &#123;
      return name;
   &#125;

   public void setName(String name) &#123;
      this.name = name;
   &#125;

   public User(String name)&#123;
      this.name  = name;
   &#125;

   public void sendMessage(String message)&#123;
      ChatRoom.showMessage(this,message);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class MediatorPatternDemo &#123;
   public static void main(String[] args) &#123;
      User robert = new User(&quot;Robert&quot;);
      User john = new User(&quot;John&quot;);

      robert.sendMessage(&quot;Hi! John!&quot;);
      john.sendMessage(&quot;Hello! Robert!&quot;);
   &#125;
&#125;</code></pre>
<h1 id="21-备忘录模式"><a href="#21-备忘录模式" class="headerlink" title="21 备忘录模式"></a>21 备忘录模式</h1><h2 id="21-1-介绍"><a href="#21-1-介绍" class="headerlink" title="21.1 介绍"></a>21.1 介绍</h2><p>备忘录模式（Memento Pattern）属于行为型模式，保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<p>意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p>主要解决：所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p>何时使用：很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p>如何解决：通过一个备忘录类专门存储对象状态。</p>
<p>关键代码：客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p>应用实例： </p>
<ul>
<li>后悔药。 </li>
<li>打游戏时的存档。 </li>
<li>Windows 里的 ctrl + z。 </li>
<li>IE 中的后退。 </li>
<li>数据库的事务管理。</li>
</ul>
<p>优点： </p>
<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 </li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
</ul>
<p>缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p>使用场景： </p>
<ul>
<li>需要保存/恢复数据的相关状态场景。 </li>
<li>提供一个可回滚的操作。</li>
</ul>
<p>注意事项： </p>
<ul>
<li>为了符合迪米特原则，还要增加一个管理备忘录的类。 </li>
<li>为了节约内存，可使用原型模式+备忘录模式。</li>
</ul>
<h2 id="22-2-实现"><a href="#22-2-实现" class="headerlink" title="22.2 实现"></a>22.2 实现</h2><p>备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。</p>
<p>创建 Memento 类：</p>
<pre><code class="java">public class Memento &#123;
   private String state;

   public Memento(String state)&#123;
      this.state = state;
   &#125;

   public String getState()&#123;
      return state;
   &#125;  
&#125;</code></pre>
<p>创建 Originator 类：</p>
<pre><code class="java">public class Originator &#123;
   private String state;

   public void setState(String state)&#123;
      this.state = state;
   &#125;

   public String getState()&#123;
      return state;
   &#125;

   public Memento saveStateToMemento()&#123;
      return new Memento(state);
   &#125;

   public void getStateFromMemento(Memento Memento)&#123;
      state = Memento.getState();
   &#125;
&#125;</code></pre>
<p>创建 CareTaker 类：</p>
<pre><code class="java">public class CareTaker &#123;
   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();

   public void add(Memento state)&#123;
      mementoList.add(state);
   &#125;

   public Memento get(int index)&#123;
      return mementoList.get(index);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class MementoPatternDemo &#123;
   public static void main(String[] args) &#123;
      Originator originator = new Originator();
      CareTaker careTaker = new CareTaker();
      originator.setState(&quot;State #1&quot;);
      originator.setState(&quot;State #2&quot;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&quot;State #3&quot;);
      careTaker.add(originator.saveStateToMemento());
      originator.setState(&quot;State #4&quot;);

      System.out.println(&quot;Current State: &quot; + originator.getState());    
      originator.getStateFromMemento(careTaker.get(0));
      System.out.println(&quot;First saved State: &quot; + originator.getState());
      originator.getStateFromMemento(careTaker.get(1));
      System.out.println(&quot;Second saved State: &quot; + originator.getState());
   &#125;
&#125;</code></pre>
<h1 id="22-解释器模式"><a href="#22-解释器模式" class="headerlink" title="22 解释器模式"></a>22 解释器模式</h1><h2 id="22-1-介绍"><a href="#22-1-介绍" class="headerlink" title="22.1 介绍"></a>22.1 介绍</h2><p>解释器模式（Interpreter Pattern）属于行为型模式，提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文，被用在 SQL 解析、符号处理引擎等。</p>
<p>意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p>主要解决：对于一些固定文法构建一个解释句子的解释器。</p>
<p>何时使用：如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p>如何解决：构建语法树，定义终结符与非终结符。</p>
<p>关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p>
<p>应用实例：编译器、运算表达式计算。</p>
<p>优点： </p>
<ul>
<li>可扩展性比较好，灵活。 </li>
<li>增加了新的解释表达式的方式。 </li>
<li>易于实现简单文法。</li>
</ul>
<p>缺点： </p>
<ul>
<li>可利用场景比较少。 </li>
<li>对于复杂的文法比较难维护。 </li>
<li>解释器模式会引起类膨胀。 </li>
<li>解释器模式采用递归调用方法。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 </li>
<li>一些重复出现的问题可以用一种简单的语言来进行表达。 </li>
<li>一个简单语法需要解释的场景。</li>
</ul>
<p>注意事项：可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
<h2 id="22-2-实现-1"><a href="#22-2-实现-1" class="headerlink" title="22.2 实现"></a>22.2 实现</h2><p>我们将创建一个接口 Expression 和实现了 Expression 接口的实体类。定义作为上下文中主要解释器的 TerminalExpression 类。其他的类 OrExpression、AndExpression 用于创建组合式表达式。</p>
<p>创建一个表达式接口：</p>
<pre><code class="java">public interface Expression &#123;
   public boolean interpret(String context);
&#125;</code></pre>
<p>创建实现了上述接口的实体类：</p>
<pre><code class="java">public class TerminalExpression implements Expression &#123;

   private String data;

   public TerminalExpression(String data)&#123;
      this.data = data; 
   &#125;

   @Override
   public boolean interpret(String context) &#123;
      if(context.contains(data))&#123;
         return true;
      &#125;
      return false;
   &#125;
&#125;

public class OrExpression implements Expression &#123;

   private Expression expr1 = null;
   private Expression expr2 = null;

   public OrExpression(Expression expr1, Expression expr2) &#123; 
      this.expr1 = expr1;
      this.expr2 = expr2;
   &#125;

   @Override
   public boolean interpret(String context) &#123;      
      return expr1.interpret(context) || expr2.interpret(context);
   &#125;
&#125;

public class AndExpression implements Expression &#123;

   private Expression expr1 = null;
   private Expression expr2 = null;

   public AndExpression(Expression expr1, Expression expr2) &#123; 
      this.expr1 = expr1;
      this.expr2 = expr2;
   &#125;

   @Override
   public boolean interpret(String context) &#123;      
      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class InterpreterPatternDemo &#123;

   //规则：Robert 和 John 是男性
   public static Expression getMaleExpression()&#123;
      Expression robert = new TerminalExpression(&quot;Robert&quot;);
      Expression john = new TerminalExpression(&quot;John&quot;);
      return new OrExpression(robert, john);    
   &#125;

   //规则：Julie 是一个已婚的女性
   public static Expression getMarriedWomanExpression()&#123;
      Expression julie = new TerminalExpression(&quot;Julie&quot;);
      Expression married = new TerminalExpression(&quot;Married&quot;);
      return new AndExpression(julie, married);    
   &#125;

   public static void main(String[] args) &#123;
      Expression isMale = getMaleExpression();
      Expression isMarriedWoman = getMarriedWomanExpression();

      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));
      System.out.println(&quot;Julie is a married women? &quot; 
      + isMarriedWoman.interpret(&quot;Married Julie&quot;));
   &#125;
&#125;</code></pre>
<h1 id="23-状态模式"><a href="#23-状态模式" class="headerlink" title="23 状态模式"></a>23 状态模式</h1><h2 id="23-1-介绍"><a href="#23-1-介绍" class="headerlink" title="23.1 介绍"></a>23.1 介绍</h2><p>状态模式（State Pattern）属于行为型模式，在这种模式中类的行为是基于它的状态改变的，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<p>意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p>主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p>何时使用：代码中包含大量与对象状态有关的条件语句。</p>
<p>如何解决：将各种具体的状态类抽象出来。</p>
<p>关键代码：通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p>应用实例： </p>
<ul>
<li>打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 </li>
<li>曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</li>
</ul>
<p>优点： </p>
<ul>
<li>封装了转换规则。 </li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。 </li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<p>缺点： </p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 </li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>行为随状态改变而改变的场景。 </li>
<li>条件、分支语句的代替者。</li>
</ul>
<p>注意事项：在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<h2 id="23-2-实现"><a href="#23-2-实现" class="headerlink" title="23.2 实现"></a>23.2 实现</h2><p>我们将创建一个 State 接口和实现了 State 接口的实体状态类。Context 是一个带有某个状态的类。</p>
<p>创建一个接口：</p>
<pre><code class="java">public interface State &#123;
   public void doAction(Context context);
&#125;</code></pre>
<p>创建实现接口的实体类：</p>
<pre><code class="java">public class StartState implements State &#123;

   public void doAction(Context context) &#123;
      System.out.println(&quot;Player is in start state&quot;);
      context.setState(this); 
   &#125;

   public String toString()&#123;
      return &quot;Start State&quot;;
   &#125;
&#125;

public class StopState implements State &#123;

   public void doAction(Context context) &#123;
      System.out.println(&quot;Player is in stop state&quot;);
      context.setState(this); 
   &#125;

   public String toString()&#123;
      return &quot;Stop State&quot;;
   &#125;
&#125;</code></pre>
<p>创建 Context 类：</p>
<pre><code class="java">public class Context &#123;
   private State state;

   public Context()&#123;
      state = null;
   &#125;

   public void setState(State state)&#123;
      this.state = state;     
   &#125;

   public State getState()&#123;
      return state;
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class StatePatternDemo &#123;
   public static void main(String[] args) &#123;
      Context context = new Context();

      StartState startState = new StartState();
      startState.doAction(context);

      System.out.println(context.getState().toString());

      StopState stopState = new StopState();
      stopState.doAction(context);

      System.out.println(context.getState().toString());
   &#125;
&#125;</code></pre>
<h1 id="24-策略模式"><a href="#24-策略模式" class="headerlink" title="24 策略模式"></a>24 策略模式</h1><h2 id="24-1-介绍"><a href="#24-1-介绍" class="headerlink" title="24.1 介绍"></a>24.1 介绍</h2><p>策略模式（Strategy Pattern）属于行为型模式，在这种模式中，一个类的行为或其算法可以在运行时更改，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象，策略对象改变 context 对象的执行算法。</p>
<p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p>
<p>关键代码：实现同一个接口。</p>
<p>应用实例： </p>
<ul>
<li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 </li>
<li>旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 </li>
<li>JAVA AWT 中的 LayoutManager。</li>
</ul>
<p>优点： </p>
<ul>
<li>算法可以自由切换。 </li>
<li>避免使用多重条件判断。 </li>
<li>扩展性良好。</li>
</ul>
<p>缺点： </p>
<ul>
<li>策略类会增多。 </li>
<li>所有策略类都需要对外暴露。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li>
<li>一个系统需要动态地在几种算法中选择一种。 </li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
</ul>
<p>注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h2 id="24-2-实现"><a href="#24-2-实现" class="headerlink" title="24.2 实现"></a>24.2 实现</h2><p>我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。</p>
<p>创建一个接口：</p>
<pre><code class="java">public interface Strategy &#123;
   public int doOperation(int num1, int num2);
&#125;</code></pre>
<p>创建实现接口的实体类：</p>
<pre><code class="java">public class OperationAdd implements Strategy&#123;
   @Override
   public int doOperation(int num1, int num2) &#123;
      return num1 + num2;
   &#125;
&#125;

public class OperationSubtract implements Strategy&#123;
   @Override
   public int doOperation(int num1, int num2) &#123;
      return num1 - num2;
   &#125;
&#125;

public class OperationMultiply implements Strategy&#123;
   @Override
   public int doOperation(int num1, int num2) &#123;
      return num1 * num2;
   &#125;
&#125;</code></pre>
<p>创建 Context 类：</p>
<pre><code class="java">public class Context &#123;
   private Strategy strategy;

   public Context(Strategy strategy)&#123;
      this.strategy = strategy;
   &#125;

   public int executeStrategy(int num1, int num2)&#123;
      return strategy.doOperation(num1, num2);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class StrategyPatternDemo &#123;
   public static void main(String[] args) &#123;
      Context context = new Context(new OperationAdd());    
      System.out.println(&quot;10 + 5 = &quot; + context.executeStrategy(10, 5));

      context = new Context(new OperationSubtract());      
      System.out.println(&quot;10 - 5 = &quot; + context.executeStrategy(10, 5));

      context = new Context(new OperationMultiply());    
      System.out.println(&quot;10 * 5 = &quot; + context.executeStrategy(10, 5));
   &#125;
&#125;</code></pre>
<h1 id="25-责任链模式"><a href="#25-责任链模式" class="headerlink" title="25 责任链模式"></a>25 责任链模式</h1><h2 id="25-1-介绍"><a href="#25-1-介绍" class="headerlink" title="25.1 介绍"></a>25.1 介绍</h2><p>责任链模式（Chain of Responsibility Pattern）属于行为型模式，为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p>主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p>何时使用：在处理消息的时候以过滤很多道。</p>
<p>如何解决：拦截的类都实现统一接口。</p>
<p>关键代码：Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p>应用实例： </p>
<ul>
<li>红楼梦中的”击鼓传花”。 </li>
<li>JS 中的事件冒泡。 </li>
<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</li>
</ul>
<p>优点： </p>
<ul>
<li>降低耦合度。它将请求的发送者和接收者解耦。 </li>
<li>简化了对象。使得对象不需要知道链的结构。 </li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </li>
<li>增加新的请求处理类很方便。</li>
</ul>
<p>缺点： </p>
<ul>
<li>不能保证请求一定被接收。 </li>
<li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </li>
<li>可能不容易观察运行时的特征，有碍于除错。</li>
</ul>
<p>使用场景： </p>
<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 </li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 </li>
<li>可动态指定一组对象处理请求。</li>
</ul>
<p>注意事项：在 JAVA WEB 中遇到很多应用。</p>
<h2 id="25-2-实现"><a href="#25-2-实现" class="headerlink" title="25.2 实现"></a>25.2 实现</h2><p>我们创建抽象类 AbstractLogger，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 AbstractLogger。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。</p>
<p>创建抽象的记录器类：</p>
<pre><code class="java">public abstract class AbstractLogger &#123;
   public static int INFO = 1;
   public static int DEBUG = 2;
   public static int ERROR = 3;

   protected int level;

   //责任链中的下一个元素
   protected AbstractLogger nextLogger;

   public void setNextLogger(AbstractLogger nextLogger)&#123;
      this.nextLogger = nextLogger;
   &#125;

   public void logMessage(int level, String message)&#123;
      if(this.level &lt;= level)&#123;
         write(message);
      &#125;
      if(nextLogger !=null)&#123;
         nextLogger.logMessage(level, message);
      &#125;
   &#125;

   abstract protected void write(String message);

&#125;</code></pre>
<p>创建扩展了该记录器类的实体类：</p>
<pre><code class="java">public class ConsoleLogger extends AbstractLogger &#123;

   public ConsoleLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;    
      System.out.println(&quot;Standard Console::Logger: &quot; + message);
   &#125;
&#125;

public class ErrorLogger extends AbstractLogger &#123;

   public ErrorLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;    
      System.out.println(&quot;Error Console::Logger: &quot; + message);
   &#125;
&#125;

public class FileLogger extends AbstractLogger &#123;

   public FileLogger(int level)&#123;
      this.level = level;
   &#125;

   @Override
   protected void write(String message) &#123;    
      System.out.println(&quot;File::Logger: &quot; + message);
   &#125;
&#125;</code></pre>
<p>测试：</p>
<pre><code class="java">public class ChainPatternDemo &#123;

   private static AbstractLogger getChainOfLoggers()&#123;

      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);
      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);
      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);

      errorLogger.setNextLogger(fileLogger);
      fileLogger.setNextLogger(consoleLogger);

      return errorLogger;  
   &#125;

   public static void main(String[] args) &#123;
      AbstractLogger loggerChain = getChainOfLoggers();

      loggerChain.logMessage(AbstractLogger.INFO, &quot;This is an information.&quot;);

      loggerChain.logMessage(AbstractLogger.DEBUG, 
         &quot;This is a debug level information.&quot;);

      loggerChain.logMessage(AbstractLogger.ERROR, 
         &quot;This is an error information.&quot;);
   &#125;
&#125;</code></pre>
<hr>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1G4411c7N4/">尚硅谷Java设计模式（图解+框架源码剖析）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式｜菜鸟教程</a></p>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2022年10月28日 23:59</p>
        <p>原始链接： <a class="post-url" href="/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="设计模式">http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></p>
        <footer>
            <a href="http://muquanrui.com">
                <img src="/images/logo.png" alt="MU Quanrui">
                MU Quanrui
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/&title=《设计模式》 — Quanrui's Blog&pic=cover.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/&title=《设计模式》 — Quanrui's Blog&source=Carpe diem." data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《设计模式》 — Quanrui's Blog&url=http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/&via=http://muquanrui.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://muquanrui.com/2022/10/15/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Java/" class="color5">Java</a>
      
    <a href="/tags/设计模式/" class="color5">设计模式</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
        <div class= "post-toc-name">Table of Contents</div>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="post-toc-text">1 概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-%E7%AE%80%E4%BB%8B"><span class="post-toc-text">1.1 简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-%E5%8E%9F%E5%88%99%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">1.2 原则和类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8E%9F%E5%88%99"><span class="post-toc-text">原则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">创建型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">结构型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">行为型模式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-UML%E7%B1%BB%E5%9B%BE"><span class="post-toc-text">2 UML类图</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-%E8%A1%A8%E7%A4%BA%E5%85%B7%E4%BD%93%E7%B1%BB"><span class="post-toc-text">2.1 表示具体类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-%E8%A1%A8%E7%A4%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="post-toc-text">2.2 表示抽象类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-%E8%A1%A8%E7%A4%BA%E6%8E%A5%E5%8F%A3"><span class="post-toc-text">2.3 表示接口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-%E8%A1%A8%E7%A4%BA%E5%8C%85"><span class="post-toc-text">2.4 表示包</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-5-%E8%A1%A8%E7%A4%BA%E5%85%B3%E7%B3%BB"><span class="post-toc-text">2.5 表示关系</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB"><span class="post-toc-text">泛化关系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="post-toc-text">实现关系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="post-toc-text">关联关系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="post-toc-text">依赖关系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB"><span class="post-toc-text">聚合关系</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="post-toc-text">组合关系</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="post-toc-text">3 设计模式七大原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="post-toc-text">3.1 单一职责原则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="post-toc-text">3.2 接口隔离原则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="post-toc-text">3.3 依赖倒转原则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-4-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="post-toc-text">3.4 里氏替换原则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-5-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="post-toc-text">3.5 开闭原则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-6-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="post-toc-text">3.6 迪米特法则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-7-%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="post-toc-text">3.7 合成复用原则</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">4 单例模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">4.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="post-toc-text">4.2 实现：不推荐使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="post-toc-text">饿汉式（静态常量）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="post-toc-text">饿汉式（静态代码块）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89"><span class="post-toc-text">懒汉式（线程不安全）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%EF%BC%89"><span class="post-toc-text">懒汉式（线程安全，同步方法）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="post-toc-text">懒汉式（线程安全，同步代码块）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-3-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="post-toc-text">4.3 实现：推荐使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="post-toc-text">双重检查（线程安全，推荐使用）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="post-toc-text">静态内部类（线程安全，推荐使用）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%9A%E4%B8%BE%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="post-toc-text">枚举（线程安全，推荐使用）</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">5 工厂模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">5.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">5.2 实现：简单工厂模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-3-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">5.3 实现：工厂方法模式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-4-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">5.4 实现：抽象工厂模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">6 原型模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">6.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">6.2 实现：浅拷贝</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">6.3 实现：深拷贝</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">7 建造者模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">7.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">7.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">8 适配器模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">8.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#8-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">8.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#9-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">9 桥接模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">9.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#9-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">9.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#10-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">10 装饰器模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">10.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#10-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">10.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#11-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">11 组合模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">11.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#11-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">11.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#12-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">12 外观模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">12.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#12-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">12.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#13-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">13 享元模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">13.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#13-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">13.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#14-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">14 代理模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">14.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-2-%E5%AE%9E%E7%8E%B0%EF%BC%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">14.2 实现：静态代理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-3-%E5%AE%9E%E7%8E%B0%EF%BC%9AJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">14.3 实现：JDK动态代理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#14-4-%E5%AE%9E%E7%8E%B0%EF%BC%9ACGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">14.4 实现：CGLIB动态代理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#15-%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">15 模版方法模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">15.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#15-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">15.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#16-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">16 命令模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">16.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#16-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">16.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#17-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">17 访问者模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">17.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#17-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">17.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#18-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">18 迭代器模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">18.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#18-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">18.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#19-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">19 观察者模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">19.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#19-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">19.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">20 中介者模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">20.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#20-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">20.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#21-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">21 备忘录模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#21-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">21.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">22.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#22-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">22 解释器模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">22.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#22-2-%E5%AE%9E%E7%8E%B0-1"><span class="post-toc-text">22.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#23-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">23 状态模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#23-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">23.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#23-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">23.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#24-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">24 策略模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#24-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">24.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#24-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">24.2 实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#25-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">25 责任链模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#25-1-%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">25.1 介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#25-2-%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">25.2 实现</span></a></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2022/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%BE%E8%A7%A3%E7%B3%BB%E7%BB%9F/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          图解系统
        
      </span>
    </a>
  
  
    <a href="/2022/10/14/Java/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">八大排序算法Java实现</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="Java/设计模式" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyvaQ34l4';
        var conf = 'dfbc2f31fdc91ffc75e2035195b4426d';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    |
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
    <div class="theme-info">
</p>


      <span class="post-count">本站博文总字数：639.9k</span>
      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2018~2022 MU Quanrui<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!--加载prettify代码高亮js-->
  <script type="text/javascript" src="/google-code-prettify/prettify.js"></script>
  <script type="text/javascript">
    $(document).ready(function(){
      $('pre').addClass('prettyprint linenums');
      $('code').addClass('prettyprint');
      prettyPrint();
    })
  </script>

<script>
  var mihoConfig = {
      root: "http://muquanrui.com",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Big-Data/">Big Data</a><a class="category-link" href="/categories/Blog/">Blog</a><a class="category-link" href="/categories/Essay/">Essay</a><a class="category-link" href="/categories/IDEA/">IDEA</a><a class="category-link" href="/categories/IDE%E5%92%8C%E7%BC%96%E8%BE%91%E5%99%A8/">IDE和编辑器</a><a class="category-link" href="/categories/Java/">Java</a><a class="category-link" href="/categories/Lifelong-Learning/">Lifelong Learning</a><a class="category-link" href="/categories/MySQL/">MySQL</a><a class="category-link" href="/categories/Programming/">Programming</a><a class="category-link" href="/categories/Project/">Project</a><a class="category-link" href="/categories/Redis/">Redis</a><a class="category-link" href="/categories/Spring/">Spring</a><a class="category-link" href="/categories/UML/">UML</a><a class="category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><a class="category-link" href="/categories/%E5%9B%BE%E8%AE%BA/">图论</a><a class="category-link" href="/categories/%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80/">奇淫巧技</a><a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="category-link" href="/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/">方法论</a><a class="category-link" href="/categories/%E6%97%A0%E5%90%8D%E5%90%88%E9%9B%86/">无名合集</a><a class="category-link" href="/categories/%E6%B3%95%E8%AF%AD/">法语</a><a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3/">计算机接口</a><a class="category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Big-Data/" style="font-size: 10.83px;">Big Data</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/B%E7%AB%99%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 13.33px;">B站尚硅谷</a> <a href="/tags/B%E7%AB%99%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/" style="font-size: 14.17px;">B站王道考研</a> <a href="/tags/CSS/" style="font-size: 11.67px;">CSS</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/ENSEEIHT/" style="font-size: 15px;">ENSEEIHT</a> <a href="/tags/Essay/" style="font-size: 10.83px;">Essay</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/IDEA/" style="font-size: 10.83px;">IDEA</a> <a href="/tags/IDE%E5%92%8C%E7%BC%96%E8%BE%91%E5%99%A8/" style="font-size: 10px;">IDE和编辑器</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/JavaWeb/" style="font-size: 10.83px;">JavaWeb</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 16.67px;">Java核心技术卷I</a> <a href="/tags/Java%E7%AC%94%E8%AE%B0/" style="font-size: 17.5px;">Java笔记</a> <a href="/tags/Java%E9%AB%98%E7%BA%A7/" style="font-size: 15.83px;">Java高级</a> <a href="/tags/Lifelong-Learning/" style="font-size: 10px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/OneNote/" style="font-size: 10px;">OneNote</a> <a href="/tags/Project/" style="font-size: 10px;">Project</a> <a href="/tags/QoS/" style="font-size: 11.67px;">QoS</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10.83px;">SSM</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Spark/" style="font-size: 10.83px;">Spark</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/UML/" style="font-size: 12.5px;">UML</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/YAML/" style="font-size: 10px;">YAML</a> <a href="/tags/macOS/" style="font-size: 12.5px;">macOS</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 12.5px;">八股文</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.83px;">前端</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">图解网络</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10.83px;">图论</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" style="font-size: 19.17px;">大学课程</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">学习笔记</a> <a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 10px;">摄影</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13.33px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%B3%95%E8%AF%AD/" style="font-size: 16.67px;">法语</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%8F%A3%E8%AF%AD/" style="font-size: 10px;">法语口语</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">法语语法</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E8%AF%AD%E9%9F%B3/" style="font-size: 10px;">法语语音</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10.83px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10.83px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 12.5px;">计算机接口与通信</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 18.33px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">软件工程</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/categories">
                    <i class="fa fa-book"></i><span>Categories</span>
                </a>
            </li>
            
            <li>
                <a  href="/tags">
                    <i class="fa fa-tags"></i><span>Tags</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Big-Data/" style="font-size: 10.83px;">Big Data</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/B%E7%AB%99%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 13.33px;">B站尚硅谷</a> <a href="/tags/B%E7%AB%99%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/" style="font-size: 14.17px;">B站王道考研</a> <a href="/tags/CSS/" style="font-size: 11.67px;">CSS</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">C语言</a> <a href="/tags/ENSEEIHT/" style="font-size: 15px;">ENSEEIHT</a> <a href="/tags/Essay/" style="font-size: 10.83px;">Essay</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/IDEA/" style="font-size: 10.83px;">IDEA</a> <a href="/tags/IDE%E5%92%8C%E7%BC%96%E8%BE%91%E5%99%A8/" style="font-size: 10px;">IDE和编辑器</a> <a href="/tags/JUC/" style="font-size: 10px;">JUC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/JavaWeb/" style="font-size: 10.83px;">JavaWeb</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 16.67px;">Java核心技术卷I</a> <a href="/tags/Java%E7%AC%94%E8%AE%B0/" style="font-size: 17.5px;">Java笔记</a> <a href="/tags/Java%E9%AB%98%E7%BA%A7/" style="font-size: 15.83px;">Java高级</a> <a href="/tags/Lifelong-Learning/" style="font-size: 10px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 11.67px;">MySQL</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/OneNote/" style="font-size: 10px;">OneNote</a> <a href="/tags/Project/" style="font-size: 10px;">Project</a> <a href="/tags/QoS/" style="font-size: 11.67px;">QoS</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/SSM/" style="font-size: 10.83px;">SSM</a> <a href="/tags/SVN/" style="font-size: 10px;">SVN</a> <a href="/tags/Spark/" style="font-size: 10.83px;">Spark</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/SpringMVC/" style="font-size: 10px;">SpringMVC</a> <a href="/tags/Typora/" style="font-size: 10px;">Typora</a> <a href="/tags/UML/" style="font-size: 12.5px;">UML</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/YAML/" style="font-size: 10px;">YAML</a> <a href="/tags/macOS/" style="font-size: 12.5px;">macOS</a> <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 12.5px;">八股文</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10.83px;">前端</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">图解网络</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10.83px;">图论</a> <a href="/tags/%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B/" style="font-size: 19.17px;">大学课程</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">学习笔记</a> <a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 10px;">摄影</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 16.67px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13.33px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%B3%95%E8%AF%AD/" style="font-size: 16.67px;">法语</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%8F%A3%E8%AF%AD/" style="font-size: 10px;">法语口语</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E8%AF%AD%E6%B3%95/" style="font-size: 15px;">法语语法</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E8%AF%AD%E9%9F%B3/" style="font-size: 10px;">法语语音</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" style="font-size: 10.83px;">离散数学</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10.83px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 12.5px;">计算机接口与通信</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 18.33px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">软件工程</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>









  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400,"vOffset":-30},"mobile":{"show":false},"react":{"opacity":0.8},"log":false});</script></body>
</html>



