<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Netty学习笔记 | Quanrui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Quanrui's Blog" />
  
  <meta name="description" content="1 NIO 基础1.1 三大组件non-blocking io 即「非阻塞IO」。 Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，即单工通道，channel 比 stream 更为底层。">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty学习笔记">
<meta property="og:url" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Quanrui&#39;s Blog">
<meta property="og:description" content="1 NIO 基础1.1 三大组件non-blocking io 即「非阻塞IO」。 Channel &amp; Bufferchannel 有一点类似于 stream，它就是读写数据的双向通道，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，即单工通道，channel 比 stream 更为底层。">
<meta property="og:locale">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0021-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0018-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0019-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0020-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0021-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0022-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0023-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0033-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0039-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0035-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0038-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0037-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0034-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0036-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0024-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0025-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0026-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0027-8285561.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0005.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0006.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0007.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0040.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0042.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0041.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0044.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0048.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0047.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0008.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0009.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0010.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0011.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0012.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0049.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0051.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0031.jpg">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0013.png">
<meta property="og:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0032.png">
<meta property="article:published_time" content="2022-07-17T02:26:11.000Z">
<meta property="article:modified_time" content="2023-01-01T12:05:21.558Z">
<meta property="article:author" content="MU Quanrui">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Framework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/0021-8285561.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  
<link rel="stylesheet" href="/css/style.css">


 <!--加载prettify代码高亮样式-->
<link href="/google-code-prettify/tranquil-heart.css" type="text/css" rel="stylesheet" />

  
<script src="/js/pace.min.js"></script>

  

  
  


  <!--加载条样式-->
  <style>
    .pace .pace-progress {
    	background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);
    	height: 3px;
    }
    .pace .pace-progress-inner {
     	box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
    	border-top-color: #1E92FB;	/*上边框颜色*/
    	border-left-color: #1E92FB;	/*左边框颜色*/
    }
  </style>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div id="background"></div><!--背景颜色/图片-->
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">

        <div id="header-menu" class="header-menu-pos animated">


<a target="_blank" rel="noopener" href="https://github.com/muquanrui" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FFA500; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Quanrui&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/categories">
                        <i class="fa fa-book"></i>
                        <span>Categories</span>
                    </a>
                    
                    <a  href="/tags">
                        <i class="fa fa-tags"></i>
                        <span>Tags</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Quanrui&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        Carpe diem.
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//muquanrui.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/muquanrui">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Google" target="_blank" href="//google.com">
                            <i class="fa fa-google fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Programming/Framework/Netty学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Netty学习笔记
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Framework/">Framework</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-07-17
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>          
        </li>
      </ul>
       <span class="post-count">文章字数:38.7k字 &nbsp &nbsp  
         阅读时长:191分钟</span>
    </div>
  
        
          
      </header>
    

    <div class="article-entry post-content" itemprop="articleBody">

    
    



      
            
            <h1 id="1-NIO-基础"><a href="#1-NIO-基础" class="headerlink" title="1 NIO 基础"></a>1 NIO 基础</h1><h2 id="1-1-三大组件"><a href="#1-1-三大组件" class="headerlink" title="1.1 三大组件"></a>1.1 三大组件</h2><p>non-blocking io 即「非阻塞IO」。</p>
<h3 id="Channel-amp-Buffer"><a href="#Channel-amp-Buffer" class="headerlink" title="Channel &amp; Buffer"></a>Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，即单工通道，channel 比 stream 更为底层。</p>
<pre><code class="mermaid">graph LR
channel --&gt; buffer
buffer --&gt; channel</code></pre>
<p>常见的 Channel 有</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>
<h4 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h4><ul>
<li>每来一个客户端，就新建一个socket负责客户端和服务器之间的连接，并启动一个新的线程为socket服务</li>
</ul>
<pre><code class="mermaid">graph TD
subgraph 多线程版
t1(thread) --&gt; s1(socket1)
t2(thread) --&gt; s2(socket2)
t3(thread) --&gt; s3(socket3)
end</code></pre>
<p>⚠️ 多线程版缺点</p>
<ul>
<li>内存占用高</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的场景</li>
</ul>
<h4 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h4><ul>
<li>线程池可以设置最大线程数，避免出现特多的线程</li>
<li>一个线程需要负责多个socket，但此时socket工作在阻塞模式下，一个线程在一个时间段内还是只能负责一个socket</li>
</ul>
<pre><code class="mermaid">graph TD
subgraph 线程池版
t4(thread) --&gt; s4(socket1)
t5(thread) --&gt; s5(socket2)
t4(thread) -.-&gt; s6(socket3)
t5(thread) -.-&gt; s7(socket4)
end</code></pre>
<p>⚠️ 线程池版缺点</p>
<ul>
<li>阻塞模式下，线程仅能处理一个 socket 连接</li>
<li>仅适合短连接场景</li>
</ul>
<h4 id="selector-版设计"><a href="#selector-版设计" class="headerlink" title="selector 版设计"></a>selector 版设计</h4><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）。</p>
<pre><code class="mermaid">graph TD
subgraph selector 版
thread --&gt; selector
selector --&gt; c1(channel)
selector --&gt; c2(channel)
selector --&gt; c3(channel)
end</code></pre>
<p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理。</p>
<h2 id="1-2-ByteBuffer"><a href="#1-2-ByteBuffer" class="headerlink" title="1.2 ByteBuffer"></a>1.2 ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p>
<pre><code>1234567890abcd</code></pre>
<p>使用 FileChannel 来读取文件内容</p>
<pre><code class="java">@Slf4j
public class ChannelDemo1 &#123;
    public static void main(String[] args) &#123;
        try (RandomAccessFile file = new RandomAccessFile(&quot;helloword/data.txt&quot;, &quot;rw&quot;)) &#123;
            FileChannel channel = file.getChannel();
            ByteBuffer buffer = ByteBuffer.allocate(10);
            do &#123;
                // 向 buffer 写入
                int len = channel.read(buffer);
                log.debug(&quot;读到字节数：&#123;&#125;&quot;, len);
                if (len == -1) &#123;
                    break;
                &#125;
                // 切换 buffer 读模式
                buffer.flip();
                while(buffer.hasRemaining()) &#123;
                    log.debug(&quot;&#123;&#125;&quot;, (char)buffer.get());
                &#125;
                // 切换 buffer 写模式
                buffer.clear();
            &#125; while (true);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>输出</p>
<pre><code>10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d
10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</code></pre>
<h3 id="ByteBuffer-正确使用姿势"><a href="#ByteBuffer-正确使用姿势" class="headerlink" title="ByteBuffer 正确使用姿势"></a>ByteBuffer 正确使用姿势</h3><ol>
<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>
<li>调用 flip() 切换至<strong>读模式</strong></li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<h3 id="ByteBuffer-结构"><a href="#ByteBuffer-结构" class="headerlink" title="ByteBuffer 结构"></a>ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>一开始</p>
<p><img src="images/0021-8285561.png"></p>
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<p><img src="images/0018-8285561.png"></p>
<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>
<p><img src="images/0019-8285561.png"></p>
<p>读取 4 个字节后，状态</p>
<p><img src="images/0020-8285561.png"></p>
<p>clear 动作发生后，状态</p>
<p><img src="images/0021-8285561.png"></p>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src="images/0022-8285561.png"></p>
<h3 id="ByteBuffer-常见方法"><a href="#ByteBuffer-常见方法" class="headerlink" title="ByteBuffer 常见方法"></a>ByteBuffer 常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>
<pre><code class="java">Bytebuffer buf = ByteBuffer.allocate(16);</code></pre>
<h4 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h4><p>有两种办法</p>
<ul>
<li>调用 channel 的 read 方法</li>
<li>调用 buffer 自己的 put 方法</li>
</ul>
<pre><code class="java">int readBytes = channel.read(buf);</code></pre>
<p>和</p>
<pre><code class="java">buf.put((byte)127);</code></pre>
<h4 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h4><p>同样有两种办法</p>
<ul>
<li>调用 channel 的 write 方法</li>
<li>调用 buffer 自己的 get 方法</li>
</ul>
<pre><code class="java">int writeBytes = channel.write(buf);</code></pre>
<p>和</p>
<pre><code class="java">byte b = buf.get();</code></pre>
<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>
<ul>
<li>可以调用 rewind 方法将 position 重新置为 0</li>
<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>
</ul>
<h4 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>
<blockquote>
<p><strong>注意</strong></p>
<p>rewind 和 flip 都会清除 mark 位置</p>
</blockquote>
<h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><pre><code class="java">ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(&quot;你好&quot;);
ByteBuffer buffer2 = Charset.forName(&quot;utf-8&quot;).encode(&quot;你好&quot;);

debug(buffer1);
debug(buffer2);

CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);
System.out.println(buffer3.getClass());
System.out.println(buffer3.toString());</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| e4 bd a0 e5 a5 bd                               |......          |
+--------+-------------------------------------------------+----------------+
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| e4 bd a0 e5 a5 bd                               |......          |
+--------+-------------------------------------------------+----------------+
class java.nio.HeapCharBuffer
你好</code></pre>
<h4 id="⚠️-Buffer-的线程安全"><a href="#⚠️-Buffer-的线程安全" class="headerlink" title="⚠️ Buffer 的线程安全"></a>⚠️ Buffer 的线程安全</h4><blockquote>
<p>Buffer 是<strong>非线程安全的</strong></p>
</blockquote>
<h3 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p>
<pre><code>onetwothree</code></pre>
<p>使用如下方式读取，可以将数据填充至多个 buffer</p>
<pre><code class="java">try (RandomAccessFile file = new RandomAccessFile(&quot;helloword/3parts.txt&quot;, &quot;rw&quot;)) &#123;
    FileChannel channel = file.getChannel();
    ByteBuffer a = ByteBuffer.allocate(3);
    ByteBuffer b = ByteBuffer.allocate(3);
    ByteBuffer c = ByteBuffer.allocate(5);
    channel.read(new ByteBuffer[]&#123;a, b, c&#125;);
    a.flip();
    b.flip();
    c.flip();
    debug(a);
    debug(b);
    debug(c);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre>
<p>结果</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 6f 6e 65                                        |one             |
+--------+-------------------------------------------------+----------------+
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 74 77 6f                                        |two             |
+--------+-------------------------------------------------+----------------+
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 74 68 72 65 65                                  |three           |
+--------+-------------------------------------------------+----------------+</code></pre>
<h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>
<pre><code class="java">try (RandomAccessFile file = new RandomAccessFile(&quot;helloword/3parts.txt&quot;, &quot;rw&quot;)) &#123;
    FileChannel channel = file.getChannel();
    ByteBuffer d = ByteBuffer.allocate(4);
    ByteBuffer e = ByteBuffer.allocate(4);
    channel.position(11);

    d.put(new byte[]&#123;&#39;f&#39;, &#39;o&#39;, &#39;u&#39;, &#39;r&#39;&#125;);
    e.put(new byte[]&#123;&#39;f&#39;, &#39;i&#39;, &#39;v&#39;, &#39;e&#39;&#125;);
    d.flip();
    e.flip();
    debug(d);
    debug(e);
    channel.write(new ByteBuffer[]&#123;d, e&#125;);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 66 6f 75 72                                     |four            |
+--------+-------------------------------------------------+----------------+
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 66 69 76 65                                     |five            |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>文件内容</p>
<pre><code>onetwothreefourfive</code></pre>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
<ul>
<li>Hello,world\n</li>
<li>I’m zhangsan\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer (黏包，半包)</p>
<ul>
<li>Hello,world\nI’m zhangsan\nHo</li>
<li>w are you?\n</li>
</ul>
<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</p>
<pre><code class="java">public static void main(String[] args) &#123;
    ByteBuffer source = ByteBuffer.allocate(32);
    //                     11            24
    source.put(&quot;Hello,world\nI&#39;m zhangsan\nHo&quot;.getBytes());
    split(source);

    source.put(&quot;w are you?\nhaha!\n&quot;.getBytes());
    split(source);
&#125;

private static void split(ByteBuffer source) &#123;
    source.flip();
    int oldLimit = source.limit();
    for (int i = 0; i &lt; oldLimit; i++) &#123;
        if (source.get(i) == &#39;\n&#39;) &#123;
            System.out.println(i);
            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());
            // 0 ~ limit
            source.limit(i + 1);
            target.put(source); // 从source 读，向 target 写
            debugAll(target);
            source.limit(oldLimit);
        &#125;
    &#125;
    source.compact();
&#125;</code></pre>
<h2 id="1-3-文件编程"><a href="#1-3-文件编程" class="headerlink" title="1.3 文件编程"></a>1.3 文件编程</h2><h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><h4 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h4><blockquote>
<p>FileChannel 只能工作在阻塞模式下</p>
</blockquote>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>
<ul>
<li>通过 FileInputStream 获取的 channel 只能读</li>
<li>通过 FileOutputStream 获取的 channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>
<pre><code class="java">int readBytes = channel.read(buffer);</code></pre>
<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>
<pre><code class="java">ByteBuffer buffer = ...;
buffer.put(...); // 存入数据
buffer.flip();   // 切换读模式

while(buffer.hasRemaining()) &#123;
    channel.write(buffer);
&#125;</code></pre>
<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取当前位置</p>
<pre><code class="java">long pos = channel.position();</code></pre>
<p>设置当前位置</p>
<pre><code class="java">long newPos = ...;
channel.position(newPos);</code></pre>
<p>设置当前位置时，如果设置为文件的末尾</p>
<ul>
<li>这时读取会返回 -1 </li>
<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>
</ul>
<h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>使用 size 方法获取文件的大小</p>
<h4 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>
<h3 id="两个-Channel-传输数据"><a href="#两个-Channel-传输数据" class="headerlink" title="两个 Channel 传输数据"></a>两个 Channel 传输数据</h3><pre><code class="java">String FROM = &quot;helloword/data.txt&quot;;
String TO = &quot;helloword/to.txt&quot;;
long start = System.nanoTime();
try (FileChannel from = new FileInputStream(FROM).getChannel();
     FileChannel to = new FileOutputStream(TO).getChannel();
    ) &#123;
    from.transferTo(0, from.size(), to);
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;
long end = System.nanoTime();
System.out.println(&quot;transferTo 用时：&quot; + (end - start) / 1000_000.0);</code></pre>
<p>输出</p>
<pre><code>transferTo 用时：8.2011</code></pre>
<p>超过 2g 大小的文件传输</p>
<pre><code class="java">public class TestFileChannelTransferTo &#123;
    public static void main(String[] args) &#123;
        try (
                FileChannel from = new FileInputStream(&quot;data.txt&quot;).getChannel();
                FileChannel to = new FileOutputStream(&quot;to.txt&quot;).getChannel();
        ) &#123;
            // 效率高，底层会利用操作系统的零拷贝进行优化
            long size = from.size();
            // left 变量代表还剩余多少字节
            for (long left = size; left &gt; 0; ) &#123;
                System.out.println(&quot;position:&quot; + (size - left) + &quot; left:&quot; + left);
                left -= from.transferTo((size - left), left, to);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>实际传输一个超大文件</p>
<pre><code>position:0 left:7769948160
position:2147483647 left:5622464513
position:4294967294 left:3474980866
position:6442450941 left:1327497219</code></pre>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>jdk7 引入了 Path 和 Paths 类</p>
<ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
</ul>
<pre><code class="java">Path source = Paths.get(&quot;1.txt&quot;); // 相对路径 使用 user.dir 环境变量来定位 1.txt

Path source = Paths.get(&quot;d:\\1.txt&quot;); // 绝对路径 代表了  d:\1.txt

Path source = Paths.get(&quot;d:/1.txt&quot;); // 绝对路径 同样代表了  d:\1.txt

Path projects = Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;); // 代表了  d:\data\projects</code></pre>
<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<p>例如目录结构如下</p>
<pre><code>d:
    |- data
        |- projects
            |- a
            |- b</code></pre>
<p>代码</p>
<pre><code class="java">Path path = Paths.get(&quot;d:\\data\\projects\\a\\..\\b&quot;);
System.out.println(path);
System.out.println(path.normalize()); // 正常化路径</code></pre>
<p>会输出</p>
<pre><code>d:\data\projects\a\..\b
d:\data\projects\b</code></pre>
<h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p>检查文件是否存在</p>
<pre><code class="java">Path path = Paths.get(&quot;helloword/data.txt&quot;);
System.out.println(Files.exists(path));</code></pre>
<p>创建一级目录</p>
<pre><code class="java">Path path = Paths.get(&quot;helloword/d1&quot;);
Files.createDirectory(path);</code></pre>
<ul>
<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<p>创建多级目录用</p>
<pre><code class="java">Path path = Paths.get(&quot;helloword/d1/d2&quot;);
Files.createDirectories(path);</code></pre>
<p>拷贝文件</p>
<pre><code class="java">Path source = Paths.get(&quot;helloword/data.txt&quot;);
Path target = Paths.get(&quot;helloword/target.txt&quot;);

Files.copy(source, target);</code></pre>
<ul>
<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>
</ul>
<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>
<pre><code class="java">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre>
<p>移动文件</p>
<pre><code class="java">Path source = Paths.get(&quot;helloword/data.txt&quot;);
Path target = Paths.get(&quot;helloword/data.txt&quot;);

Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</code></pre>
<ul>
<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>
</ul>
<p>删除文件</p>
<pre><code class="java">Path target = Paths.get(&quot;helloword/target.txt&quot;);

Files.delete(target);</code></pre>
<ul>
<li>如果文件不存在，会抛异常 NoSuchFileException</li>
</ul>
<p>删除目录</p>
<pre><code class="java">Path target = Paths.get(&quot;helloword/d1&quot;);

Files.delete(target);</code></pre>
<ul>
<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>
</ul>
<p>遍历目录文件</p>
<pre><code class="java">public static void main(String[] args) throws IOException &#123;
    Path path = Paths.get(&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;);
    AtomicInteger dirCount = new AtomicInteger();
    AtomicInteger fileCount = new AtomicInteger();
    Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;
        @Override
        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) 
            throws IOException &#123;
            System.out.println(dir);
            dirCount.incrementAndGet();
            return super.preVisitDirectory(dir, attrs);
        &#125;

        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
            throws IOException &#123;
            System.out.println(file);
            fileCount.incrementAndGet();
            return super.visitFile(file, attrs);
        &#125;
    &#125;);
    System.out.println(dirCount); // 133
    System.out.println(fileCount); // 1479
&#125;</code></pre>
<p>统计 jar 的数目</p>
<pre><code class="java">Path path = Paths.get(&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;);
AtomicInteger fileCount = new AtomicInteger();
Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
        throws IOException &#123;
        if (file.toFile().getName().endsWith(&quot;.jar&quot;)) &#123;
            fileCount.incrementAndGet();
        &#125;
        return super.visitFile(file, attrs);
    &#125;
&#125;);
System.out.println(fileCount); // 724</code></pre>
<p>删除多级目录</p>
<pre><code class="java">Path path = Paths.get(&quot;d:\\a&quot;);
Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
        throws IOException &#123;
        Files.delete(file);
        return super.visitFile(file, attrs);
    &#125;

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) 
        throws IOException &#123;
        Files.delete(dir);
        return super.postVisitDirectory(dir, exc);
    &#125;
&#125;);</code></pre>
<p>⚠️ 删除很危险</p>
<blockquote>
<p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p>
</blockquote>
<p>拷贝多级目录</p>
<pre><code class="java">long start = System.currentTimeMillis();
String source = &quot;D:\\Snipaste-1.16.2-x64&quot;;
String target = &quot;D:\\Snipaste-1.16.2-x64aaa&quot;;

Files.walk(Paths.get(source)).forEach(path -&gt; &#123;
    try &#123;
        String targetName = path.toString().replace(source, target);
        // 是目录
        if (Files.isDirectory(path)) &#123;
            Files.createDirectory(Paths.get(targetName));
        &#125;
        // 是普通文件
        else if (Files.isRegularFile(path)) &#123;
            Files.copy(path, Paths.get(targetName));
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;);
long end = System.currentTimeMillis();
System.out.println(end - start);</code></pre>
<h2 id="1-4-网络编程"><a href="#1-4-网络编程" class="headerlink" title="1.4 网络编程"></a>1.4 网络编程</h2><h3 id="非阻塞-vs-阻塞"><a href="#非阻塞-vs-阻塞" class="headerlink" title="非阻塞 vs 阻塞"></a>非阻塞 vs 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p>服务器端</p>
<pre><code class="java">// 使用 nio 来理解阻塞模式, 单线程
// 0. ByteBuffer
ByteBuffer buffer = ByteBuffer.allocate(16);
// 1. 创建了服务器
ServerSocketChannel ssc = ServerSocketChannel.open();

// 2. 绑定监听端口
ssc.bind(new InetSocketAddress(8080));

// 3. 连接集合
List&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();
while (true) &#123;
    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信
    log.debug(&quot;connecting...&quot;);
    SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行
    log.debug(&quot;connected... &#123;&#125;&quot;, sc);
    channels.add(sc);
    for (SocketChannel channel : channels) &#123;
        // 5. 接收客户端发送的数据
        log.debug(&quot;before read... &#123;&#125;&quot;, channel);
        channel.read(buffer); // 阻塞方法，线程停止运行
        buffer.flip();
        debugRead(buffer);
        buffer.clear();
        log.debug(&quot;after read...&#123;&#125;&quot;, channel);
    &#125;
&#125;</code></pre>
<p>客户端</p>
<pre><code class="java">SocketChannel sc = SocketChannel.open();
sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
System.out.println(&quot;waiting...&quot;);</code></pre>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>
<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>
<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li>
<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
<p>服务器端，客户端代码不变</p>
<pre><code class="java">// 使用 nio 来理解非阻塞模式, 单线程
// 0. ByteBuffer
ByteBuffer buffer = ByteBuffer.allocate(16);
// 1. 创建了服务器
ServerSocketChannel ssc = ServerSocketChannel.open();
ssc.configureBlocking(false); // 非阻塞模式
// 2. 绑定监听端口
ssc.bind(new InetSocketAddress(8080));
// 3. 连接集合
List&lt;SocketChannel&gt; channels = new ArrayList&lt;&gt;();
while (true) &#123;
    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信
    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null
    if (sc != null) &#123;
        log.debug(&quot;connected... &#123;&#125;&quot;, sc);
        sc.configureBlocking(false); // 非阻塞模式
        channels.add(sc);
    &#125;
    for (SocketChannel channel : channels) &#123;
        // 5. 接收客户端发送的数据
        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0
        if (read &gt; 0) &#123;
            buffer.flip();
            debugRead(buffer);
            buffer.clear();
            log.debug(&quot;after read...&#123;&#125;&quot;, channel);
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><pre><code class="mermaid">graph TD
subgraph selector 版
thread --&gt; selector
selector --&gt; c1(channel)
selector --&gt; c2(channel)
selector --&gt; c3(channel)
end</code></pre>
<p>好处</p>
<ul>
<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><pre><code class="java">Selector selector = Selector.open();</code></pre>
<h4 id="绑定-Channel-事件"><a href="#绑定-Channel-事件" class="headerlink" title="绑定 Channel 事件"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>
<pre><code class="java">channel.configureBlocking(false);
SelectionKey key = channel.register(selector, 绑定事件);</code></pre>
<ul>
<li>channel 必须工作在非阻塞模式</li>
<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>
<li>绑定的事件类型可以有<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
<h4 id="监听-Channel-事件"><a href="#监听-Channel-事件" class="headerlink" title="监听 Channel 事件"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>
<p>方法1，阻塞直到绑定事件发生</p>
<pre><code class="java">int count = selector.select();</code></pre>
<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>
<pre><code class="java">int count = selector.select(long timeout);</code></pre>
<p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
<pre><code class="java">int count = selector.selectNow();</code></pre>
<h4 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h4><blockquote>
<ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发 accept 事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>
<li>channel 可写，会触发 write 事件</li>
<li>在 linux 下 nio bug 发生时</li>
</ul>
</li>
<li>调用 selector.wakeup()</li>
<li>调用 selector.close()</li>
<li>selector 所在线程 interrupt</li>
</ul>
</blockquote>
<h3 id="处理-accept-事件"><a href="#处理-accept-事件" class="headerlink" title="处理 accept 事件"></a>处理 accept 事件</h3><p>客户端代码为</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) &#123;
        try (Socket socket = new Socket(&quot;localhost&quot;, 8080)) &#123;
            System.out.println(socket);
            socket.getOutputStream().write(&quot;world&quot;.getBytes());
            System.in.read();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>服务器端代码为</p>
<pre><code class="java">@Slf4j
public class ChannelDemo6 &#123;
    public static void main(String[] args) &#123;
        try (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;
            channel.bind(new InetSocketAddress(8080));
            System.out.println(channel);
            Selector selector = Selector.open();
            channel.configureBlocking(false);
            channel.register(selector, SelectionKey.OP_ACCEPT);

            while (true) &#123;
                int count = selector.select();
//                int count = selector.selectNow();
                log.debug(&quot;select count: &#123;&#125;&quot;, count);
//                if(count &lt;= 0) &#123;
//                    continue;
//                &#125;

                // 获取所有事件
                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();

                // 遍历所有事件，逐一处理
                Iterator&lt;SelectionKey&gt; iter = keys.iterator();
                while (iter.hasNext()) &#123;
                    SelectionKey key = iter.next();
                    // 判断事件类型
                    if (key.isAcceptable()) &#123;
                        ServerSocketChannel c = (ServerSocketChannel) key.channel();
                        // 必须处理
                        SocketChannel sc = c.accept();
                        log.debug(&quot;&#123;&#125;&quot;, sc);
                    &#125;
                    // 处理完毕，必须将事件移除
                    iter.remove();
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><blockquote>
<p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>
</blockquote>
<h3 id="处理-read-事件"><a href="#处理-read-事件" class="headerlink" title="处理 read 事件"></a>处理 read 事件</h3><pre><code class="java">@Slf4j
public class ChannelDemo6 &#123;
    public static void main(String[] args) &#123;
        try (ServerSocketChannel channel = ServerSocketChannel.open()) &#123;
            channel.bind(new InetSocketAddress(8080));
            System.out.println(channel);
            Selector selector = Selector.open();
            channel.configureBlocking(false);
            channel.register(selector, SelectionKey.OP_ACCEPT);

            while (true) &#123;
                int count = selector.select();
//                int count = selector.selectNow();
                log.debug(&quot;select count: &#123;&#125;&quot;, count);
//                if(count &lt;= 0) &#123;
//                    continue;
//                &#125;

                // 获取所有事件
                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();

                // 遍历所有事件，逐一处理
                Iterator&lt;SelectionKey&gt; iter = keys.iterator();
                while (iter.hasNext()) &#123;
                    SelectionKey key = iter.next();
                    // 判断事件类型
                    if (key.isAcceptable()) &#123;
                        ServerSocketChannel c = (ServerSocketChannel) key.channel();
                        // 必须处理
                        SocketChannel sc = c.accept();
                        sc.configureBlocking(false);
                        sc.register(selector, SelectionKey.OP_READ);
                        log.debug(&quot;连接已建立: &#123;&#125;&quot;, sc);
                    &#125; else if (key.isReadable()) &#123;
                        SocketChannel sc = (SocketChannel) key.channel();
                        ByteBuffer buffer = ByteBuffer.allocate(128);
                        int read = sc.read(buffer);
                        if(read == -1) &#123;
                            key.cancel();
                            sc.close();
                        &#125; else &#123;
                            buffer.flip();
                            debug(buffer);
                        &#125;
                    &#125;
                    // 处理完毕，必须将事件移除
                    iter.remove();
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>开启两个客户端，修改一下发送文字，输出</p>
<pre><code>sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]
21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1
21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]
21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f                                  |hello           |
+--------+-------------------------------------------------+----------------+
21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1
21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]
21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 77 6f 72 6c 64                                  |world           |
+--------+-------------------------------------------------+----------------+</code></pre>
<h4 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h4><blockquote>
<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><blockquote>
<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
</blockquote>
<h4 id="⚠️-不处理边界的问题"><a href="#⚠️-不处理边界的问题" class="headerlink" title="⚠️  不处理边界的问题"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p>
<pre><code class="java">public class Server &#123;
    public static void main(String[] args) throws IOException &#123;
        ServerSocket ss=new ServerSocket(9000);
        while (true) &#123;
            Socket s = ss.accept();
            InputStream in = s.getInputStream();
            // 这里这么写，有没有问题
            byte[] arr = new byte[4];
            while(true) &#123;
                int read = in.read(arr);
                // 这里这么写，有没有问题
                if(read == -1) &#123;
                    break;
                &#125;
                System.out.println(new String(arr, 0, read));
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) throws IOException &#123;
        Socket max = new Socket(&quot;localhost&quot;, 9000);
        OutputStream out = max.getOutputStream();
        out.write(&quot;hello&quot;.getBytes());
        out.write(&quot;world&quot;.getBytes());
        out.write(&quot;你好&quot;.getBytes());
        max.close();
    &#125;
&#125;</code></pre>
<p>输出</p>
<pre><code>hell
owor
ld�
�好
</code></pre>
<p>为什么？</p>
<h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src="images/0023-8285561.png"></p>
<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>
<li>Http 1.1 是 TLV 格式</li>
<li>Http 2.0 是 LTV 格式</li>
</ul>
</li>
</ul>
<pre><code class="mermaid">sequenceDiagram 
participant c1 as 客户端1
participant s as 服务器
participant b1 as ByteBuffer1
participant b2 as ByteBuffer2
c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r
s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef
s -&gt;&gt; b2: 扩容
b1 -&gt;&gt; b2: 拷贝 01234567890abcdef
s -&gt;&gt; b2: 第二次 read 存入 3333\r
b2 -&gt;&gt; b2: 01234567890abcdef3333\r</code></pre>
<p>服务器端</p>
<pre><code class="java">private static void split(ByteBuffer source) &#123;
    source.flip();
    for (int i = 0; i &lt; source.limit(); i++) &#123;
        // 找到一条完整消息
        if (source.get(i) == &#39;\n&#39;) &#123;
            int length = i + 1 - source.position();
            // 把这条完整消息存入新的 ByteBuffer
            ByteBuffer target = ByteBuffer.allocate(length);
            // 从 source 读，向 target 写
            for (int j = 0; j &lt; length; j++) &#123;
                target.put(source.get());
            &#125;
            debugAll(target);
        &#125;
    &#125;
    source.compact(); // 0123456789abcdef  position 16 limit 16
&#125;

public static void main(String[] args) throws IOException &#123;
    // 1. 创建 selector, 管理多个 channel
    Selector selector = Selector.open();
    ServerSocketChannel ssc = ServerSocketChannel.open();
    ssc.configureBlocking(false);
    // 2. 建立 selector 和 channel 的联系（注册）
    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件
    SelectionKey sscKey = ssc.register(selector, 0, null);
    // key 只关注 accept 事件
    sscKey.interestOps(SelectionKey.OP_ACCEPT);
    log.debug(&quot;sscKey:&#123;&#125;&quot;, sscKey);
    ssc.bind(new InetSocketAddress(8080));
    while (true) &#123;
        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行
        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理
        selector.select();
        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件
        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); // accept, read
        while (iter.hasNext()) &#123;
            SelectionKey key = iter.next();
            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题
            iter.remove();
            log.debug(&quot;key: &#123;&#125;&quot;, key);
            // 5. 区分事件类型
            if (key.isAcceptable()) &#123; // 如果是 accept
                ServerSocketChannel channel = (ServerSocketChannel) key.channel();
                SocketChannel sc = channel.accept();
                sc.configureBlocking(false);
                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment
                // 将一个 byteBuffer 作为附件关联到 selectionKey 上
                SelectionKey scKey = sc.register(selector, 0, buffer);
                scKey.interestOps(SelectionKey.OP_READ);
                log.debug(&quot;&#123;&#125;&quot;, sc);
                log.debug(&quot;scKey:&#123;&#125;&quot;, scKey);
            &#125; else if (key.isReadable()) &#123; // 如果是 read
                try &#123;
                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel
                    // 获取 selectionKey 上关联的附件
                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1
                    if(read == -1) &#123;
                        key.cancel();
                    &#125; else &#123;
                        split(buffer);
                        // 需要扩容
                        if (buffer.position() == buffer.limit()) &#123;
                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);
                            buffer.flip();
                            newBuffer.put(buffer); // 0123456789abcdef3333\n
                            key.attach(newBuffer);
                        &#125;
                    &#125;

                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端</p>
<pre><code class="java">SocketChannel sc = SocketChannel.open();
sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
SocketAddress address = sc.getLocalAddress();
// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));
sc.write(Charset.defaultCharset().encode(&quot;0123\n456789abcdef&quot;));
sc.write(Charset.defaultCharset().encode(&quot;0123456789abcdef3333\n&quot;));
System.in.read();</code></pre>
<h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul>
<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>
<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul>
<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
</li>
</ul>
<h3 id="处理-write-事件"><a href="#处理-write-事件" class="headerlink" title="处理 write 事件"></a>处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>
<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>如果不取消，会每次可写均会触发 write 事件</li>
</ul>
</li>
</ul>
<pre><code class="java">public class WriteServer &#123;

    public static void main(String[] args) throws IOException &#123;
        ServerSocketChannel ssc = ServerSocketChannel.open();
        ssc.configureBlocking(false);
        ssc.bind(new InetSocketAddress(8080));

        Selector selector = Selector.open();
        ssc.register(selector, SelectionKey.OP_ACCEPT);

        while(true) &#123;
            selector.select();

            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();
            while (iter.hasNext()) &#123;
                SelectionKey key = iter.next();
                iter.remove();
                if (key.isAcceptable()) &#123;
                    SocketChannel sc = ssc.accept();
                    sc.configureBlocking(false);
                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);
                    // 1. 向客户端发送内容
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0; i &lt; 3000000; i++) &#123;
                        sb.append(&quot;a&quot;);
                    &#125;
                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());
                    int write = sc.write(buffer);
                    // 3. write 表示实际写了多少字节
                    System.out.println(&quot;实际写入字节:&quot; + write);
                    // 4. 如果有剩余未读字节，才需要关注写事件
                    if (buffer.hasRemaining()) &#123;
                        // read 1  write 4
                        // 在原有关注事件的基础上，多关注 写事件
                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);
                        // 把 buffer 作为附件加入 sckey
                        sckey.attach(buffer);
                    &#125;
                &#125; else if (key.isWritable()) &#123;
                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    SocketChannel sc = (SocketChannel) key.channel();
                    int write = sc.write(buffer);
                    System.out.println(&quot;实际写入字节:&quot; + write);
                    if (!buffer.hasRemaining()) &#123; // 写完了
                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);
                        key.attach(null);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端</p>
<pre><code class="java">public class WriteClient &#123;
    public static void main(String[] args) throws IOException &#123;
        Selector selector = Selector.open();
        SocketChannel sc = SocketChannel.open();
        sc.configureBlocking(false);
        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);
        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
        int count = 0;
        while (true) &#123;
            selector.select();
            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();
            while (iter.hasNext()) &#123;
                SelectionKey key = iter.next();
                iter.remove();
                if (key.isConnectable()) &#123;
                    System.out.println(sc.finishConnect());
                &#125; else if (key.isReadable()) &#123;
                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);
                    count += sc.read(buffer);
                    buffer.clear();
                    System.out.println(count);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="💡-write-为何要取消"><a href="#💡-write-为何要取消" class="headerlink" title="💡 write 为何要取消"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>
<h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><h4 id="💡-利用多线程优化"><a href="#💡-利用多线程优化" class="headerlink" title="💡 利用多线程优化"></a>💡 利用多线程优化</h4><blockquote>
<p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p>
</blockquote>
<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理 accept 事件</li>
<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>
</ul>
<pre><code class="java">public class ChannelDemo7 &#123;
    public static void main(String[] args) throws IOException &#123;
        new BossEventLoop().register();
    &#125;


    @Slf4j
    static class BossEventLoop implements Runnable &#123;
        private Selector boss;
        private WorkerEventLoop[] workers;
        private volatile boolean start = false;
        AtomicInteger index = new AtomicInteger();

        public void register() throws IOException &#123;
            if (!start) &#123;
                ServerSocketChannel ssc = ServerSocketChannel.open();
                ssc.bind(new InetSocketAddress(8080));
                ssc.configureBlocking(false);
                boss = Selector.open();
                SelectionKey ssckey = ssc.register(boss, 0, null);
                ssckey.interestOps(SelectionKey.OP_ACCEPT);
                workers = initEventLoops();
                new Thread(this, &quot;boss&quot;).start();
                log.debug(&quot;boss start...&quot;);
                start = true;
            &#125;
        &#125;

        public WorkerEventLoop[] initEventLoops() &#123;
//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];
            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];
            for (int i = 0; i &lt; workerEventLoops.length; i++) &#123;
                workerEventLoops[i] = new WorkerEventLoop(i);
            &#125;
            return workerEventLoops;
        &#125;

        @Override
        public void run() &#123;
            while (true) &#123;
                try &#123;
                    boss.select();
                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();
                    while (iter.hasNext()) &#123;
                        SelectionKey key = iter.next();
                        iter.remove();
                        if (key.isAcceptable()) &#123;
                            ServerSocketChannel c = (ServerSocketChannel) key.channel();
                            SocketChannel sc = c.accept();
                            sc.configureBlocking(false);
                            log.debug(&quot;&#123;&#125; connected&quot;, sc.getRemoteAddress());
                            workers[index.getAndIncrement() % workers.length].register(sc);
                        &#125;
                    &#125;
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;

    @Slf4j
    static class WorkerEventLoop implements Runnable &#123;
        private Selector worker;
        private volatile boolean start = false;
        private int index;

        private final ConcurrentLinkedQueue&lt;Runnable&gt; tasks = new ConcurrentLinkedQueue&lt;&gt;();

        public WorkerEventLoop(int index) &#123;
            this.index = index;
        &#125;

        public void register(SocketChannel sc) throws IOException &#123;
            if (!start) &#123;
                worker = Selector.open();
                new Thread(this, &quot;worker-&quot; + index).start();
                start = true;
            &#125;
            tasks.add(() -&gt; &#123;
                try &#123;
                    SelectionKey sckey = sc.register(worker, 0, null);
                    sckey.interestOps(SelectionKey.OP_READ);
                    worker.selectNow();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;);
            worker.wakeup();
        &#125;

        @Override
        public void run() &#123;
            while (true) &#123;
                try &#123;
                    worker.select();
                    Runnable task = tasks.poll();
                    if (task != null) &#123;
                        task.run();
                    &#125;
                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();
                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();
                    while (iter.hasNext()) &#123;
                        SelectionKey key = iter.next();
                        if (key.isReadable()) &#123;
                            SocketChannel sc = (SocketChannel) key.channel();
                            ByteBuffer buffer = ByteBuffer.allocate(128);
                            try &#123;
                                int read = sc.read(buffer);
                                if (read == -1) &#123;
                                    key.cancel();
                                    sc.close();
                                &#125; else &#123;
                                    buffer.flip();
                                    log.debug(&quot;&#123;&#125; message:&quot;, sc.getRemoteAddress());
                                    debugAll(buffer);
                                &#125;
                            &#125; catch (IOException e) &#123;
                                e.printStackTrace();
                                key.cancel();
                                sc.close();
                            &#125;
                        &#125;
                        iter.remove();
                    &#125;
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="💡-如何拿到-cpu-个数"><a href="#💡-如何拿到-cpu-个数" class="headerlink" title="💡 如何拿到 cpu 个数"></a>💡 如何拿到 cpu 个数</h4><blockquote>
<ul>
<li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>
<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>
</ul>
</blockquote>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li>
<li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li>
</ul>
<p>首先启动服务器端</p>
<pre><code class="java">public class UdpServer &#123;
    public static void main(String[] args) &#123;
        try (DatagramChannel channel = DatagramChannel.open()) &#123;
            channel.socket().bind(new InetSocketAddress(9999));
            System.out.println(&quot;waiting...&quot;);
            ByteBuffer buffer = ByteBuffer.allocate(32);
            channel.receive(buffer);
            buffer.flip();
            debug(buffer);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>输出</p>
<pre><code>waiting...</code></pre>
<p>运行客户端</p>
<pre><code class="java">public class UdpClient &#123;
    public static void main(String[] args) &#123;
        try (DatagramChannel channel = DatagramChannel.open()) &#123;
            ByteBuffer buffer = StandardCharsets.UTF_8.encode(&quot;hello&quot;);
            InetSocketAddress address = new InetSocketAddress(&quot;localhost&quot;, 9999);
            channel.send(buffer, address);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>接下来服务器端输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 65 6c 6c 6f                                  |hello           |
+--------+-------------------------------------------------+----------------+</code></pre>
<h2 id="1-5-NIO-vs-BIO"><a href="#1-5-NIO-vs-BIO" class="headerlink" title="1.5 NIO vs BIO"></a>1.5 NIO vs BIO</h2><h3 id="stream-vs-channel"><a href="#stream-vs-channel" class="headerlink" title="stream vs channel"></a>stream vs channel</h3><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h3 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src="images/0033-8285561.png"></p>
<ul>
<li><p>阻塞 IO</p>
<p><img src="images/0039-8285561.png"></p>
</li>
<li><p>非阻塞  IO</p>
<p><img src="images/0035-8285561.png"></p>
</li>
<li><p>多路复用</p>
<p><img src="images/0038-8285561.png"></p>
</li>
<li><p>信号驱动</p>
</li>
<li><p>异步 IO</p>
<p><img src="images/0037-8285561.png"></p>
</li>
<li><p>阻塞 IO vs 多路复用</p>
<p><img src="images/0034-8285561.png"></p>
<p><img src="images/0036-8285561.png"></p>
</li>
</ul>
<blockquote>
<p>🔖 参考：UNIX 网络编程 - 卷 I</p>
</blockquote>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>
<pre><code class="java">File f = new File(&quot;helloword/data.txt&quot;);
RandomAccessFile file = new RandomAccessFile(file, &quot;r&quot;);

byte[] buf = new byte[(int)f.length()];
file.read(buf);

Socket socket = ...;
socket.getOutputStream().write(buf);</code></pre>
<p>内部工作流程是这样的：</p>
<p><img src="images/0024-8285561.png"></p>
<ol>
<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf </p>
<ul>
<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img src="images/0025-8285561.png"></p>
<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<p><img src="images/0026-8285561.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<p>进一步优化（linux 2.4）</p>
<p><img src="images/0027-8285561.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 IOCP 实现了真正的异步 IO</li>
<li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li>
</ul>
</blockquote>
<h4 id="文件-AIO"><a href="#文件-AIO" class="headerlink" title="文件 AIO"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>
<pre><code class="java">@Slf4j
public class AioDemo1 &#123;
    public static void main(String[] args) throws IOException &#123;
        try&#123;
            AsynchronousFileChannel s = 
                AsynchronousFileChannel.open(
                    Paths.get(&quot;1.txt&quot;), StandardOpenOption.READ);
            ByteBuffer buffer = ByteBuffer.allocate(2);
            log.debug(&quot;begin...&quot;);
            s.read(buffer, 0, null, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;
                @Override
                public void completed(Integer result, ByteBuffer attachment) &#123;
                    log.debug(&quot;read completed...&#123;&#125;&quot;, result);
                    buffer.flip();
                    debug(buffer);
                &#125;

                @Override
                public void failed(Throwable exc, ByteBuffer attachment) &#123;
                    log.debug(&quot;read failed...&quot;);
                &#125;
            &#125;);

        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        log.debug(&quot;do other things...&quot;);
        System.in.read();
    &#125;
&#125;</code></pre>
<p>输出</p>
<pre><code>13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...
13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...
13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 0d                                           |a.              |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>可以看到</p>
<ul>
<li>响应文件读取成功的是另一个线程 Thread-5</li>
<li>主线程并没有 IO 操作阻塞</li>
</ul>
<h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
<h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><pre><code class="java">public class AioServer &#123;
    public static void main(String[] args) throws IOException &#123;
        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();
        ssc.bind(new InetSocketAddress(8080));
        ssc.accept(null, new AcceptHandler(ssc));
        System.in.read();
    &#125;

    private static void closeChannel(AsynchronousSocketChannel sc) &#123;
        try &#123;
            System.out.printf(&quot;[%s] %s close\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());
            sc.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    private static class ReadHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;
        private final AsynchronousSocketChannel sc;

        public ReadHandler(AsynchronousSocketChannel sc) &#123;
            this.sc = sc;
        &#125;

        @Override
        public void completed(Integer result, ByteBuffer attachment) &#123;
            try &#123;
                if (result == -1) &#123;
                    closeChannel(sc);
                    return;
                &#125;
                System.out.printf(&quot;[%s] %s read\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());
                attachment.flip();
                System.out.println(Charset.defaultCharset().decode(attachment));
                attachment.clear();
                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件
                sc.read(attachment, attachment, this);
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) &#123;
            closeChannel(sc);
            exc.printStackTrace();
        &#125;
    &#125;

    private static class WriteHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;
        private final AsynchronousSocketChannel sc;

        private WriteHandler(AsynchronousSocketChannel sc) &#123;
            this.sc = sc;
        &#125;

        @Override
        public void completed(Integer result, ByteBuffer attachment) &#123;
            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容
            if (attachment.hasRemaining()) &#123;
                sc.write(attachment);
            &#125;
        &#125;

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) &#123;
            exc.printStackTrace();
            closeChannel(sc);
        &#125;
    &#125;

    private static class AcceptHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;
        private final AsynchronousServerSocketChannel ssc;

        public AcceptHandler(AsynchronousServerSocketChannel ssc) &#123;
            this.ssc = ssc;
        &#125;

        @Override
        public void completed(AsynchronousSocketChannel sc, Object attachment) &#123;
            try &#123;
                System.out.printf(&quot;[%s] %s connected\n&quot;, Thread.currentThread().getName(), sc.getRemoteAddress());
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            ByteBuffer buffer = ByteBuffer.allocate(16);
            // 读事件由 ReadHandler 处理
            sc.read(buffer, buffer, new ReadHandler(sc));
            // 写事件由 WriteHandler 处理
            sc.write(Charset.defaultCharset().encode(&quot;server hello!&quot;), ByteBuffer.allocate(16), new WriteHandler(sc));
            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件
            ssc.accept(null, this);
        &#125;

        @Override
        public void failed(Throwable exc, Object attachment) &#123;
            exc.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<h1 id="2-Netty-入门"><a href="#2-Netty-入门" class="headerlink" title="2 Netty 入门"></a>2 Netty 入门</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="Netty-是什么？"><a href="#Netty-是什么？" class="headerlink" title="Netty 是什么？"></a>Netty 是什么？</h3><pre><code>Netty is an asynchronous event-driven network application framework
for rapid development of maintainable high performance protocol servers &amp; clients.</code></pre>
<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端。</p>
<h3 id="Netty-的作者"><a href="#Netty-的作者" class="headerlink" title="Netty 的作者"></a>Netty 的作者</h3><p><img src="images/0005.png"></p>
<p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p>
<h3 id="Netty-的地位"><a href="#Netty-的地位" class="headerlink" title="Netty 的地位"></a>Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>
<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h3 id="Netty-的优势"><a href="#Netty-的优势" class="headerlink" title="Netty 的优势"></a>Netty 的优势</h3><ul>
<li>Netty vs NIO，工作量大，bug 多<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>epoll 空轮询导致 CPU 100%</li>
<li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li>
</ul>
</li>
<li>Netty vs 其它网络应用框架<ul>
<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>
<li>久经考验，16年，Netty 版本<ul>
<li>2.x 2004</li>
<li>3.x 2008</li>
<li>4.x 2013</li>
<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-Hello-World"><a href="#2-2-Hello-World" class="headerlink" title="2.2 Hello World"></a>2.2 Hello World</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回</li>
</ul>
<p>加入依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.netty&lt;/groupId&gt;
    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
    &lt;version&gt;4.1.39.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre><code class="java">new ServerBootstrap()
    .group(new NioEventLoopGroup()) // 1
    .channel(NioServerSocketChannel.class) // 2
    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; // 3
        protected void initChannel(NioSocketChannel ch) &#123;
            ch.pipeline().addLast(new StringDecoder()); // 5
            ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123; // 6
                @Override
                protected void channelRead0(ChannelHandlerContext ctx, String msg) &#123;
                    System.out.println(msg);
                &#125;
            &#125;);
        &#125;
    &#125;)
    .bind(8080); // 4</code></pre>
<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>
</li>
<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>
<p><img src="images/0006.png"></p>
</li>
<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>
</li>
<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p>
</li>
<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>
</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="java">new Bootstrap()
    .group(new NioEventLoopGroup()) // 1
    .channel(NioSocketChannel.class) // 2
    .handler(new ChannelInitializer&lt;Channel&gt;() &#123; // 3
        @Override
        protected void initChannel(Channel ch) &#123;
            ch.pipeline().addLast(new StringEncoder()); // 8
        &#125;
    &#125;)
    .connect(&quot;127.0.0.1&quot;, 8080) // 4
    .sync() // 5
    .channel() // 6
    .writeAndFlush(new Date() + &quot;: hello world!&quot;); // 7</code></pre>
<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>
</li>
<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>
<p><img src="images/0007.png"></p>
</li>
<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，指定要连接的服务器和端口</p>
</li>
<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p>
</li>
<li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p>
</li>
<li><p>7 处，写入消息并清空缓冲区</p>
</li>
<li><p>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</p>
</li>
<li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>
</li>
</ul>
<h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p><img src="images/0040.png"></p>
<h4 id="💡-提示"><a href="#💡-提示" class="headerlink" title="💡 提示"></a>💡 提示</h4><blockquote>
<p>一开始需要树立正确的观念</p>
<ul>
<li>把 channel 理解为数据的通道</li>
<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>把 handler 理解为数据的处理工序<ul>
<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler 分 Inbound 和 Outbound 两类</li>
</ul>
</li>
<li>把 eventLoop 理解为处理数据的工人<ul>
<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>
<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-3-组件"><a href="#2-3-组件" class="headerlink" title="2.3 组件"></a>2.3 组件</h2><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>事件循环对象</p>
<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 juc.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p>事件循环组</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<p>以一个简单的实现为例：</p>
<pre><code class="java">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程
DefaultEventLoopGroup group = new DefaultEventLoopGroup(2);
System.out.println(group.next());
System.out.println(group.next());
System.out.println(group.next());</code></pre>
<p>输出</p>
<pre><code>io.netty.channel.DefaultEventLoop@60f82f98
io.netty.channel.DefaultEventLoop@35f983a6
io.netty.channel.DefaultEventLoop@60f82f98</code></pre>
<p>也可以使用 for 循环</p>
<pre><code class="java">DefaultEventLoopGroup group = new DefaultEventLoopGroup(2);
for (EventExecutor eventLoop : group) &#123;
    System.out.println(eventLoop);
&#125;</code></pre>
<p>输出</p>
<pre><code>io.netty.channel.DefaultEventLoop@60f82f98
io.netty.channel.DefaultEventLoop@35f983a6</code></pre>
<h4 id="💡-优雅关闭"><a href="#💡-优雅关闭" class="headerlink" title="💡 优雅关闭"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h4 id="演示-NioEventLoop-处理-io-事件"><a href="#演示-NioEventLoop-处理-io-事件" class="headerlink" title="演示 NioEventLoop 处理 io 事件"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人</p>
<pre><code class="java">new ServerBootstrap()
    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))
    .channel(NioServerSocketChannel.class)
    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
        @Override
        protected void initChannel(NioSocketChannel ch) &#123;
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;
                    if (byteBuf != null) &#123;
                        byte[] buf = new byte[16];
                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());
                        log.debug(new String(buf));
                    &#125;
                &#125;
            &#125;);
        &#125;
    &#125;).bind(8080).sync();</code></pre>
<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<pre><code class="java">public static void main(String[] args) throws InterruptedException &#123;
    Channel channel = new Bootstrap()
            .group(new NioEventLoopGroup(1))
            .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
                @Override
                protected void initChannel(NioSocketChannel ch) throws Exception &#123;
                    System.out.println(&quot;init...&quot;);
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                &#125;
            &#125;)
            .channel(NioSocketChannel.class).connect(&quot;localhost&quot;, 8080)
            .sync()
            .channel();

    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;wangwu&quot;.getBytes()));
    Thread.sleep(2000);
    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;wangwu&quot;.getBytes()));</code></pre>
<p>最后输出</p>
<pre><code>22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       
22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       
22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           
22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           
22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        
22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </code></pre>
<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>
<p><img src="images/0042.png"></p>
<p>再增加两个非 nio 工人</p>
<pre><code class="java">DefaultEventLoopGroup normalWorkers = new DefaultEventLoopGroup(2);
new ServerBootstrap()
    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))
    .channel(NioServerSocketChannel.class)
    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
        @Override
        protected void initChannel(NioSocketChannel ch)  &#123;
            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
            ch.pipeline().addLast(normalWorkers,&quot;myhandler&quot;,
              new ChannelInboundHandlerAdapter() &#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;
                    if (byteBuf != null) &#123;
                        byte[] buf = new byte[16];
                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());
                        log.debug(new String(buf));
                    &#125;
                &#125;
            &#125;);
        &#125;
    &#125;).bind(8080).sync();</code></pre>
<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<p>输出</p>
<pre><code>22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED
22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE
22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |
+--------+-------------------------------------------------+----------------+
22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE
22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        
22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |
+--------+-------------------------------------------------+----------------+
22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE
22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        
22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED
22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE
22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 6c 69 73 69                                     |lisi            |
+--------+-------------------------------------------------+----------------+
22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE
22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            
22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 6c 69 73 69                                     |lisi            |
+--------+-------------------------------------------------+----------------+
22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE
22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            
22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED
22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE
22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 77 61 6e 67 77 75                               |wangwu          |
+--------+-------------------------------------------------+----------------+
22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE
22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          
22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 77 61 6e 67 77 75                               |wangwu          |
+--------+-------------------------------------------------+----------------+
22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE
22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </code></pre>
<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>
<p><img src="images/0041.png"></p>
<h4 id="💡-handler-执行中如何换人？"><a href="#💡-handler-执行中如何换人？" class="headerlink" title="💡 handler 执行中如何换人？"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>
<pre><code class="java">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;
    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);
    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程
    EventExecutor executor = next.executor();

    // 是，直接调用
    if (executor.inEventLoop()) &#123;
        next.invokeChannelRead(m);
    &#125; 
    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）
    else &#123;
        executor.execute(new Runnable() &#123;
            @Override
            public void run() &#123;
                next.invokeChannelRead(m);
            &#125;
        &#125;);
    &#125;
&#125;</code></pre>
<ul>
<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>
</ul>
<h4 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>
<pre><code class="java">NioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);

log.debug(&quot;server start...&quot;);
Thread.sleep(2000);
nioWorkers.execute(()-&gt;&#123;
    log.debug(&quot;normal task...&quot;);
&#125;);</code></pre>
<p>输出</p>
<pre><code>22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...
22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</code></pre>
<blockquote>
<p>可以用来执行耗时较长的任务</p>
</blockquote>
<h4 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h4><pre><code class="java">NioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);

log.debug(&quot;server start...&quot;);
Thread.sleep(2000);
nioWorkers.scheduleAtFixedRate(() -&gt; &#123;
    log.debug(&quot;running...&quot;);
&#125;, 0, 1, TimeUnit.SECONDS);</code></pre>
<p>输出</p>
<pre><code>22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...
22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...
22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...
22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...
22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...
...</code></pre>
<blockquote>
<p>可以用来执行定时任务</p>
</blockquote>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel 的主要作用</p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>这是刚才的客户端代码</p>
<pre><code class="java">new Bootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        protected void initChannel(Channel ch) &#123;
            ch.pipeline().addLast(new StringEncoder());
        &#125;
    &#125;)
    .connect(&quot;127.0.0.1&quot;, 8080)
    .sync()
    .channel()
    .writeAndFlush(new Date() + &quot;: hello world!&quot;);</code></pre>
<p>现在把它拆开来看</p>
<pre><code class="java">ChannelFuture channelFuture = new Bootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        protected void initChannel(Channel ch) &#123;
            ch.pipeline().addLast(new StringEncoder());
        &#125;
    &#125;)
    .connect(&quot;127.0.0.1&quot;, 8080); // 1

channelFuture.sync().channel().writeAndFlush(new Date() + &quot;: hello world!&quot;);</code></pre>
<ul>
<li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li>
</ul>
<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>
<p>实验如下：</p>
<pre><code class="java">ChannelFuture channelFuture = new Bootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        protected void initChannel(Channel ch) &#123;
            ch.pipeline().addLast(new StringEncoder());
        &#125;
    &#125;)
    .connect(&quot;127.0.0.1&quot;, 8080);

System.out.println(channelFuture.channel()); // 1
channelFuture.sync(); // 2
System.out.println(channelFuture.channel()); // 3</code></pre>
<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>
<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>
<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>
</ul>
<p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p>
<pre><code class="java">ChannelFuture channelFuture = new Bootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        protected void initChannel(Channel ch) &#123;
            ch.pipeline().addLast(new StringEncoder());
        &#125;
    &#125;)
    .connect(&quot;127.0.0.1&quot;, 8080);
System.out.println(channelFuture.channel()); // 1
channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;
    System.out.println(future.channel()); // 2
&#125;);</code></pre>
<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>
<li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>
</ul>
<h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><pre><code class="java">@Slf4j
public class CloseFutureClient &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        NioEventLoopGroup group new NioEventLoopGroup();
        ChannelFuture channelFuture = new Bootstrap()
                .group(group)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
                    @Override // 在连接建立后被调用
                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;
                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                        ch.pipeline().addLast(new StringEncoder());
                    &#125;
                &#125;)
                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));
        Channel channel = channelFuture.sync().channel();
        log.debug(&quot;&#123;&#125;&quot;, channel);
        new Thread(()-&gt;&#123;
            Scanner scanner = new Scanner(System.in);
            while (true) &#123;
                String line = scanner.nextLine();
                if (&quot;q&quot;.equals(line)) &#123;
                    channel.close(); // close 异步操作 1s 之后
//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后
                    break;
                &#125;
                channel.writeAndFlush(line);
            &#125;
        &#125;, &quot;input&quot;).start();

        // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭
        ChannelFuture closeFuture = channel.closeFuture();
        /*log.debug(&quot;waiting close...&quot;);
        closeFuture.sync();
        log.debug(&quot;处理关闭之后的操作&quot;);*/
        closeFuture.addListener(new ChannelFutureListener() &#123;
            @Override
            public void operationComplete(ChannelFuture future) throws Exception &#123;
                log.debug(&quot;处理关闭之后的操作&quot;);
                group.shutdownGracefully();
            &#125;
        &#125;);
    &#125;
&#125;</code></pre>
<h4 id="💡-异步提升的是什么"><a href="#💡-异步提升的是什么" class="headerlink" title="💡 异步提升的是什么"></a>💡 异步提升的是什么</h4><ul>
<li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p>
</li>
<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>
</li>
</ul>
<p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>
<p><img src="images/0044.png"></p>
<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>
<p><img src="images/0048.png"></p>
<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>
<p><img src="images/0047.png"></p>
<p>要点</p>
<ul>
<li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li>
<li>异步并没有缩短响应时间，反而有所增加</li>
<li>合理进行任务拆分，也是利用异步的关键</li>
</ul>
<h3 id="Future-amp-Promise"><a href="#Future-amp-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>
<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<p>例1</p>
<p>同步处理任务成功</p>
<pre><code class="java">DefaultEventLoop eventExecutors = new DefaultEventLoop();
DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);

eventExecutors.execute(()-&gt;&#123;
    try &#123;
        Thread.sleep(1000);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    log.debug(&quot;set success, &#123;&#125;&quot;,10);
    promise.setSuccess(10);
&#125;);

log.debug(&quot;start...&quot;);
log.debug(&quot;&#123;&#125;&quot;,promise.getNow()); // 还没有结果
log.debug(&quot;&#123;&#125;&quot;,promise.get());</code></pre>
<p>输出</p>
<pre><code>11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...
11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null
11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10
11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</code></pre>
<p>例2</p>
<p>异步处理任务成功</p>
<pre><code class="java">DefaultEventLoop eventExecutors = new DefaultEventLoop();
DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);

// 设置回调，异步接收结果
promise.addListener(future -&gt; &#123;
    // 这里的 future 就是上面的 promise
    log.debug(&quot;&#123;&#125;&quot;,future.getNow());
&#125;);

// 等待 1000 后设置成功结果
eventExecutors.execute(()-&gt;&#123;
    try &#123;
        Thread.sleep(1000);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    log.debug(&quot;set success, &#123;&#125;&quot;,10);
    promise.setSuccess(10);
&#125;);

log.debug(&quot;start...&quot;);</code></pre>
<p>输出</p>
<pre><code>11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...
11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10
11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</code></pre>
<p>例3</p>
<p>同步处理任务失败 - sync &amp; get</p>
<pre><code class="java">DefaultEventLoop eventExecutors = new DefaultEventLoop();
        DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);

        eventExecutors.execute(() -&gt; &#123;
            try &#123;
                Thread.sleep(1000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            RuntimeException e = new RuntimeException(&quot;error...&quot;);
            log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());
            promise.setFailure(e);
        &#125;);

        log.debug(&quot;start...&quot;);
        log.debug(&quot;&#123;&#125;&quot;, promise.getNow());
        promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</code></pre>
<p>输出</p>
<pre><code>12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...
12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null
12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...
Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...
    at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)
    at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)
Caused by: java.lang.RuntimeException: error...
    at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)
    at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:745)</code></pre>
<p>例4</p>
<p>同步处理任务失败 - await</p>
<pre><code class="java">DefaultEventLoop eventExecutors = new DefaultEventLoop();
DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);

eventExecutors.execute(() -&gt; &#123;
    try &#123;
        Thread.sleep(1000);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    RuntimeException e = new RuntimeException(&quot;error...&quot;);
    log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());
    promise.setFailure(e);
&#125;);

log.debug(&quot;start...&quot;);
log.debug(&quot;&#123;&#125;&quot;, promise.getNow());
promise.await(); // 与 sync 和 get 区别在于，不会抛异常
log.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</code></pre>
<p>输出</p>
<pre><code>12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...
12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null
12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...
12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</code></pre>
<p>例5</p>
<p>异步处理任务失败</p>
<pre><code class="java">DefaultEventLoop eventExecutors = new DefaultEventLoop();
DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);

promise.addListener(future -&gt; &#123;
    log.debug(&quot;result &#123;&#125;&quot;, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());
&#125;);

eventExecutors.execute(() -&gt; &#123;
    try &#123;
        Thread.sleep(1000);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
    RuntimeException e = new RuntimeException(&quot;error...&quot;);
    log.debug(&quot;set failure, &#123;&#125;&quot;, e.toString());
    promise.setFailure(e);
&#125;);

log.debug(&quot;start...&quot;);</code></pre>
<p>输出</p>
<pre><code>12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...
12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...
12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</code></pre>
<p>例6</p>
<p>await 死锁检查</p>
<pre><code class="java">DefaultEventLoop eventExecutors = new DefaultEventLoop();
DefaultPromise&lt;Integer&gt; promise = new DefaultPromise&lt;&gt;(eventExecutors);

eventExecutors.submit(()-&gt;&#123;
    System.out.println(&quot;1&quot;);
    try &#123;
        promise.await();
        // 注意不能仅捕获 InterruptedException 异常
        // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播
        // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出
    &#125; catch (Exception e) &#123; 
        e.printStackTrace();
    &#125;
    System.out.println(&quot;2&quot;);
&#125;);
eventExecutors.submit(()-&gt;&#123;
    System.out.println(&quot;3&quot;);
    try &#123;
        promise.await();
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
    System.out.println(&quot;4&quot;);
&#125;);</code></pre>
<p>输出</p>
<pre><code>1
2
3
4
io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)
    at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)
    at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)
    at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)
    at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
    at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)
    at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:745)
io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)
    at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)
    at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)
    at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)
    at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
    at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)
    at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
    at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:745)
</code></pre>
<h3 id="Handler-amp-Pipeline"><a href="#Handler-amp-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>
</ul>
<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>
<p>先搞清楚顺序，服务端</p>
<pre><code class="java">new ServerBootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioServerSocketChannel.class)
    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
        protected void initChannel(NioSocketChannel ch) &#123;
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    System.out.println(1);
                    ctx.fireChannelRead(msg); // 1
                &#125;
            &#125;);
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    System.out.println(2);
                    ctx.fireChannelRead(msg); // 2
                &#125;
            &#125;);
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    System.out.println(3);
                    ctx.channel().write(msg); // 3
                &#125;
            &#125;);
            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;
                @Override
                public void write(ChannelHandlerContext ctx, Object msg, 
                                  ChannelPromise promise) &#123;
                    System.out.println(4);
                    ctx.write(msg, promise); // 4
                &#125;
            &#125;);
            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;
                @Override
                public void write(ChannelHandlerContext ctx, Object msg, 
                                  ChannelPromise promise) &#123;
                    System.out.println(5);
                    ctx.write(msg, promise); // 5
                &#125;
            &#125;);
            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter()&#123;
                @Override
                public void write(ChannelHandlerContext ctx, Object msg, 
                                  ChannelPromise promise) &#123;
                    System.out.println(6);
                    ctx.write(msg, promise); // 6
                &#125;
            &#125;);
        &#125;
    &#125;)
    .bind(8080);</code></pre>
<p>客户端</p>
<pre><code class="java">new Bootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        protected void initChannel(Channel ch) &#123;
            ch.pipeline().addLast(new StringEncoder());
        &#125;
    &#125;)
    .connect(&quot;127.0.0.1&quot;, 8080)
    .addListener((ChannelFutureListener) future -&gt; &#123;
        future.channel().writeAndFlush(&quot;hello,world&quot;);
    &#125;);</code></pre>
<p>服务器端打印：</p>
<pre><code>1
2
3
6
5
4</code></pre>
<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>
<p><img src="images/0008.png"></p>
<ul>
<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>
<li>如果注释掉 1 处代码，则仅会打印 1</li>
<li>如果注释掉 2 处代码，则仅会打印 1 2</li>
</ul>
</li>
<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>
<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>
</ul>
</li>
<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>
<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>
</ul>
</li>
<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>
<li>都是触发出站处理器的执行</li>
<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>
<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>
<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>
<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>
</ul>
</li>
</ul>
<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>
<p><img src="images/0009.png"></p>
<h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>是对字节数据的封装</p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><pre><code class="java">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);
log(buffer);</code></pre>
<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>
<p>输出</p>
<pre><code>read index:0 write index:0 capacity:10</code></pre>
<p>其中 log 方法参考如下</p>
<pre><code class="java">private static void log(ByteBuf buffer) &#123;
    int length = buffer.readableBytes();
    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;
    StringBuilder buf = new StringBuilder(rows * 80 * 2)
        .append(&quot;read index:&quot;).append(buffer.readerIndex())
        .append(&quot; write index:&quot;).append(buffer.writerIndex())
        .append(&quot; capacity:&quot;).append(buffer.capacity())
        .append(NEWLINE);
    appendPrettyHexDump(buf, buffer);
    System.out.println(buf.toString());
&#125;</code></pre>
<h4 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>
<pre><code class="java">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);</code></pre>
<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>
<pre><code class="java">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);</code></pre>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h4 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<pre><code class="java">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</code></pre>
<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>ByteBuf 由四部分组成</p>
<p><img src="images/0010.png"></p>
<p>最开始读写指针都在 0 位置</p>
<h4 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h4><p>方法列表，省略一些不重要的方法</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
</blockquote>
<p>先写入 4 个字节</p>
<pre><code class="java">buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
log(buffer);</code></pre>
<p>结果是</p>
<pre><code>read index:0 write index:4 capacity:10
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04                                     |....            |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>再写入一个 int 整数，也是 4 个字节</p>
<pre><code class="java">buffer.writeInt(5);
log(buffer);</code></pre>
<p>结果是</p>
<pre><code>read index:0 write index:8 capacity:10
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 00 00 00 05                         |........        |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>
<pre><code class="java">buffer.writeInt(6);
log(buffer);</code></pre>
<p>扩容规则是</p>
<ul>
<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>结果是</p>
<pre><code>read index:0 write index:12 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |
+--------+-------------------------------------------------+----------------+</code></pre>
<h4 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h4><p>例如读了 4 次，每次一个字节</p>
<pre><code class="java">System.out.println(buffer.readByte());
System.out.println(buffer.readByte());
System.out.println(buffer.readByte());
System.out.println(buffer.readByte());
log(buffer);</code></pre>
<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<pre><code>1
2
3
4
read index:4 write index:12 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 00 00 05 00 00 00 06                         |........        |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>如果需要重复读取 int 整数 5，怎么办？</p>
<p>可以在 read 前先做个标记 mark</p>
<pre><code class="java">buffer.markReaderIndex();
System.out.println(buffer.readInt());
log(buffer);</code></pre>
<p>结果</p>
<pre><code>5
read index:8 write index:12 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 00 00 06                                     |....            |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>这时要重复读取的话，重置到标记位置 reset</p>
<pre><code class="java">buffer.resetReaderIndex();
log(buffer);</code></pre>
<p>这时</p>
<pre><code>read index:4 write index:12 capacity:16
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 00 00 05 00 00 00 06                         |........        |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>
<h4 id="retain-amp-release"><a href="#retain-amp-release" class="headerlink" title="retain &amp; release"></a>retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<blockquote>
<p>回收内存的源码实现，请关注下面方法的不同实现</p>
<p><code>protected abstract void deallocate()</code></p>
</blockquote>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<p>谁来负责 release 呢？</p>
<p>不是我们想象的（一般情况下）</p>
<pre><code class="java">ByteBuf buf = ...
try &#123;
    ...
&#125; finally &#123;
    buf.release();
&#125;</code></pre>
<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>
<ul>
<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>
<li>入站 ByteBuf 处理原则<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>
<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>
<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>
<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li>出站 ByteBuf 处理原则<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>
</ul>
</li>
<li>异常处理原则<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<p>TailContext 释放未处理消息逻辑</p>
<pre><code class="java">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)
protected void onUnhandledInboundMessage(Object msg) &#123;
    try &#123;
        logger.debug(
            &quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot; +
            &quot;Please check your pipeline configuration.&quot;, msg);
    &#125; finally &#123;
        ReferenceCountUtil.release(msg);
    &#125;
&#125;</code></pre>
<p>具体代码</p>
<pre><code class="java">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)
public static boolean release(Object msg) &#123;
    if (msg instanceof ReferenceCounted) &#123;
        return ((ReferenceCounted) msg).release();
    &#125;
    return false;
&#125;</code></pre>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<p><img src="images/0011.png"></p>
<p>例，原始 ByteBuf 进行一些初始操作</p>
<pre><code class="java">ByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10);
origin.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
origin.readByte();
System.out.println(ByteBufUtil.prettyHexDump(origin));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 02 03 04                                        |...             |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>
<pre><code class="java">ByteBuf slice = origin.slice();
System.out.println(ByteBufUtil.prettyHexDump(slice));
// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 02 03 04                                        |...             |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>
<pre><code class="java">origin.readByte();
System.out.println(ByteBufUtil.prettyHexDump(origin));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 03 04                                           |..              |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>这时的 slice 不受影响，因为它有独立的读写指针</p>
<pre><code class="java">System.out.println(ByteBufUtil.prettyHexDump(slice));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 02 03 04                                        |...             |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>如果 slice 的内容发生了更改</p>
<pre><code class="java">slice.setByte(2, 5);
System.out.println(ByteBufUtil.prettyHexDump(slice));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 02 03 05                                        |...             |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
<pre><code>System.out.println(ByteBufUtil.prettyHexDump(origin));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 03 05                                           |..              |
+--------+-------------------------------------------------+----------------+</code></pre>
<h4 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<p><img src="images/0012.png"></p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<h4 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<p>有两个 ByteBuf 如下</p>
<pre><code class="java">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);
buf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);
ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);
buf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);
System.out.println(ByteBufUtil.prettyHexDump(buf1));
System.out.println(ByteBufUtil.prettyHexDump(buf2));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 05                                  |.....           |
+--------+-------------------------------------------------+----------------+
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 06 07 08 09 0a                                  |.....           |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>
<p>方法1：</p>
<pre><code class="java">ByteBuf buf3 = ByteBufAllocator.DEFAULT
    .buffer(buf1.readableBytes()+buf2.readableBytes());
buf3.writeBytes(buf1);
buf3.writeBytes(buf2);
System.out.println(ByteBufUtil.prettyHexDump(buf3));</code></pre>
<p>结果</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>
<p>方法2：</p>
<pre><code class="java">CompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();
// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0
buf3.addComponents(true, buf1, buf2);</code></pre>
<p>结果是一样的</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h4 id="Unpooled"><a href="#Unpooled" class="headerlink" title="Unpooled"></a>Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>
<pre><code class="java">ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);
buf1.writeBytes(new byte[]&#123;1, 2, 3, 4, 5&#125;);
ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);
buf2.writeBytes(new byte[]&#123;6, 7, 8, 9, 10&#125;);

// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf
ByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);
System.out.println(ByteBufUtil.prettyHexDump(buf3));</code></pre>
<p>输出</p>
<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |
+--------+-------------------------------------------------+----------------+</code></pre>
<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>
<pre><code class="java">ByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]&#123;1, 2, 3&#125;, new byte[]&#123;4, 5, 6&#125;);
System.out.println(buf4.getClass());
System.out.println(ByteBufUtil.prettyHexDump(buf4));</code></pre>
<p>输出</p>
<pre><code>class io.netty.buffer.CompositeByteBuf
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 02 03 04 05 06                               |......          |
+--------+-------------------------------------------------+----------------+</code></pre>
<h4 id="💡-ByteBuf-优势"><a href="#💡-ByteBuf-优势" class="headerlink" title="💡 ByteBuf 优势"></a>💡 ByteBuf 优势</h4><ul>
<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<h2 id="2-4-双向通信"><a href="#2-4-双向通信" class="headerlink" title="2.4 双向通信"></a>2.4 双向通信</h2><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>实现一个 echo server</p>
<p>编写 server</p>
<pre><code class="java">new ServerBootstrap()
    .group(new NioEventLoopGroup())
    .channel(NioServerSocketChannel.class)
    .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
        @Override
        protected void initChannel(NioSocketChannel ch) &#123;
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter()&#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    ByteBuf buffer = (ByteBuf) msg;
                    System.out.println(buffer.toString(Charset.defaultCharset()));

                    // 建议使用 ctx.alloc() 创建 ByteBuf
                    ByteBuf response = ctx.alloc().buffer();
                    response.writeBytes(buffer);
                    ctx.writeAndFlush(response);

                    // 思考：需要释放 buffer 吗
                    // 思考：需要释放 response 吗
                &#125;
            &#125;);
        &#125;
    &#125;).bind(8080);</code></pre>
<p>编写 client</p>
<pre><code class="java">NioEventLoopGroup group = new NioEventLoopGroup();
Channel channel = new Bootstrap()
    .group(group)
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;
        @Override
        protected void initChannel(NioSocketChannel ch) throws Exception &#123;
            ch.pipeline().addLast(new StringEncoder());
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
                    ByteBuf buffer = (ByteBuf) msg;
                    System.out.println(buffer.toString(Charset.defaultCharset()));

                    // 思考：需要释放 buffer 吗
                &#125;
            &#125;);
        &#125;
    &#125;).connect(&quot;127.0.0.1&quot;, 8080).sync().channel();

channel.closeFuture().addListener(future -&gt; &#123;
    group.shutdownGracefully();
&#125;);

new Thread(() -&gt; &#123;
    Scanner scanner = new Scanner(System.in);
    while (true) &#123;
        String line = scanner.nextLine();
        if (&quot;q&quot;.equals(line)) &#123;
            channel.close();
            break;
        &#125;
        channel.writeAndFlush(line);
    &#125;
&#125;).start();</code></pre>
<h3 id="💡-读和写的误解"><a href="#💡-读和写的误解" class="headerlink" title="💡 读和写的误解"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>例如</p>
<pre><code class="java">public class TestServer &#123;
    public static void main(String[] args) throws IOException &#123;
        ServerSocket ss = new ServerSocket(8888);
        Socket s = ss.accept();

        new Thread(() -&gt; &#123;
            try &#123;
                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));
                while (true) &#123;
                    System.out.println(reader.readLine());
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();

        new Thread(() -&gt; &#123;
            try &#123;
                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
                // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据
                for (int i = 0; i &lt; 100; i++) &#123;
                    writer.write(String.valueOf(i));
                    writer.newLine();
                    writer.flush();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
    &#125;
&#125;</code></pre>
<p>客户端</p>
<pre><code class="java">public class TestClient &#123;
    public static void main(String[] args) throws IOException &#123;
        Socket s = new Socket(&quot;localhost&quot;, 8888);

        new Thread(() -&gt; &#123;
            try &#123;
                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));
                while (true) &#123;
                    System.out.println(reader.readLine());
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();

        new Thread(() -&gt; &#123;
            try &#123;
                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
                for (int i = 0; i &lt; 100; i++) &#123;
                    writer.write(String.valueOf(i));
                    writer.newLine();
                    writer.flush();
                &#125;
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();
    &#125;
&#125;</code></pre>
<h1 id="3-Netty-进阶"><a href="#3-Netty-进阶" class="headerlink" title="3 Netty 进阶"></a>3 Netty 进阶</h1><h2 id="3-1-粘包与半包"><a href="#3-1-粘包与半包" class="headerlink" title="3.1 粘包与半包"></a>3.1 粘包与半包</h2><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p>服务端代码</p>
<pre><code class="java">public class HelloWorldServer &#123;
    static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class);
    void start() &#123;
        NioEventLoopGroup boss = new NioEventLoopGroup(1);
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try &#123;
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());
                            super.channelActive(ctx);
                        &#125;

                        @Override
                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());
                            super.channelInactive(ctx);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture = serverBootstrap.bind(8080);
            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());
            channelFuture.sync();
            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;server error&quot;, e);
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
            log.debug(&quot;stoped&quot;);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        new HelloWorldServer().start();
    &#125;
&#125;</code></pre>
<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>
<pre><code class="java">public class HelloWorldClient &#123;
    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);
    public static void main(String[] args) &#123;
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    log.debug(&quot;connetted...&quot;);
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;sending...&quot;);
                            Random r = new Random();
                            char c = &#39;a&#39;;
                            for (int i = 0; i &lt; 10; i++) &#123;
                                ByteBuf buffer = ctx.alloc().buffer();
                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);
                                ctx.writeAndFlush(buffer);
                            &#125;
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>
<pre><code>08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...
08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...
08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED
08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE
08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]
08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
+--------+-------------------------------------------------+----------------+
08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</code></pre>
<h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>
<pre><code class="java">ByteBuf buffer = ctx.alloc().buffer();
for (int i = 0; i &lt; 10; i++) &#123;
    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);
&#125;
ctx.writeAndFlush(buffer);</code></pre>
<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>
<pre><code class="java">serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</code></pre>
<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>
<pre><code>08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...
08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...
08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED
08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE
08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]
08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|
|00000010| 00 01 02 03                                     |....            |
+--------+-------------------------------------------------+----------------+
08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE
08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|
|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |
+--------+-------------------------------------------------+----------------+
08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</code></pre>
<blockquote>
<p><strong>注意</strong></p>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>
</blockquote>
<h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><p>粘包</p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p>本质是因为 TCP 是流式协议，消息无边界</p>
<blockquote>
<p>滑动窗口</p>
<ul>
<li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p>
<p><img src="images/0049.png"></p>
</li>
</ul>
<ul>
<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p>
<p><img src="images/0051.png"></p>
</li>
<li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p>
<ul>
<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p> MSS 限制</p>
<ul>
<li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p>
<ul>
<li>以太网的 MTU 是 1500</li>
<li>FDDI（光纤分布式数据接口）的 MTU 是 4352</li>
<li>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</li>
</ul>
</li>
<li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p>
<ul>
<li>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</li>
<li>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</li>
<li>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</li>
</ul>
<img src="images/0031.jpg" style="zoom:50%;" />
</li>
</ul>
</blockquote>
<blockquote>
<p>Nagle 算法</p>
<ul>
<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>
<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>
<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>
<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>
<li>如果 TCP_NODELAY = true，则需要发送</li>
<li>已发送的数据都收到 ack 时，则需要发送</li>
<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li>
<li>除上述情况，延迟发送</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
<li>每一条消息采用固定长度，缺点浪费空间</li>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义</li>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>
</ol>
<h4 id="方法1：短链接"><a href="#方法1：短链接" class="headerlink" title="方法1：短链接"></a>方法1：短链接</h4><p>以解决粘包为例</p>
<pre><code class="java">public class HelloWorldClient &#123;
    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);

    public static void main(String[] args) &#123;
        // 分 10 次发送
        for (int i = 0; i &lt; 10; i++) &#123;
            send();
        &#125;
    &#125;

    private static void send() &#123;
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    log.debug(&quot;conneted...&quot;);
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;sending...&quot;);
                            ByteBuf buffer = ctx.alloc().buffer();
                            buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);
                            ctx.writeAndFlush(buffer);
                            // 发完即关
                            ctx.close();
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 8080).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>输出，略</p>
<blockquote>
<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>
</blockquote>
<h4 id="方法2：固定长度"><a href="#方法2：固定长度" class="headerlink" title="方法2：固定长度"></a>方法2：固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>
<pre><code class="java">ch.pipeline().addLast(new FixedLengthFrameDecoder(8));</code></pre>
<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>
<pre><code class="java">public class HelloWorldClient &#123;
    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);

    public static void main(String[] args) &#123;
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    log.debug(&quot;connetted...&quot;);
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;sending...&quot;);
                            // 发送内容随机的数据包
                            Random r = new Random();
                            char c = &#39;a&#39;;
                            ByteBuf buffer = ctx.alloc().buffer();
                            for (int i = 0; i &lt; 10; i++) &#123;
                                byte[] bytes = new byte[8];
                                for (int j = 0; j &lt; r.nextInt(8); j++) &#123;
                                    bytes[j] = (byte) c;
                                &#125;
                                c++;
                                buffer.writeBytes(bytes);
                            &#125;
                            ctx.writeAndFlush(buffer);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture = bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端输出</p>
<pre><code>12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...
12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED
12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090
12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE
12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...
12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|
|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|
|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|
|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|
|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</code></pre>
<p>服务端输出</p>
<pre><code>12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...
12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 00 00 00 00 00 00 00                         |b.......        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 63 63 00 00 00 00 00 00                         |cc......        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 64 00 00 00 00 00 00 00                         |d.......        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 00 00 00 00 00 00 00 00                         |........        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 00 00 00 00 00 00 00                         |h.......        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |
+--------+-------------------------------------------------+----------------+
12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</code></pre>
<p>缺点是，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<h4 id="方法3：固定分隔符"><a href="#方法3：固定分隔符" class="headerlink" title="方法3：固定分隔符"></a>方法3：固定分隔符</h4><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>
<pre><code class="java">ch.pipeline().addLast(new LineBasedFrameDecoder(1024));</code></pre>
<p>客户端在每条消息之后，加入 \n 分隔符</p>
<pre><code class="java">public class HelloWorldClient &#123;
    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);

    public static void main(String[] args) &#123;
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    log.debug(&quot;connetted...&quot;);
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;sending...&quot;);
                            Random r = new Random();
                            char c = &#39;a&#39;;
                            ByteBuf buffer = ctx.alloc().buffer();
                            for (int i = 0; i &lt; 10; i++) &#123;
                                for (int j = 1; j &lt;= r.nextInt(16)+1; j++) &#123;
                                    buffer.writeByte((byte) c);
                                &#125;
                                buffer.writeByte(10);
                                c++;
                            &#125;
                            ctx.writeAndFlush(buffer);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture = bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端输出</p>
<pre><code>14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...
14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED
14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090
14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE
14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...
14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|
|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|
|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|
|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</code></pre>
<p>服务端输出</p>
<pre><code>14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61                                              |a               |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 62 62                                        |bbb             |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 63 63 63                                        |ccc             |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 64 64                                           |dd              |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 66 66                                           |ff              |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 67 67 67 67 67 67 67                            |ggggggg         |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 68 68 68                                     |hhhh            |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |
+--------+-------------------------------------------------+----------------+
14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</code></pre>
<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<h4 id="方法4：预设长度"><a href="#方法4：预设长度" class="headerlink" title="方法4：预设长度"></a>方法4：预设长度</h4><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>
<pre><code class="java">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数
ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));</code></pre>
<p>客户端代码</p>
<pre><code class="java">public class HelloWorldClient &#123;
    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);

    public static void main(String[] args) &#123;
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(worker);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    log.debug(&quot;connetted...&quot;);
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            log.debug(&quot;sending...&quot;);
                            Random r = new Random();
                            char c = &#39;a&#39;;
                            ByteBuf buffer = ctx.alloc().buffer();
                            for (int i = 0; i &lt; 10; i++) &#123;
                                byte length = (byte) (r.nextInt(16) + 1);
                                // 先写入长度
                                buffer.writeByte(length);
                                // 再
                                for (int j = 1; j &lt;= length; j++) &#123;
                                    buffer.writeByte((byte) c);
                                &#125;
                                c++;
                            &#125;
                            ctx.writeAndFlush(buffer);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            ChannelFuture channelFuture = bootstrap.connect(&quot;192.168.0.103&quot;, 9090).sync();
            channelFuture.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端输出</p>
<pre><code>14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...
14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED
14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090
14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE
14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...
14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|
|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|
|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|
|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|
|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|
|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|
|00000060| 6a                                              |j               |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</code></pre>
<p>服务端输出</p>
<pre><code>14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...
14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 63 63 63 63 63 63                               |cccccc          |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 67 67                                           |gg              |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 68 68                                           |hh              |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |
+--------+-------------------------------------------------+----------------+
14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE
</code></pre>
<h2 id="3-2-协议设计与解析"><a href="#3-2-协议设计与解析" class="headerlink" title="3.2 协议设计与解析"></a>3.2 协议设计与解析</h2><h3 id="为什么需要协议？"><a href="#为什么需要协议？" class="headerlink" title="为什么需要协议？"></a>为什么需要协议？</h3><p>TCP/IP 中消息传输基于流的方式，没有边界。</p>
<p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
<p>例如：在网络上传输</p>
<pre><code>下雨天留客天留我不留</code></pre>
<p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p>
<p>一种解读</p>
<pre><code>下雨天留客，天留，我不留</code></pre>
<p>另一种解读</p>
<pre><code>下雨天，留客天，留我不？留</code></pre>
<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>
<pre><code>定长字节表示内容长度 + 实际内容</code></pre>
<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>
<pre><code>0f下雨天留客06天留09我不留</code></pre>
<blockquote>
<p>小故事</p>
<p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p>
<p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p>
<p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p>
<p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p>
<p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p>
</blockquote>
<h3 id="redis-协议举例"><a href="#redis-协议举例" class="headerlink" title="redis 协议举例"></a>redis 协议举例</h3><pre><code class="java">NioEventLoopGroup worker = new NioEventLoopGroup();
byte[] LINE = &#123;13, 10&#125;;
try &#123;
    Bootstrap bootstrap = new Bootstrap();
    bootstrap.channel(NioSocketChannel.class);
    bootstrap.group(worker);
    bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
        @Override
        protected void initChannel(SocketChannel ch) &#123;
            ch.pipeline().addLast(new LoggingHandler());
            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                // 会在连接 channel 建立成功后，会触发 active 事件
                @Override
                public void channelActive(ChannelHandlerContext ctx) &#123;
                    set(ctx);
                    get(ctx);
                &#125;
                private void get(ChannelHandlerContext ctx) &#123;
                    ByteBuf buf = ctx.alloc().buffer();
                    buf.writeBytes(&quot;*2&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;$3&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;get&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;$3&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;aaa&quot;.getBytes());
                    buf.writeBytes(LINE);
                    ctx.writeAndFlush(buf);
                &#125;
                private void set(ChannelHandlerContext ctx) &#123;
                    ByteBuf buf = ctx.alloc().buffer();
                    buf.writeBytes(&quot;*3&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;$3&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;set&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;$3&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;aaa&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;$3&quot;.getBytes());
                    buf.writeBytes(LINE);
                    buf.writeBytes(&quot;bbb&quot;.getBytes());
                    buf.writeBytes(LINE);
                    ctx.writeAndFlush(buf);
                &#125;

                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                    ByteBuf buf = (ByteBuf) msg;
                    System.out.println(buf.toString(Charset.defaultCharset()));
                &#125;
            &#125;);
        &#125;
    &#125;);
    ChannelFuture channelFuture = bootstrap.connect(&quot;localhost&quot;, 6379).sync();
    channelFuture.channel().closeFuture().sync();
&#125; catch (InterruptedException e) &#123;
    log.error(&quot;client error&quot;, e);
&#125; finally &#123;
    worker.shutdownGracefully();
&#125;</code></pre>
<h3 id="http-协议举例"><a href="#http-协议举例" class="headerlink" title="http 协议举例"></a>http 协议举例</h3><pre><code class="java">NioEventLoopGroup boss = new NioEventLoopGroup();
NioEventLoopGroup worker = new NioEventLoopGroup();
try &#123;
    ServerBootstrap serverBootstrap = new ServerBootstrap();
    serverBootstrap.channel(NioServerSocketChannel.class);
    serverBootstrap.group(boss, worker);
    serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
        @Override
        protected void initChannel(SocketChannel ch) throws Exception &#123;
            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
            ch.pipeline().addLast(new HttpServerCodec());
            ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;
                @Override
                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception &#123;
                    // 获取请求
                    log.debug(msg.uri());

                    // 返回响应
                    DefaultFullHttpResponse response =
                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);

                    byte[] bytes = &quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;.getBytes();

                    response.headers().setInt(CONTENT_LENGTH, bytes.length);
                    response.content().writeBytes(bytes);

                    // 写回响应
                    ctx.writeAndFlush(response);
                &#125;
            &#125;);
            /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;
                @Override
                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());

                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头

                    &#125; else if (msg instanceof HttpContent) &#123; //请求体

                    &#125;
                &#125;
            &#125;);*/
        &#125;
    &#125;);
    ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();
    channelFuture.channel().closeFuture().sync();
&#125; catch (InterruptedException e) &#123;
    log.error(&quot;server error&quot;, e);
&#125; finally &#123;
    boss.shutdownGracefully();
    worker.shutdownGracefully();
&#125;</code></pre>
<h3 id="自定义协议要素"><a href="#自定义协议要素" class="headerlink" title="自定义协议要素"></a>自定义协议要素</h3><ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>
<pre><code class="java">@Slf4j
public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;

    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;
        // 1. 4 字节的魔数
        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
        // 2. 1 字节的版本,
        out.writeByte(1);
        // 3. 1 字节的序列化方式 jdk 0 , json 1
        out.writeByte(0);
        // 4. 1 字节的指令类型
        out.writeByte(msg.getMessageType());
        // 5. 4 个字节
        out.writeInt(msg.getSequenceId());
        // 无意义，对齐填充
        out.writeByte(0xff);
        // 6. 获取内容的字节数组
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(msg);
        byte[] bytes = bos.toByteArray();
        // 7. 长度
        out.writeInt(bytes.length);
        // 8. 写入内容
        out.writeBytes(bytes);
    &#125;

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        int magicNum = in.readInt();
        byte version = in.readByte();
        byte serializerType = in.readByte();
        byte messageType = in.readByte();
        int sequenceId = in.readInt();
        in.readByte();
        int length = in.readInt();
        byte[] bytes = new byte[length];
        in.readBytes(bytes, 0, length);
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        Message message = (Message) ois.readObject();
        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);
        log.debug(&quot;&#123;&#125;&quot;, message);
        out.add(message);
    &#125;
&#125;</code></pre>
<p>测试</p>
<pre><code class="java">EmbeddedChannel channel = new EmbeddedChannel(
    new LoggingHandler(),
    new LengthFieldBasedFrameDecoder(
        1024, 12, 4, 0, 0),
    new MessageCodec()
);
// encode
LoginRequestMessage message = new LoginRequestMessage(&quot;zhangsan&quot;, &quot;123&quot;, &quot;张三&quot;);
//        channel.writeOutbound(message);
// decode
ByteBuf buf = ByteBufAllocator.DEFAULT.buffer();
new MessageCodec().encode(null, message, buf);

ByteBuf s1 = buf.slice(0, 100);
ByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);
s1.retain(); // 引用计数 2
channel.writeInbound(s1); // release 1
channel.writeInbound(s2);</code></pre>
<p>解读</p>
<p><img src="images/0013.png"></p>
<h4 id="💡-什么时候可以加-Sharable"><a href="#💡-什么时候可以加-Sharable" class="headerlink" title="💡 什么时候可以加 @Sharable"></a>💡 什么时候可以加 @Sharable</h4><ul>
<li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li>
<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li>
<li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li>
</ul>
<pre><code class="java">@Slf4j
@ChannelHandler.Sharable
/**
 * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的
 */
public class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;
    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;
        ByteBuf out = ctx.alloc().buffer();
        // 1. 4 字节的魔数
        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
        // 2. 1 字节的版本,
        out.writeByte(1);
        // 3. 1 字节的序列化方式 jdk 0 , json 1
        out.writeByte(0);
        // 4. 1 字节的指令类型
        out.writeByte(msg.getMessageType());
        // 5. 4 个字节
        out.writeInt(msg.getSequenceId());
        // 无意义，对齐填充
        out.writeByte(0xff);
        // 6. 获取内容的字节数组
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(msg);
        byte[] bytes = bos.toByteArray();
        // 7. 长度
        out.writeInt(bytes.length);
        // 8. 写入内容
        out.writeBytes(bytes);
        outList.add(out);
    &#125;

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        int magicNum = in.readInt();
        byte version = in.readByte();
        byte serializerType = in.readByte();
        byte messageType = in.readByte();
        int sequenceId = in.readInt();
        in.readByte();
        int length = in.readInt();
        byte[] bytes = new byte[length];
        in.readBytes(bytes, 0, length);
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        Message message = (Message) ois.readObject();
        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);
        log.debug(&quot;&#123;&#125;&quot;, message);
        out.add(message);
    &#125;
&#125;</code></pre>
<h2 id="3-3-聊天室案例"><a href="#3-3-聊天室案例" class="headerlink" title="3.3 聊天室案例"></a>3.3 聊天室案例</h2><h3 id="聊天室业务介绍"><a href="#聊天室业务介绍" class="headerlink" title="聊天室业务介绍"></a>聊天室业务介绍</h3><pre><code class="java">/**
 * 用户管理接口
 */
public interface UserService &#123;

    /**
     * 登录
     * @param username 用户名
     * @param password 密码
     * @return 登录成功返回 true, 否则返回 false
     */
    boolean login(String username, String password);
&#125;</code></pre>
<pre><code class="java">/**
 * 会话管理接口
 */
public interface Session &#123;

    /**
     * 绑定会话
     * @param channel 哪个 channel 要绑定会话
     * @param username 会话绑定用户
     */
    void bind(Channel channel, String username);

    /**
     * 解绑会话
     * @param channel 哪个 channel 要解绑会话
     */
    void unbind(Channel channel);

    /**
     * 获取属性
     * @param channel 哪个 channel
     * @param name 属性名
     * @return 属性值
     */
    Object getAttribute(Channel channel, String name);

    /**
     * 设置属性
     * @param channel 哪个 channel
     * @param name 属性名
     * @param value 属性值
     */
    void setAttribute(Channel channel, String name, Object value);

    /**
     * 根据用户名获取 channel
     * @param username 用户名
     * @return channel
     */
    Channel getChannel(String username);
&#125;</code></pre>
<pre><code class="java">/**
 * 聊天组会话管理接口
 */
public interface GroupSession &#123;

    /**
     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null
     * @param name 组名
     * @param members 成员
     * @return 成功时返回组对象, 失败返回 null
     */
    Group createGroup(String name, Set&lt;String&gt; members);

    /**
     * 加入聊天组
     * @param name 组名
     * @param member 成员名
     * @return 如果组不存在返回 null, 否则返回组对象
     */
    Group joinMember(String name, String member);

    /**
     * 移除组成员
     * @param name 组名
     * @param member 成员名
     * @return 如果组不存在返回 null, 否则返回组对象
     */
    Group removeMember(String name, String member);

    /**
     * 移除聊天组
     * @param name 组名
     * @return 如果组不存在返回 null, 否则返回组对象
     */
    Group removeGroup(String name);

    /**
     * 获取组成员
     * @param name 组名
     * @return 成员集合, 没有成员会返回 empty set
     */
    Set&lt;String&gt; getMembers(String name);

    /**
     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回
     * @param name 组名
     * @return 成员 channel 集合
     */
    List&lt;Channel&gt; getMembersChannel(String name);
&#125;</code></pre>
<h3 id="聊天室业务-登录"><a href="#聊天室业务-登录" class="headerlink" title="聊天室业务-登录"></a>聊天室业务-登录</h3><pre><code class="java">@Slf4j
public class ChatServer &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup boss = new NioEventLoopGroup();
        NioEventLoopGroup worker = new NioEventLoopGroup();
        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);
        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();
        try &#123;
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProcotolFrameDecoder());
                    ch.pipeline().addLast(LOGGING_HANDLER);
                    ch.pipeline().addLast(MESSAGE_CODEC);
                    ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;LoginRequestMessage&gt;() &#123;
                        @Override
                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;
                            String username = msg.getUsername();
                            String password = msg.getPassword();
                            boolean login = UserServiceFactory.getUserService().login(username, password);
                            LoginResponseMessage message;
                            if(login) &#123;
                                message = new LoginResponseMessage(true, &quot;登录成功&quot;);
                            &#125; else &#123;
                                message = new LoginResponseMessage(false, &quot;用户名或密码不正确&quot;);
                            &#125;
                            ctx.writeAndFlush(message);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            Channel channel = serverBootstrap.bind(8080).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;server error&quot;, e);
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<pre><code class="java">@Slf4j
public class ChatClient &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup group = new NioEventLoopGroup();
        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);
        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();
        CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);
        AtomicBoolean LOGIN = new AtomicBoolean(false);
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(group);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProcotolFrameDecoder());
//                    ch.pipeline().addLast(LOGGING_HANDLER);
                    ch.pipeline().addLast(MESSAGE_CODEC);
                    ch.pipeline().addLast(&quot;client handler&quot;, new ChannelInboundHandlerAdapter() &#123;
                        // 接收响应消息
                        @Override
                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
                            log.debug(&quot;msg: &#123;&#125;&quot;, msg);
                            if ((msg instanceof LoginResponseMessage)) &#123;
                                LoginResponseMessage response = (LoginResponseMessage) msg;
                                if (response.isSuccess()) &#123;
                                    // 如果登录成功
                                    LOGIN.set(true);
                                &#125;
                                // 唤醒 system in 线程
                                WAIT_FOR_LOGIN.countDown();
                            &#125;
                        &#125;

                        // 在连接建立后触发 active 事件
                        @Override
                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
                            // 负责接收用户在控制台的输入，负责向服务器发送各种消息
                            new Thread(() -&gt; &#123;
                                Scanner scanner = new Scanner(System.in);
                                System.out.println(&quot;请输入用户名:&quot;);
                                String username = scanner.nextLine();
                                System.out.println(&quot;请输入密码:&quot;);
                                String password = scanner.nextLine();
                                // 构造消息对象
                                LoginRequestMessage message = new LoginRequestMessage(username, password);
                                // 发送消息
                                ctx.writeAndFlush(message);
                                System.out.println(&quot;等待后续操作...&quot;);
                                try &#123;
                                    WAIT_FOR_LOGIN.await();
                                &#125; catch (InterruptedException e) &#123;
                                    e.printStackTrace();
                                &#125;
                                // 如果登录失败
                                if (!LOGIN.get()) &#123;
                                    ctx.channel().close();
                                    return;
                                &#125;
                                while (true) &#123;
                                    System.out.println(&quot;==================================&quot;);
                                    System.out.println(&quot;send [username] [content]&quot;);
                                    System.out.println(&quot;gsend [group name] [content]&quot;);
                                    System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);
                                    System.out.println(&quot;gmembers [group name]&quot;);
                                    System.out.println(&quot;gjoin [group name]&quot;);
                                    System.out.println(&quot;gquit [group name]&quot;);
                                    System.out.println(&quot;quit&quot;);
                                    System.out.println(&quot;==================================&quot;);
                                    String command = scanner.nextLine();
                                    String[] s = command.split(&quot; &quot;);
                                    switch (s[0])&#123;
                                        case &quot;send&quot;:
                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));
                                            break;
                                        case &quot;gsend&quot;:
                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));
                                            break;
                                        case &quot;gcreate&quot;:
                                            Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList(s[2].split(&quot;,&quot;)));
                                            set.add(username); // 加入自己
                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));
                                            break;
                                        case &quot;gmembers&quot;:
                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));
                                            break;
                                        case &quot;gjoin&quot;:
                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));
                                            break;
                                        case &quot;gquit&quot;:
                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));
                                            break;
                                        case &quot;quit&quot;:
                                            ctx.channel().close();
                                            return;
                                    &#125;
                                &#125;
                            &#125;, &quot;system in&quot;).start();
                        &#125;
                    &#125;);
                &#125;
            &#125;);
            Channel channel = bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (Exception e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="聊天室业务-单聊"><a href="#聊天室业务-单聊" class="headerlink" title="聊天室业务-单聊"></a>聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p>
<p>登录 handler</p>
<pre><code class="java">@ChannelHandler.Sharable
public class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;
        String username = msg.getUsername();
        String password = msg.getPassword();
        boolean login = UserServiceFactory.getUserService().login(username, password);
        LoginResponseMessage message;
        if(login) &#123;
            SessionFactory.getSession().bind(ctx.channel(), username);
            message = new LoginResponseMessage(true, &quot;登录成功&quot;);
        &#125; else &#123;
            message = new LoginResponseMessage(false, &quot;用户名或密码不正确&quot;);
        &#125;
        ctx.writeAndFlush(message);
    &#125;
&#125;</code></pre>
<p>单聊 handler</p>
<pre><code class="java">@ChannelHandler.Sharable
public class ChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;ChatRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception &#123;
        String to = msg.getTo();
        Channel channel = SessionFactory.getSession().getChannel(to);
        // 在线
        if(channel != null) &#123;
            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));
        &#125;
        // 不在线
        else &#123;
            ctx.writeAndFlush(new ChatResponseMessage(false, &quot;对方用户不存在或者不在线&quot;));
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="聊天室业务-群聊"><a href="#聊天室业务-群聊" class="headerlink" title="聊天室业务-群聊"></a>聊天室业务-群聊</h3><p>创建群聊</p>
<pre><code class="java">@ChannelHandler.Sharable
public class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupCreateRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception &#123;
        String groupName = msg.getGroupName();
        Set&lt;String&gt; members = msg.getMembers();
        // 群管理器
        GroupSession groupSession = GroupSessionFactory.getGroupSession();
        Group group = groupSession.createGroup(groupName, members);
        if (group == null) &#123;
            // 发生成功消息
            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + &quot;创建成功&quot;));
            // 发送拉群消息
            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);
            for (Channel channel : channels) &#123;
                channel.writeAndFlush(new GroupCreateResponseMessage(true, &quot;您已被拉入&quot; + groupName));
            &#125;
        &#125; else &#123;
            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + &quot;已经存在&quot;));
        &#125;
    &#125;
&#125;</code></pre>
<p>群聊</p>
<pre><code class="java">@ChannelHandler.Sharable
public class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupChatRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception &#123;
        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()
                .getMembersChannel(msg.getGroupName());

        for (Channel channel : channels) &#123;
            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));
        &#125;
    &#125;
&#125;</code></pre>
<p>加入群聊</p>
<pre><code class="java">@ChannelHandler.Sharable
public class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupJoinRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception &#123;
        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());
        if (group != null) &#123;
            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群加入成功&quot;));
        &#125; else &#123;
            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群不存在&quot;));
        &#125;
    &#125;
&#125;</code></pre>
<p>退出群聊</p>
<pre><code class="java">@ChannelHandler.Sharable
public class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupQuitRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception &#123;
        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());
        if (group != null) &#123;
            ctx.writeAndFlush(new GroupJoinResponseMessage(true, &quot;已退出群&quot; + msg.getGroupName()));
        &#125; else &#123;
            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + &quot;群不存在&quot;));
        &#125;
    &#125;
&#125;</code></pre>
<p>查看成员</p>
<pre><code class="java">@ChannelHandler.Sharable
public class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler&lt;GroupMembersRequestMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception &#123;
        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()
                .getMembers(msg.getGroupName());
        ctx.writeAndFlush(new GroupMembersResponseMessage(members));
    &#125;
&#125;</code></pre>
<h3 id="聊天室业务-退出"><a href="#聊天室业务-退出" class="headerlink" title="聊天室业务-退出"></a>聊天室业务-退出</h3><pre><code>@Slf4j
@ChannelHandler.Sharable
public class QuitHandler extends ChannelInboundHandlerAdapter &#123;

    // 当连接断开时触发 inactive 事件
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
        SessionFactory.getSession().unbind(ctx.channel());
        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());
    &#125;

    // 当出现异常时触发
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        SessionFactory.getSession().unbind(ctx.channel());
        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());
    &#125;
&#125;</code></pre>
<h3 id="聊天室业务-空闲检测"><a href="#聊天室业务-空闲检测" class="headerlink" title="聊天室业务-空闲检测"></a>聊天室业务-空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>原因</p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p>问题</p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p>服务器端解决</p>
<ul>
<li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>
</ul>
<pre><code class="java">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长
// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件
ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));
// ChannelDuplexHandler 可以同时作为入站和出站处理器
ch.pipeline().addLast(new ChannelDuplexHandler() &#123;
    // 用来触发特殊事件
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;
        IdleStateEvent event = (IdleStateEvent) evt;
        // 触发了读空闲事件
        if (event.state() == IdleState.READER_IDLE) &#123;
            log.debug(&quot;已经 5s 没有读到数据了&quot;);
            ctx.channel().close();
        &#125;
    &#125;
&#125;);</code></pre>
<p>客户端定时心跳</p>
<ul>
<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>
</ul>
<pre><code class="java">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长
// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件
ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));
// ChannelDuplexHandler 可以同时作为入站和出站处理器
ch.pipeline().addLast(new ChannelDuplexHandler() &#123;
    // 用来触发特殊事件
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception&#123;
        IdleStateEvent event = (IdleStateEvent) evt;
        // 触发了写空闲事件
        if (event.state() == IdleState.WRITER_IDLE) &#123;
            //                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);
            ctx.writeAndFlush(new PingMessage());
        &#125;
    &#125;
&#125;);</code></pre>
<h1 id="4-优化与源码"><a href="#4-优化与源码" class="headerlink" title="4 优化与源码"></a>4 优化与源码</h1><h2 id="4-1-优化"><a href="#4-1-优化" class="headerlink" title="4.1 优化"></a>4.1 优化</h2><h3 id="扩展序列化算法"><a href="#扩展序列化算法" class="headerlink" title="扩展序列化算法"></a>扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>
<pre><code class="java">// 反序列化
byte[] body = new byte[bodyLength];
byteByf.readBytes(body);
ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body));
Message message = (Message) in.readObject();
message.setSequenceId(sequenceId);

// 序列化
ByteArrayOutputStream out = new ByteArrayOutputStream();
new ObjectOutputStream(out).writeObject(message);
byte[] bytes = out.toByteArray();</code></pre>
<p>为了支持更多序列化算法，抽象一个 Serializer 接口</p>
<pre><code class="java">public interface Serializer &#123;

    // 反序列化方法
    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);

    // 序列化方法
    &lt;T&gt; byte[] serialize(T object);

&#125;</code></pre>
<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>
<pre><code class="java">enum SerializerAlgorithm implements Serializer &#123;
    // Java 实现
    Java &#123;
        @Override
        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;
            try &#123;
                ObjectInputStream in = 
                    new ObjectInputStream(new ByteArrayInputStream(bytes));
                Object object = in.readObject();
                return (T) object;
            &#125; catch (IOException | ClassNotFoundException e) &#123;
                throw new RuntimeException(&quot;SerializerAlgorithm.Java 反序列化错误&quot;, e);
            &#125;
        &#125;

        @Override
        public &lt;T&gt; byte[] serialize(T object) &#123;
            try &#123;
                ByteArrayOutputStream out = new ByteArrayOutputStream();
                new ObjectOutputStream(out).writeObject(object);
                return out.toByteArray();
            &#125; catch (IOException e) &#123;
                throw new RuntimeException(&quot;SerializerAlgorithm.Java 序列化错误&quot;, e);
            &#125;
        &#125;
    &#125;, 
    // Json 实现(引入了 Gson 依赖)
    Json &#123;
        @Override
        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;
            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);
        &#125;

        @Override
        public &lt;T&gt; byte[] serialize(T object) &#123;
            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);
        &#125;
    &#125;;

    // 需要从协议的字节中得到是哪种序列化算法
    public static SerializerAlgorithm getByInt(int type) &#123;
        SerializerAlgorithm[] array = SerializerAlgorithm.values();
        if (type &lt; 0 || type &gt; array.length - 1) &#123;
            throw new IllegalArgumentException(&quot;超过 SerializerAlgorithm 范围&quot;);
        &#125;
        return array[type];
    &#125;
&#125;</code></pre>
<p>增加配置类和配置文件</p>
<pre><code class="java">public abstract class Config &#123;
    static Properties properties;
    static &#123;
        try (InputStream in = Config.class.getResourceAsStream(&quot;/application.properties&quot;)) &#123;
            properties = new Properties();
            properties.load(in);
        &#125; catch (IOException e) &#123;
            throw new ExceptionInInitializerError(e);
        &#125;
    &#125;
    public static int getServerPort() &#123;
        String value = properties.getProperty(&quot;server.port&quot;);
        if(value == null) &#123;
            return 8080;
        &#125; else &#123;
            return Integer.parseInt(value);
        &#125;
    &#125;
    public static Serializer.Algorithm getSerializerAlgorithm() &#123;
        String value = properties.getProperty(&quot;serializer.algorithm&quot;);
        if(value == null) &#123;
            return Serializer.Algorithm.Java;
        &#125; else &#123;
            return Serializer.Algorithm.valueOf(value);
        &#125;
    &#125;
&#125;</code></pre>
<p>配置文件</p>
<pre><code class="properties">serializer.algorithm=Json</code></pre>
<p>修改编解码器</p>
<pre><code class="java">/**
 * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的
 */
public class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;
    @Override
    public void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;
        ByteBuf out = ctx.alloc().buffer();
        // 1. 4 字节的魔数
        out.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);
        // 2. 1 字节的版本,
        out.writeByte(1);
        // 3. 1 字节的序列化方式 jdk 0 , json 1
        out.writeByte(Config.getSerializerAlgorithm().ordinal());
        // 4. 1 字节的指令类型
        out.writeByte(msg.getMessageType());
        // 5. 4 个字节
        out.writeInt(msg.getSequenceId());
        // 无意义，对齐填充
        out.writeByte(0xff);
        // 6. 获取内容的字节数组
        byte[] bytes = Config.getSerializerAlgorithm().serialize(msg);
        // 7. 长度
        out.writeInt(bytes.length);
        // 8. 写入内容
        out.writeBytes(bytes);
        outList.add(out);
    &#125;

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;
        int magicNum = in.readInt();
        byte version = in.readByte();
        byte serializerAlgorithm = in.readByte(); // 0 或 1
        byte messageType = in.readByte(); // 0,1,2...
        int sequenceId = in.readInt();
        in.readByte();
        int length = in.readInt();
        byte[] bytes = new byte[length];
        in.readBytes(bytes, 0, length);

        // 找到反序列化算法
        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];
        // 确定具体消息类型
        Class&lt;? extends Message&gt; messageClass = Message.getMessageClass(messageType);
        Message message = algorithm.deserialize(messageClass, bytes);
//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);
//        log.debug(&quot;&#123;&#125;&quot;, message);
        out.add(message);
    &#125;
&#125;</code></pre>
<p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p>
<pre><code class="java">@Data
public abstract class Message implements Serializable &#123;

    /**
     * 根据消息类型字节，获得对应的消息 class
     * @param messageType 消息类型字节
     * @return 消息 class
     */
    public static Class&lt;? extends Message&gt; getMessageClass(int messageType) &#123;
        return messageClasses.get(messageType);
    &#125;

    private int sequenceId;

    private int messageType;

    public abstract int getMessageType();

    public static final int LoginRequestMessage = 0;
    public static final int LoginResponseMessage = 1;
    public static final int ChatRequestMessage = 2;
    public static final int ChatResponseMessage = 3;
    public static final int GroupCreateRequestMessage = 4;
    public static final int GroupCreateResponseMessage = 5;
    public static final int GroupJoinRequestMessage = 6;
    public static final int GroupJoinResponseMessage = 7;
    public static final int GroupQuitRequestMessage = 8;
    public static final int GroupQuitResponseMessage = 9;
    public static final int GroupChatRequestMessage = 10;
    public static final int GroupChatResponseMessage = 11;
    public static final int GroupMembersRequestMessage = 12;
    public static final int GroupMembersResponseMessage = 13;
    public static final int PingMessage = 14;
    public static final int PongMessage = 15;
    private static final Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses = new HashMap&lt;&gt;();

    static &#123;
        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);
        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);
        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);
        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);
        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);
        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);
        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);
        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);
        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);
        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);
        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);
        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);
        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);
        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);
    &#125;
&#125;</code></pre>
<h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h4 id="1）CONNECT-TIMEOUT-MILLIS"><a href="#1）CONNECT-TIMEOUT-MILLIS" class="headerlink" title="1）CONNECT_TIMEOUT_MILLIS"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul>
<li><p>属于 SocketChannal 参数</p>
</li>
<li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>
</li>
<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p>
</li>
</ul>
<pre><code class="java">@Slf4j
public class TestConnectionTimeout &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup group = new NioEventLoopGroup();
        try &#123;
            Bootstrap bootstrap = new Bootstrap()
                    .group(group)
                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)
                    .channel(NioSocketChannel.class)
                    .handler(new LoggingHandler());
            ChannelFuture future = bootstrap.connect(&quot;127.0.0.1&quot;, 8080);
            future.sync().channel().closeFuture().sync(); // 断点1
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            log.debug(&quot;timeout&quot;);
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>
<pre><code class="java">@Override
public final void connect(
        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;
    // ...
    // Schedule connect timeout.
    int connectTimeoutMillis = config().getConnectTimeoutMillis();
    if (connectTimeoutMillis &gt; 0) &#123;
        connectTimeoutFuture = eventLoop().schedule(new Runnable() &#123;
            @Override
            public void run() &#123;                
                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;
                ConnectTimeoutException cause =
                    new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress); // 断点2
                if (connectPromise != null &amp;&amp; connectPromise.tryFailure(cause)) &#123;
                    close(voidPromise());
                &#125;
            &#125;
        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);
    &#125;
    // ...
&#125;</code></pre>
<h4 id="2）SO-BACKLOG"><a href="#2）SO-BACKLOG" class="headerlink" title="2）SO_BACKLOG"></a>2）SO_BACKLOG</h4><ul>
<li>属于 ServerSocketChannal 参数</li>
</ul>
<pre><code class="mermaid">sequenceDiagram

participant c as client
participant s as server
participant sq as syns queue
participant aq as accept queue

s -&gt;&gt; s : bind()
s -&gt;&gt; s : listen()
c -&gt;&gt; c : connect()
c -&gt;&gt; s : 1. SYN
Note left of c : SYN_SEND
s -&gt;&gt; sq : put
Note right of s : SYN_RCVD
s -&gt;&gt; c : 2. SYN + ACK
Note left of c : ESTABLISHED
c -&gt;&gt; s : 3. ACK
sq -&gt;&gt; aq : put
Note right of s : ESTABLISHED
aq --&gt;&gt; s : 
s -&gt;&gt; s : accept()</code></pre>
<ol>
<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>
<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>
<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>
</ol>
<p>其中</p>
<ul>
<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>
</li>
<li><p>sync queue - 半连接队列</p>
<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li><p>accept queue - 全连接队列</p>
<ul>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
</ul>
</li>
</ul>
<p>netty 中</p>
<p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p>
<p>可以通过下面源码查看默认大小</p>
<pre><code class="java">public class DefaultServerSocketChannelConfig extends DefaultChannelConfig
                                              implements ServerSocketChannelConfig &#123;

    private volatile int backlog = NetUtil.SOMAXCONN;
    // ...
&#125;</code></pre>
<p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<p>oio 中更容易说明，不用 debug 模式</p>
<pre><code class="java">public class Server &#123;
    public static void main(String[] args) throws IOException &#123;
        ServerSocket ss = new ServerSocket(8888, 2);
        Socket accept = ss.accept();
        System.out.println(accept);
        System.in.read();
    &#125;
&#125;</code></pre>
<p>客户端启动 4 个</p>
<pre><code class="java">public class Client &#123;
    public static void main(String[] args) throws IOException &#123;
        try &#123;
            Socket s = new Socket();
            System.out.println(new Date()+&quot; connecting...&quot;);
            s.connect(new InetSocketAddress(&quot;localhost&quot;, 8888),1000);
            System.out.println(new Date()+&quot; connected...&quot;);
            s.getOutputStream().write(1);
            System.in.read();
        &#125; catch (IOException e) &#123;
            System.out.println(new Date()+&quot; connecting timeout...&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p>
<pre><code class="java">Tue Apr 21 20:30:28 CST 2020 connecting...
Tue Apr 21 20:30:28 CST 2020 connected...</code></pre>
<p>第 4 个客户端连接时</p>
<pre><code>Tue Apr 21 20:53:58 CST 2020 connecting...
Tue Apr 21 20:53:59 CST 2020 connecting timeout...
java.net.SocketTimeoutException: connect timed out</code></pre>
<h4 id="3）ulimit-n"><a href="#3）ulimit-n" class="headerlink" title="3）ulimit -n"></a>3）ulimit -n</h4><ul>
<li>属于操作系统参数</li>
</ul>
<h4 id="4）TCP-NODELAY"><a href="#4）TCP-NODELAY" class="headerlink" title="4）TCP_NODELAY"></a>4）TCP_NODELAY</h4><ul>
<li>属于 SocketChannal 参数</li>
</ul>
<h4 id="5）SO-SNDBUF-amp-SO-RCVBUF"><a href="#5）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="5）SO_SNDBUF &amp; SO_RCVBUF"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul>
<li>SO_SNDBUF 属于 SocketChannal 参数</li>
<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li>
</ul>
<h4 id="6）ALLOCATOR"><a href="#6）ALLOCATOR" class="headerlink" title="6）ALLOCATOR"></a>6）ALLOCATOR</h4><ul>
<li>属于 SocketChannal 参数</li>
<li>用来分配 ByteBuf， ctx.alloc()</li>
</ul>
<h4 id="7）RCVBUF-ALLOCATOR"><a href="#7）RCVBUF-ALLOCATOR" class="headerlink" title="7）RCVBUF_ALLOCATOR"></a>7）RCVBUF_ALLOCATOR</h4><ul>
<li>属于 SocketChannal 参数</li>
<li>控制 netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<h3 id="RPC-框架"><a href="#RPC-框架" class="headerlink" title="RPC 框架"></a>RPC 框架</h3><h4 id="1）准备工作"><a href="#1）准备工作" class="headerlink" title="1）准备工作"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p>
<p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>
<pre><code class="java">@Data
public abstract class Message implements Serializable &#123;

    // 省略旧的代码

    public static final int RPC_MESSAGE_TYPE_REQUEST = 101;
    public static final int  RPC_MESSAGE_TYPE_RESPONSE = 102;

    static &#123;
        // ...
        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);
        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);
    &#125;

&#125;</code></pre>
<p>请求消息</p>
<pre><code class="java">@Getter
@ToString(callSuper = true)
public class RpcRequestMessage extends Message &#123;

    /**
     * 调用的接口全限定名，服务端根据它找到实现
     */
    private String interfaceName;
    /**
     * 调用接口中的方法名
     */
    private String methodName;
    /**
     * 方法返回类型
     */
    private Class&lt;?&gt; returnType;
    /**
     * 方法参数类型数组
     */
    private Class[] parameterTypes;
    /**
     * 方法参数值数组
     */
    private Object[] parameterValue;

    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;
        super.setSequenceId(sequenceId);
        this.interfaceName = interfaceName;
        this.methodName = methodName;
        this.returnType = returnType;
        this.parameterTypes = parameterTypes;
        this.parameterValue = parameterValue;
    &#125;

    @Override
    public int getMessageType() &#123;
        return RPC_MESSAGE_TYPE_REQUEST;
    &#125;
&#125;</code></pre>
<p>响应消息</p>
<pre><code class="java">@Data
@ToString(callSuper = true)
public class RpcResponseMessage extends Message &#123;
    /**
     * 返回值
     */
    private Object returnValue;
    /**
     * 异常值
     */
    private Exception exceptionValue;

    @Override
    public int getMessageType() &#123;
        return RPC_MESSAGE_TYPE_RESPONSE;
    &#125;
&#125;</code></pre>
<p>服务器架子</p>
<pre><code class="java">@Slf4j
public class RpcServer &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup boss = new NioEventLoopGroup();
        NioEventLoopGroup worker = new NioEventLoopGroup();
        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);
        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();

        // rpc 请求消息处理器，待实现
        RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler();
        try &#123;
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.channel(NioServerSocketChannel.class);
            serverBootstrap.group(boss, worker);
            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProcotolFrameDecoder());
                    ch.pipeline().addLast(LOGGING_HANDLER);
                    ch.pipeline().addLast(MESSAGE_CODEC);
                    ch.pipeline().addLast(RPC_HANDLER);
                &#125;
            &#125;);
            Channel channel = serverBootstrap.bind(8080).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            log.error(&quot;server error&quot;, e);
        &#125; finally &#123;
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>客户端架子</p>
<pre><code class="java">public class RpcClient &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup group = new NioEventLoopGroup();
        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);
        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();

        // rpc 响应消息处理器，待实现
        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(group);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProcotolFrameDecoder());
                    ch.pipeline().addLast(LOGGING_HANDLER);
                    ch.pipeline().addLast(MESSAGE_CODEC);
                    ch.pipeline().addLast(RPC_HANDLER);
                &#125;
            &#125;);
            Channel channel = bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();
            channel.closeFuture().sync();
        &#125; catch (Exception e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<p>服务器端的 service 获取</p>
<pre><code class="java">public class ServicesFactory &#123;

    static Properties properties;
    static Map&lt;Class&lt;?&gt;, Object&gt; map = new ConcurrentHashMap&lt;&gt;();

    static &#123;
        try (InputStream in = Config.class.getResourceAsStream(&quot;/application.properties&quot;)) &#123;
            properties = new Properties();
            properties.load(in);
            Set&lt;String&gt; names = properties.stringPropertyNames();
            for (String name : names) &#123;
                if (name.endsWith(&quot;Service&quot;)) &#123;
                    Class&lt;?&gt; interfaceClass = Class.forName(name);
                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));
                    map.put(interfaceClass, instanceClass.newInstance());
                &#125;
            &#125;
        &#125; catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;
            throw new ExceptionInInitializerError(e);
        &#125;
    &#125;

    public static &lt;T&gt; T getService(Class&lt;T&gt; interfaceClass) &#123;
        return (T) map.get(interfaceClass);
    &#125;
&#125;</code></pre>
<p>相关配置 application.properties</p>
<pre><code>serializer.algorithm=Json
cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</code></pre>
<h4 id="2）服务器-handler"><a href="#2）服务器-handler" class="headerlink" title="2）服务器 handler"></a>2）服务器 handler</h4><pre><code class="java">@Slf4j
@ChannelHandler.Sharable
public class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) &#123;
        RpcResponseMessage response = new RpcResponseMessage();
        response.setSequenceId(message.getSequenceId());
        try &#123;
            // 获取真正的实现对象
            HelloService service = (HelloService)
                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));

            // 获取要调用的方法
            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());

            // 调用方法
            Object invoke = method.invoke(service, message.getParameterValue());
            // 调用成功
            response.setReturnValue(invoke);
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            // 调用异常
            response.setExceptionValue(e);
        &#125;
        // 返回结果
        ctx.writeAndFlush(response);
    &#125;
&#125;</code></pre>
<h4 id="3）客户端代码第一版"><a href="#3）客户端代码第一版" class="headerlink" title="3）客户端代码第一版"></a>3）客户端代码第一版</h4><p>只发消息</p>
<pre><code class="java">@Slf4j
public class RpcClient &#123;
    public static void main(String[] args) &#123;
        NioEventLoopGroup group = new NioEventLoopGroup();
        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);
        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();
        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();
        try &#123;
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.group(group);
            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                @Override
                protected void initChannel(SocketChannel ch) throws Exception &#123;
                    ch.pipeline().addLast(new ProcotolFrameDecoder());
                    ch.pipeline().addLast(LOGGING_HANDLER);
                    ch.pipeline().addLast(MESSAGE_CODEC);
                    ch.pipeline().addLast(RPC_HANDLER);
                &#125;
            &#125;);
            Channel channel = bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();

            ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage(
                    1,
                    &quot;cn.itcast.server.service.HelloService&quot;,
                    &quot;sayHello&quot;,
                    String.class,
                    new Class[]&#123;String.class&#125;,
                    new Object[]&#123;&quot;张三&quot;&#125;
            )).addListener(promise -&gt; &#123;
                if (!promise.isSuccess()) &#123;
                    Throwable cause = promise.cause();
                    log.error(&quot;error&quot;, cause);
                &#125;
            &#125;);

            channel.closeFuture().sync();
        &#125; catch (Exception e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="4）客户端-handler-第一版"><a href="#4）客户端-handler-第一版" class="headerlink" title="4）客户端 handler 第一版"></a>4）客户端 handler 第一版</h4><pre><code class="java">@Slf4j
@ChannelHandler.Sharable
public class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;
        log.debug(&quot;&#123;&#125;&quot;, msg);
    &#125;
&#125;</code></pre>
<h4 id="5）客户端代码-第二版"><a href="#5）客户端代码-第二版" class="headerlink" title="5）客户端代码 第二版"></a>5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p>
<pre><code class="java">@Slf4j
public class RpcClientManager &#123;


    public static void main(String[] args) &#123;
        HelloService service = getProxyService(HelloService.class);
        System.out.println(service.sayHello(&quot;zhangsan&quot;));
//        System.out.println(service.sayHello(&quot;lisi&quot;));
//        System.out.println(service.sayHello(&quot;wangwu&quot;));
    &#125;

    // 创建代理类
    public static &lt;T&gt; T getProxyService(Class&lt;T&gt; serviceClass) &#123;
        ClassLoader loader = serviceClass.getClassLoader();
        Class&lt;?&gt;[] interfaces = new Class[]&#123;serviceClass&#125;;
        //                                                            sayHello  &quot;张三&quot;
        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;
            // 1. 将方法调用转换为 消息对象
            int sequenceId = SequenceIdGenerator.nextId();
            RpcRequestMessage msg = new RpcRequestMessage(
                    sequenceId,
                    serviceClass.getName(),
                    method.getName(),
                    method.getReturnType(),
                    method.getParameterTypes(),
                    args
            );
            // 2. 将消息对象发送出去
            getChannel().writeAndFlush(msg);

            // 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程
            DefaultPromise&lt;Object&gt; promise = new DefaultPromise&lt;&gt;(getChannel().eventLoop());
            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);

//            promise.addListener(future -&gt; &#123;
//                // 线程
//            &#125;);

            // 4. 等待 promise 结果
            promise.await();
            if(promise.isSuccess()) &#123;
                // 调用正常
                return promise.getNow();
            &#125; else &#123;
                // 调用失败
                throw new RuntimeException(promise.cause());
            &#125;
        &#125;);
        return (T) o;
    &#125;

    private static Channel channel = null;
    private static final Object LOCK = new Object();

    // 获取唯一的 channel 对象
    public static Channel getChannel() &#123;
        if (channel != null) &#123;
            return channel;
        &#125;
        synchronized (LOCK) &#123; //  t2
            if (channel != null) &#123; // t1
                return channel;
            &#125;
            initChannel();
            return channel;
        &#125;
    &#125;

    // 初始化 channel 方法
    private static void initChannel() &#123;
        NioEventLoopGroup group = new NioEventLoopGroup();
        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);
        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();
        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.channel(NioSocketChannel.class);
        bootstrap.group(group);
        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
            @Override
            protected void initChannel(SocketChannel ch) throws Exception &#123;
                ch.pipeline().addLast(new ProcotolFrameDecoder());
                ch.pipeline().addLast(LOGGING_HANDLER);
                ch.pipeline().addLast(MESSAGE_CODEC);
                ch.pipeline().addLast(RPC_HANDLER);
            &#125;
        &#125;);
        try &#123;
            channel = bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();
            channel.closeFuture().addListener(future -&gt; &#123;
                group.shutdownGracefully();
            &#125;);
        &#125; catch (Exception e) &#123;
            log.error(&quot;client error&quot;, e);
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="6）客户端-handler-第二版"><a href="#6）客户端-handler-第二版" class="headerlink" title="6）客户端 handler 第二版"></a>6）客户端 handler 第二版</h4><pre><code class="java">@Slf4j
@ChannelHandler.Sharable
public class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;

    //                       序号      用来接收结果的 promise 对象
    public static final Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = new ConcurrentHashMap&lt;&gt;();

    @Override

    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;
        log.debug(&quot;&#123;&#125;&quot;, msg);
        // 拿到空的 promise
        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());
        if (promise != null) &#123;
            Object returnValue = msg.getReturnValue();
            Exception exceptionValue = msg.getExceptionValue();
            if(exceptionValue != null) &#123;
                promise.setFailure(exceptionValue);
            &#125; else &#123;
                promise.setSuccess(returnValue);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2 源码分析"></a>4.2 源码分析</h2><h3 id="启动剖析"><a href="#启动剖析" class="headerlink" title="启动剖析"></a>启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>
<pre><code class="java">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector
Selector selector = Selector.open(); 

//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config
NioServerSocketChannel attachment = new NioServerSocketChannel();

//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); 
serverSocketChannel.configureBlocking(false);

//4 启动 nio boss 线程执行接下来的操作

//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件
SelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);

//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor

//7 绑定端口
serverSocketChannel.bind(new InetSocketAddress(8080));

//8 触发 channel active 事件，在 head 中关注 op_accept 事件
selectionKey.interestOps(SelectionKey.OP_ACCEPT);</code></pre>
<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>
<pre><code class="java">private ChannelFuture doBind(final SocketAddress localAddress) &#123;
    // 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) &#123;
        return regFuture;
    &#125;

    // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分
    // 2.1 如果已经完成
    if (regFuture.isDone()) &#123;
        ChannelPromise promise = channel.newPromise();
        // 3.1 立刻调用 doBind0
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    &#125; 
    // 2.2 还没有完成
    else &#123;
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        // 3.2 回调 doBind0
        regFuture.addListener(new ChannelFutureListener() &#123;
            @Override
            public void operationComplete(ChannelFuture future) throws Exception &#123;
                Throwable cause = future.cause();
                if (cause != null) &#123;
                    // 处理异常...
                    promise.setFailure(cause);
                &#125; else &#123;
                    promise.registered();
                    // 3. 由注册线程去执行 doBind0
                    doBind0(regFuture, channel, localAddress, promise);
                &#125;
            &#125;
        &#125;);
        return promise;
    &#125;
&#125;</code></pre>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>
<pre><code class="java">final ChannelFuture initAndRegister() &#123;
    Channel channel = null;
    try &#123;
        channel = channelFactory.newChannel();
        // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer
        init(channel);
    &#125; catch (Throwable t) &#123;
        // 处理异常...
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    &#125;

    // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) &#123;
        // 处理异常...
    &#125;
    return regFuture;
&#125;</code></pre>
<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>
<pre><code class="java">// 这里 channel 实际上是 NioServerSocketChannel
void init(Channel channel) throws Exception &#123;
    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();
    synchronized (options) &#123;
        setChannelOptions(channel, options, logger);
    &#125;

    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();
    synchronized (attrs) &#123;
        for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();
            channel.attr(key).set(e.getValue());
        &#125;
    &#125;

    ChannelPipeline p = channel.pipeline();

    final EventLoopGroup currentChildGroup = childGroup;
    final ChannelHandler currentChildHandler = childHandler;
    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;
    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;
    synchronized (childOptions) &#123;
        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));
    &#125;
    synchronized (childAttrs) &#123;
        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));
    &#125;

    // 为 NioServerSocketChannel 添加初始化器
    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;
        @Override
        public void initChannel(final Channel ch) throws Exception &#123;
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) &#123;
                pipeline.addLast(handler);
            &#125;

            // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel
            ch.eventLoop().execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                &#125;
            &#125;);
        &#125;
    &#125;);
&#125;</code></pre>
<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>
<pre><code class="java">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;
    // 一些检查，略...

    AbstractChannel.this.eventLoop = eventLoop;

    if (eventLoop.inEventLoop()) &#123;
        register0(promise);
    &#125; else &#123;
        try &#123;
            // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行
            // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程
            // 这行代码完成的事实是 main -&gt; nio boss 线程的切换
            eventLoop.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    register0(promise);
                &#125;
            &#125;);
        &#125; catch (Throwable t) &#123;
            // 日志记录...
            closeForcibly();
            closeFuture.setClosed();
            safeSetFailure(promise, t);
        &#125;
    &#125;
&#125;</code></pre>
<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<pre><code class="java">private void register0(ChannelPromise promise) &#123;
    try &#123;
        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;
            return;
        &#125;
        boolean firstRegistration = neverRegistered;
        // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel
        doRegister();
        neverRegistered = false;
        registered = true;

        // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel
        pipeline.invokeHandlerAddedIfNeeded();

        // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0
        safeSetSuccess(promise);
        pipeline.fireChannelRegistered();

        // 对应 server socket channel 还未绑定，isActive 为 false
        if (isActive()) &#123;
            if (firstRegistration) &#123;
                pipeline.fireChannelActive();
            &#125; else if (config().isAutoRead()) &#123;
                beginRead();
            &#125;
        &#125;
    &#125; catch (Throwable t) &#123;
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    &#125;
&#125;</code></pre>
<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>
<pre><code class="java">private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;
    if (initMap.add(ctx)) &#123; // Guard against re-entrance.
        try &#123;
            // 1.2.2.1 执行初始化
            initChannel((C) ctx.channel());
        &#125; catch (Throwable cause) &#123;
            exceptionCaught(ctx, cause);
        &#125; finally &#123;
            // 1.2.2.2 移除初始化器
            ChannelPipeline pipeline = ctx.pipeline();
            if (pipeline.context(this) != null) &#123;
                pipeline.remove(this);
            &#125;
        &#125;
        return true;
    &#125;
    return false;
&#125;</code></pre>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>
<pre><code class="java">// 3.1 或 3.2 执行 doBind0
private static void doBind0(
        final ChannelFuture regFuture, final Channel channel,
        final SocketAddress localAddress, final ChannelPromise promise) &#123;

    channel.eventLoop().execute(new Runnable() &#123;
        @Override
        public void run() &#123;
            if (regFuture.isSuccess()) &#123;
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            &#125; else &#123;
                promise.setFailure(regFuture.cause());
            &#125;
        &#125;
    &#125;);
&#125;</code></pre>
<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>
<pre><code class="java">public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;
    assertEventLoop();

    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;
        return;
    &#125;

    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;
        localAddress instanceof InetSocketAddress &amp;&amp;
        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;
        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;
        // 记录日志...
    &#125;

    boolean wasActive = isActive();
    try &#123;
        // 3.3 执行端口绑定
        doBind(localAddress);
    &#125; catch (Throwable t) &#123;
        safeSetFailure(promise, t);
        closeIfClosed();
        return;
    &#125;

    if (!wasActive &amp;&amp; isActive()) &#123;
        invokeLater(new Runnable() &#123;
            @Override
            public void run() &#123;
                // 3.4 触发 active 事件
                pipeline.fireChannelActive();
            &#125;
        &#125;);
    &#125;

    safeSetSuccess(promise);
&#125;</code></pre>
<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>
<pre><code class="java">protected void doBind(SocketAddress localAddress) throws Exception &#123;
    if (PlatformDependent.javaVersion() &gt;= 7) &#123;
        javaChannel().bind(localAddress, config.getBacklog());
    &#125; else &#123;
        javaChannel().socket().bind(localAddress, config.getBacklog());
    &#125;
&#125;</code></pre>
<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>
<pre><code class="java">public void channelActive(ChannelHandlerContext ctx) &#123;
    ctx.fireChannelActive();
    // 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)
    readIfIsAutoRead();
&#125;</code></pre>
<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>
<pre><code class="java">protected void doBeginRead() throws Exception &#123;
    // Channel.read() or ChannelHandlerContext.read() was called
    final SelectionKey selectionKey = this.selectionKey;
    if (!selectionKey.isValid()) &#123;
        return;
    &#125;

    readPending = true;

    final int interestOps = selectionKey.interestOps();
    // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件
    if ((interestOps &amp; readInterestOp) == 0) &#123;
        selectionKey.interestOps(interestOps | readInterestOp);
    &#125;
&#125;</code></pre>
<h3 id="NioEventLoop-剖析"><a href="#NioEventLoop-剖析" class="headerlink" title="NioEventLoop 剖析"></a>NioEventLoop 剖析</h3><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>
<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>
<pre><code class="java">public void execute(Runnable task) &#123;
    if (task == null) &#123;
        throw new NullPointerException(&quot;task&quot;);
    &#125;

    boolean inEventLoop = inEventLoop();
    // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列
    addTask(task);
    if (!inEventLoop) &#123;
        // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread
        startThread();
        if (isShutdown()) &#123;
            // 如果已经 shutdown，做拒绝逻辑，代码略...
        &#125;
    &#125;

    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;
        // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程
        wakeup(inEventLoop);
    &#125;
&#125;</code></pre>
<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>
<pre><code class="java">@Override
protected void wakeup(boolean inEventLoop) &#123;
    if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;
        selector.wakeup();
    &#125;
&#125;</code></pre>
<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>
<pre><code class="java">private void doStartThread() &#123;
    assert thread == null;
    executor.execute(new Runnable() &#123;
        @Override
        public void run() &#123;
            // 将线程池的当前线程保存在成员变量中，以便后续使用
            thread = Thread.currentThread();
            if (interrupted) &#123;
                thread.interrupt();
            &#125;

            boolean success = false;
            updateLastExecutionTime();
            try &#123;
                // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下
                SingleThreadEventExecutor.this.run();
                success = true;
            &#125; catch (Throwable t) &#123;
                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);
            &#125; finally &#123;
                // 清理工作，代码略...
            &#125;
        &#125;
    &#125;);
&#125;</code></pre>
<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>
<pre><code class="java">protected void run() &#123;
    for (;;) &#123;
        try &#123;
            try &#123;
                // calculateStrategy 的逻辑如下：
                // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch
                // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞
                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;
                    case SelectStrategy.CONTINUE:
                        continue;

                    case SelectStrategy.BUSY_WAIT:

                    case SelectStrategy.SELECT:
                        // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒
                        // 进行 select 阻塞，并设置唤醒状态为 false
                        boolean oldWakenUp = wakenUp.getAndSet(false);

                        // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup
                        // 下面的 select 方法不会阻塞
                        // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?
                        // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时
                        // 才能执行，让 select 方法无谓阻塞
                        select(oldWakenUp);

                        if (wakenUp.get()) &#123;
                            selector.wakeup();
                        &#125;
                    default:
                &#125;
            &#125; catch (IOException e) &#123;
                rebuildSelector0();
                handleLoopException(e);
                continue;
            &#125;

            cancelledKeys = 0;
            needsToSelectAgain = false;
            // ioRatio 默认是 50
            final int ioRatio = this.ioRatio;
            if (ioRatio == 100) &#123;
                try &#123;
                    processSelectedKeys();
                &#125; finally &#123;
                    // ioRatio 为 100 时，总是运行完所有非 IO 任务
                    runAllTasks();
                &#125;
            &#125; else &#123;                
                final long ioStartTime = System.nanoTime();
                try &#123;
                    processSelectedKeys();
                &#125; finally &#123;
                    // 记录 io 事件处理耗时
                    final long ioTime = System.nanoTime() - ioStartTime;
                    // 运行非 IO 任务，一旦超时会退出 runAllTasks
                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                &#125;
            &#125;
        &#125; catch (Throwable t) &#123;
            handleLoopException(t);
        &#125;
        try &#123;
            if (isShuttingDown()) &#123;
                closeAll();
                if (confirmShutdown()) &#123;
                    return;
                &#125;
            &#125;
        &#125; catch (Throwable t) &#123;
            handleLoopException(t);
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h4><blockquote>
<p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>
<ul>
<li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li>
<li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li>
</ul>
</blockquote>
<p>参考下图</p>
<img src="images/0032.png"  />

<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>
<pre><code class="java">private void select(boolean oldWakenUp) throws IOException &#123;
    Selector selector = this.selector;
    try &#123;
        int selectCnt = 0;
        long currentTimeNanos = System.nanoTime();
        // 计算等待时间
        // * 没有 scheduledTask，超时时间为 1s
        // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`
        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);

        for (;;) &#123;
            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;
            // 如果超时，退出循环
            if (timeoutMillis &lt;= 0) &#123;
                if (selectCnt == 0) &#123;
                    selector.selectNow();
                    selectCnt = 1;
                &#125;
                break;
            &#125;

            // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行
            // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup
            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;
                selector.selectNow();
                selectCnt = 1;
                break;
            &#125;

            // select 有限时阻塞
            // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%
            int selectedKeys = selector.select(timeoutMillis);
            // 计数加 1
            selectCnt ++;

            // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环
            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;
                break;
            &#125;
            if (Thread.interrupted()) &#123;
                   // 线程被打断，退出循环
                // 记录日志
                selectCnt = 1;
                break;
            &#125;

            long time = System.nanoTime();
            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;
                // 如果超时，计数重置为 1，下次循环就会 break
                selectCnt = 1;
            &#125; 
            // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512
            // 这是为了解决 nio 空轮询 bug
            else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;
                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;
                // 重建 selector
                selector = selectRebuildSelector(selectCnt);
                selectCnt = 1;
                break;
            &#125;

            currentTimeNanos = time;
        &#125;

        if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;
            // 记录日志
        &#125;
    &#125; catch (CancelledKeyException e) &#123;
        // 记录日志
    &#125;
&#125;</code></pre>
<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>
<pre><code class="java">private void processSelectedKeys() &#123;
    if (selectedKeys != null) &#123;
        // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet 
        // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）
        processSelectedKeysOptimized();
    &#125; else &#123;
        processSelectedKeysPlain(selector.selectedKeys());
    &#125;
&#125;</code></pre>
<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<pre><code class="java">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    // 当 key 取消或关闭时会导致这个 key 无效
    if (!k.isValid()) &#123;
        // 无效时处理...
        return;
    &#125;

    try &#123;
        int readyOps = k.readyOps();
        // 连接事件
        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;
            int ops = k.interestOps();
            ops &amp;= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);

            unsafe.finishConnect();
        &#125;

        // 可写事件
        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123;
            ch.unsafe().forceFlush();
        &#125;

        // 可读或可接入事件
        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;
            // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read
            // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read
            unsafe.read();
        &#125;
    &#125; catch (CancelledKeyException ignored) &#123;
        unsafe.close(unsafe.voidPromise());
    &#125;
&#125;</code></pre>
<h3 id="accept-剖析"><a href="#accept-剖析" class="headerlink" title="accept 剖析"></a>accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p>
<pre><code class="java">//1 阻塞直到事件发生
selector.select();

Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();
while (iter.hasNext()) &#123;    
    //2 拿到一个事件
    SelectionKey key = iter.next();

    //3 如果是 accept 事件
    if (key.isAcceptable()) &#123;

        //4 执行 accept
        SocketChannel channel = serverSocketChannel.accept();
        channel.configureBlocking(false);

        //5 关注 read 事件
        channel.register(selector, SelectionKey.OP_READ);
    &#125;
    // ...
&#125;</code></pre>
<p>先来看可接入事件处理（accept）</p>
<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>
<pre><code class="java">public void read() &#123;
    assert eventLoop().inEventLoop();
    final ChannelConfig config = config();
    final ChannelPipeline pipeline = pipeline();    
    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
    allocHandle.reset(config);

    boolean closed = false;
    Throwable exception = null;
    try &#123;
        try &#123;
            do &#123;
                // doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf
                // readBuf 是一个 ArrayList 用来缓存消息
                int localRead = doReadMessages(readBuf);
                if (localRead == 0) &#123;
                    break;
                &#125;
                if (localRead &lt; 0) &#123;
                    closed = true;
                    break;
                &#125;
                // localRead 为 1，就一条消息，即接收一个客户端连接
                allocHandle.incMessagesRead(localRead);
            &#125; while (allocHandle.continueReading());
        &#125; catch (Throwable t) &#123;
            exception = t;
        &#125;

        int size = readBuf.size();
        for (int i = 0; i &lt; size; i ++) &#123;
            readPending = false;
            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理
            // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead
            pipeline.fireChannelRead(readBuf.get(i));
        &#125;
        readBuf.clear();
        allocHandle.readComplete();
        pipeline.fireChannelReadComplete();

        if (exception != null) &#123;
            closed = closeOnReadError(exception);

            pipeline.fireExceptionCaught(exception);
        &#125;

        if (closed) &#123;
            inputShutdown = true;
            if (isOpen()) &#123;
                close(voidPromise());
            &#125;
        &#125;
    &#125; finally &#123;
        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;
            removeReadOp();
        &#125;
    &#125;
&#125;</code></pre>
<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>
<pre><code class="java">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;
    // 这时的 msg 是 NioSocketChannel
    final Channel child = (Channel) msg;

    // NioSocketChannel 添加  childHandler 即初始化器
    child.pipeline().addLast(childHandler);

    // 设置选项
    setChannelOptions(child, childOptions, logger);

    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;
        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());
    &#125;

    try &#123;
        // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程
        childGroup.register(child).addListener(new ChannelFutureListener() &#123;
            @Override
            public void operationComplete(ChannelFuture future) throws Exception &#123;
                if (!future.isSuccess()) &#123;
                    forceClose(child, future.cause());
                &#125;
            &#125;
        &#125;);
    &#125; catch (Throwable t) &#123;
        forceClose(child, t);
    &#125;
&#125;</code></pre>
<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>
<pre><code class="java">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;
    // 一些检查，略...

    AbstractChannel.this.eventLoop = eventLoop;

    if (eventLoop.inEventLoop()) &#123;
        register0(promise);
    &#125; else &#123;
        try &#123;
            // 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换
            eventLoop.execute(new Runnable() &#123;
                @Override
                public void run() &#123;
                    register0(promise);
                &#125;
            &#125;);
        &#125; catch (Throwable t) &#123;
            // 日志记录...
            closeForcibly();
            closeFuture.setClosed();
            safeSetFailure(promise, t);
        &#125;
    &#125;
&#125;</code></pre>
<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<pre><code class="java">private void register0(ChannelPromise promise) &#123;
    try &#123;
        if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;
            return;
        &#125;
        boolean firstRegistration = neverRegistered;
        doRegister();
        neverRegistered = false;
        registered = true;

        // 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail
        pipeline.invokeHandlerAddedIfNeeded();
        // 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail

        safeSetSuccess(promise);
        pipeline.fireChannelRegistered();

        if (isActive()) &#123;
            if (firstRegistration) &#123;
                // 触发 pipeline 上 active 事件
                pipeline.fireChannelActive();
            &#125; else if (config().isAutoRead()) &#123;
                beginRead();
            &#125;
        &#125;
    &#125; catch (Throwable t) &#123;
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    &#125;
&#125;</code></pre>
<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>
<pre><code class="java">public void channelActive(ChannelHandlerContext ctx) &#123;
    ctx.fireChannelActive();
    // 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)
    readIfIsAutoRead();
&#125;</code></pre>
<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>
<pre><code class="java">protected void doBeginRead() throws Exception &#123;
    // Channel.read() or ChannelHandlerContext.read() was called
    final SelectionKey selectionKey = this.selectionKey;
    if (!selectionKey.isValid()) &#123;
        return;
    &#125;

    readPending = true;
    // 这时候 interestOps 是 0
    final int interestOps = selectionKey.interestOps();
    if ((interestOps &amp; readInterestOp) == 0) &#123;
        // 关注 read 事件
        selectionKey.interestOps(interestOps | readInterestOp);
    &#125;
&#125;</code></pre>
<h3 id="read-剖析"><a href="#read-剖析" class="headerlink" title="read 剖析"></a>read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p>
<pre><code class="java">public final void read() &#123;
    final ChannelConfig config = config();
    if (shouldBreakReadReady(config)) &#123;
        clearReadPending();
        return;
    &#125;
    final ChannelPipeline pipeline = pipeline();
    // io.netty.allocator.type 决定 allocator 的实现
    final ByteBufAllocator allocator = config.getAllocator();
    // 用来分配 byteBuf，确定单次读取大小
    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();
    allocHandle.reset(config);

    ByteBuf byteBuf = null;
    boolean close = false;
    try &#123;
        do &#123;
            byteBuf = allocHandle.allocate(allocator);
            // 读取
            allocHandle.lastBytesRead(doReadBytes(byteBuf));
            if (allocHandle.lastBytesRead() &lt;= 0) &#123;
                byteBuf.release();
                byteBuf = null;
                close = allocHandle.lastBytesRead() &lt; 0;
                if (close) &#123;
                    readPending = false;
                &#125;
                break;
            &#125;

            allocHandle.incMessagesRead(1);
            readPending = false;
            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler
            pipeline.fireChannelRead(byteBuf);
            byteBuf = null;
        &#125; 
        // 是否要继续循环
        while (allocHandle.continueReading());

        allocHandle.readComplete();
        // 触发 read complete 事件
        pipeline.fireChannelReadComplete();

        if (close) &#123;
            closeOnRead(pipeline);
        &#125;
    &#125; catch (Throwable t) &#123;
        handleReadException(pipeline, byteBuf, t, close, allocHandle);
    &#125; finally &#123;
        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;
            removeReadOp();
        &#125;
    &#125;
&#125;</code></pre>
<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>
<pre><code class="java">public boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;
    return 
           // 一般为 true
           config.isAutoRead() &amp;&amp;
           // respectMaybeMoreData 默认为 true
           // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true
           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;
           // 小于最大次数，maxMessagePerRead 默认 16
           totalMessages &lt; maxMessagePerRead &amp;&amp;
           // 实际读到了数据
           totalBytesRead &gt; 0;
&#125;</code></pre>
<hr>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1py4y1E7oA">B站黑马程序员Netty教程</a></p>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2023年01月01日 20:05</p>
        <p>原始链接： <a class="post-url" href="/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Netty学习笔记">http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
        <footer>
            <a href="http://muquanrui.com">
                <img src="/images/logo.png" alt="MU Quanrui">
                MU Quanrui
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=《Netty学习笔记》 — Quanrui's Blog&pic=cover.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&title=《Netty学习笔记》 — Quanrui's Blog&source=Carpe diem." data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Netty学习笔记》 — Quanrui's Blog&url=http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/&via=http://muquanrui.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://muquanrui.com/2022/07/17/Programming/Framework/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Programming/" class="color2">Programming</a>
      
    <a href="/tags/Framework/" class="color5">Framework</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
        <div class= "post-toc-name">Table of Contents</div>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-NIO-%E5%9F%BA%E7%A1%80"><span class="post-toc-text">1 NIO 基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="post-toc-text">1.1 三大组件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Channel-amp-Buffer"><span class="post-toc-text">Channel &amp; Buffer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Selector"><span class="post-toc-text">Selector</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="post-toc-text">多线程版设计</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="post-toc-text">线程池版设计</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#selector-%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="post-toc-text">selector 版设计</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-ByteBuffer"><span class="post-toc-text">1.2 ByteBuffer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ByteBuffer-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="post-toc-text">ByteBuffer 正确使用姿势</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ByteBuffer-%E7%BB%93%E6%9E%84"><span class="post-toc-text">ByteBuffer 结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ByteBuffer-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="post-toc-text">ByteBuffer 常见方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="post-toc-text">分配空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%91-buffer-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="post-toc-text">向 buffer 写入数据</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%8E-buffer-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="post-toc-text">从 buffer 读取数据</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mark-%E5%92%8C-reset"><span class="post-toc-text">mark 和 reset</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-ByteBuffer-%E4%BA%92%E8%BD%AC"><span class="post-toc-text">字符串与 ByteBuffer 互转</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E2%9A%A0%EF%B8%8F-Buffer-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="post-toc-text">⚠️ Buffer 的线程安全</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Scattering-Reads"><span class="post-toc-text">Scattering Reads</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Gathering-Writes"><span class="post-toc-text">Gathering Writes</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="post-toc-text">练习</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="post-toc-text">1.3 文件编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#FileChannel"><span class="post-toc-text">FileChannel</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E2%9A%A0%EF%B8%8F-FileChannel-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">⚠️ FileChannel 工作模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96"><span class="post-toc-text">获取</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="post-toc-text">读取</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%86%99%E5%85%A5"><span class="post-toc-text">写入</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%B3%E9%97%AD"><span class="post-toc-text">关闭</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="post-toc-text">位置</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%A7%E5%B0%8F"><span class="post-toc-text">大小</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5"><span class="post-toc-text">强制写入</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%A4%E4%B8%AA-Channel-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="post-toc-text">两个 Channel 传输数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Path"><span class="post-toc-text">Path</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Files"><span class="post-toc-text">Files</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="post-toc-text">1.4 网络编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-vs-%E9%98%BB%E5%A1%9E"><span class="post-toc-text">非阻塞 vs 阻塞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="post-toc-text">阻塞</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="post-toc-text">非阻塞</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="post-toc-text">多路复用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Selector-1"><span class="post-toc-text">Selector</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="post-toc-text">创建</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%91%E5%AE%9A-Channel-%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">绑定 Channel 事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%91%E5%90%AC-Channel-%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">监听 Channel 事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-select-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%98%BB%E5%A1%9E"><span class="post-toc-text">💡 select 何时不阻塞</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%84%E7%90%86-accept-%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">处理 accept 事件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E8%83%BD%E5%90%A6%E4%B8%8D%E5%A4%84%E7%90%86"><span class="post-toc-text">💡 事件发生后能否不处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%84%E7%90%86-read-%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">处理 read 事件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E4%B8%BA%E4%BD%95%E8%A6%81-iter-remove"><span class="post-toc-text">💡 为何要 iter.remove()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-cancel-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="post-toc-text">💡 cancel 的作用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%B8%8D%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="post-toc-text">⚠️  不处理边界的问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="post-toc-text">处理消息的边界</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ByteBuffer-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D"><span class="post-toc-text">ByteBuffer 大小分配</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%84%E7%90%86-write-%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">处理 write 事件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90"><span class="post-toc-text">一次无法写完例子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-write-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%8F%96%E6%B6%88"><span class="post-toc-text">💡 write 为何要取消</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="post-toc-text">更进一步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="post-toc-text">💡 利用多线程优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0-cpu-%E4%B8%AA%E6%95%B0"><span class="post-toc-text">💡 如何拿到 cpu 个数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#UDP"><span class="post-toc-text">UDP</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-5-NIO-vs-BIO"><span class="post-toc-text">1.5 NIO vs BIO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stream-vs-channel"><span class="post-toc-text">stream vs channel</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#IO-%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">IO 模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">零拷贝</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98"><span class="post-toc-text">传统 IO 问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#NIO-%E4%BC%98%E5%8C%96"><span class="post-toc-text">NIO 优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AIO"><span class="post-toc-text">AIO</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%87%E4%BB%B6-AIO"><span class="post-toc-text">文件 AIO</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="post-toc-text">💡 守护线程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BD%91%E7%BB%9C-AIO"><span class="post-toc-text">网络 AIO</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-Netty-%E5%85%A5%E9%97%A8"><span class="post-toc-text">2 Netty 入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="post-toc-text">2.1 概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Netty-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="post-toc-text">Netty 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Netty-%E7%9A%84%E4%BD%9C%E8%80%85"><span class="post-toc-text">Netty 的作者</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Netty-%E7%9A%84%E5%9C%B0%E4%BD%8D"><span class="post-toc-text">Netty 的地位</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Netty-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="post-toc-text">Netty 的优势</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-Hello-World"><span class="post-toc-text">2.2 Hello World</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="post-toc-text">目标</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="post-toc-text">服务器端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="post-toc-text">客户端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="post-toc-text">流程梳理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E6%8F%90%E7%A4%BA"><span class="post-toc-text">💡 提示</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-%E7%BB%84%E4%BB%B6"><span class="post-toc-text">2.3 组件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#EventLoop"><span class="post-toc-text">EventLoop</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD"><span class="post-toc-text">💡 优雅关闭</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%BC%94%E7%A4%BA-NioEventLoop-%E5%A4%84%E7%90%86-io-%E4%BA%8B%E4%BB%B6"><span class="post-toc-text">演示 NioEventLoop 处理 io 事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-handler-%E6%89%A7%E8%A1%8C%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8D%A2%E4%BA%BA%EF%BC%9F"><span class="post-toc-text">💡 handler 执行中如何换人？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%BC%94%E7%A4%BA-NioEventLoop-%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%BB%BB%E5%8A%A1"><span class="post-toc-text">演示 NioEventLoop 处理普通任务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%BC%94%E7%A4%BA-NioEventLoop-%E5%A4%84%E7%90%86%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="post-toc-text">演示 NioEventLoop 处理定时任务</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Channel"><span class="post-toc-text">Channel</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ChannelFuture"><span class="post-toc-text">ChannelFuture</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CloseFuture"><span class="post-toc-text">CloseFuture</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E5%BC%82%E6%AD%A5%E6%8F%90%E5%8D%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text">💡 异步提升的是什么</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Future-amp-Promise"><span class="post-toc-text">Future &amp; Promise</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Handler-amp-Pipeline"><span class="post-toc-text">Handler &amp; Pipeline</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ByteBuf"><span class="post-toc-text">ByteBuf</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="post-toc-text">创建</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-vs-%E5%A0%86%E5%86%85%E5%AD%98"><span class="post-toc-text">直接内存 vs 堆内存</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B1%A0%E5%8C%96-vs-%E9%9D%9E%E6%B1%A0%E5%8C%96"><span class="post-toc-text">池化 vs 非池化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%84%E6%88%90"><span class="post-toc-text">组成</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%86%99%E5%85%A5-1"><span class="post-toc-text">写入</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="post-toc-text">扩容</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%BB%E5%8F%96-1"><span class="post-toc-text">读取</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#retain-amp-release"><span class="post-toc-text">retain &amp; release</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#slice"><span class="post-toc-text">slice</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#duplicate"><span class="post-toc-text">duplicate</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#copy"><span class="post-toc-text">copy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CompositeByteBuf"><span class="post-toc-text">CompositeByteBuf</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Unpooled"><span class="post-toc-text">Unpooled</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-ByteBuf-%E4%BC%98%E5%8A%BF"><span class="post-toc-text">💡 ByteBuf 优势</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1"><span class="post-toc-text">2.4 双向通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%83%E4%B9%A0-1"><span class="post-toc-text">练习</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%F0%9F%92%A1-%E8%AF%BB%E5%92%8C%E5%86%99%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="post-toc-text">💡 读和写的误解</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-Netty-%E8%BF%9B%E9%98%B6"><span class="post-toc-text">3 Netty 进阶</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-%E7%B2%98%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85"><span class="post-toc-text">3.1 粘包与半包</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="post-toc-text">粘包现象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="post-toc-text">半包现象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90"><span class="post-toc-text">现象分析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="post-toc-text">解决方案</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E7%9F%AD%E9%93%BE%E6%8E%A5"><span class="post-toc-text">方法1：短链接</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6"><span class="post-toc-text">方法2：固定长度</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E5%9B%BA%E5%AE%9A%E5%88%86%E9%9A%94%E7%AC%A6"><span class="post-toc-text">方法3：固定分隔符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A%E9%A2%84%E8%AE%BE%E9%95%BF%E5%BA%A6"><span class="post-toc-text">方法4：预设长度</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="post-toc-text">3.2 协议设计与解析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="post-toc-text">为什么需要协议？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#redis-%E5%8D%8F%E8%AE%AE%E4%B8%BE%E4%BE%8B"><span class="post-toc-text">redis 协议举例</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#http-%E5%8D%8F%E8%AE%AE%E4%B8%BE%E4%BE%8B"><span class="post-toc-text">http 协议举例</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%B4%A0"><span class="post-toc-text">自定义协议要素</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="post-toc-text">编解码器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%F0%9F%92%A1-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E5%8A%A0-Sharable"><span class="post-toc-text">💡 什么时候可以加 @Sharable</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-%E8%81%8A%E5%A4%A9%E5%AE%A4%E6%A1%88%E4%BE%8B"><span class="post-toc-text">3.3 聊天室案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">聊天室业务介绍</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E7%99%BB%E5%BD%95"><span class="post-toc-text">聊天室业务-登录</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E5%8D%95%E8%81%8A"><span class="post-toc-text">聊天室业务-单聊</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E7%BE%A4%E8%81%8A"><span class="post-toc-text">聊天室业务-群聊</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E9%80%80%E5%87%BA"><span class="post-toc-text">聊天室业务-退出</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%8A%E5%A4%A9%E5%AE%A4%E4%B8%9A%E5%8A%A1-%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B"><span class="post-toc-text">聊天室业务-空闲检测</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%81%87%E6%AD%BB"><span class="post-toc-text">连接假死</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81"><span class="post-toc-text">4 优化与源码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-%E4%BC%98%E5%8C%96"><span class="post-toc-text">4.1 优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%89%A9%E5%B1%95%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95"><span class="post-toc-text">扩展序列化算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="post-toc-text">参数调优</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1%EF%BC%89CONNECT-TIMEOUT-MILLIS"><span class="post-toc-text">1）CONNECT_TIMEOUT_MILLIS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2%EF%BC%89SO-BACKLOG"><span class="post-toc-text">2）SO_BACKLOG</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3%EF%BC%89ulimit-n"><span class="post-toc-text">3）ulimit -n</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4%EF%BC%89TCP-NODELAY"><span class="post-toc-text">4）TCP_NODELAY</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5%EF%BC%89SO-SNDBUF-amp-SO-RCVBUF"><span class="post-toc-text">5）SO_SNDBUF &amp; SO_RCVBUF</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6%EF%BC%89ALLOCATOR"><span class="post-toc-text">6）ALLOCATOR</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7%EF%BC%89RCVBUF-ALLOCATOR"><span class="post-toc-text">7）RCVBUF_ALLOCATOR</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RPC-%E6%A1%86%E6%9E%B6"><span class="post-toc-text">RPC 框架</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1%EF%BC%89%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="post-toc-text">1）准备工作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2%EF%BC%89%E6%9C%8D%E5%8A%A1%E5%99%A8-handler"><span class="post-toc-text">2）服务器 handler</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%AC%AC%E4%B8%80%E7%89%88"><span class="post-toc-text">3）客户端代码第一版</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#4%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF-handler-%E7%AC%AC%E4%B8%80%E7%89%88"><span class="post-toc-text">4）客户端 handler 第一版</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#5%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81-%E7%AC%AC%E4%BA%8C%E7%89%88"><span class="post-toc-text">5）客户端代码 第二版</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#6%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF-handler-%E7%AC%AC%E4%BA%8C%E7%89%88"><span class="post-toc-text">6）客户端 handler 第二版</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="post-toc-text">4.2 源码分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%90%AF%E5%8A%A8%E5%89%96%E6%9E%90"><span class="post-toc-text">启动剖析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#NioEventLoop-%E5%89%96%E6%9E%90"><span class="post-toc-text">NioEventLoop 剖析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E2%9A%A0%EF%B8%8F-%E6%B3%A8%E6%84%8F"><span class="post-toc-text">⚠️ 注意</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#accept-%E5%89%96%E6%9E%90"><span class="post-toc-text">accept 剖析</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#read-%E5%89%96%E6%9E%90"><span class="post-toc-text">read 剖析</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2022/08/13/Programming/Framework/Spring/Spring%20&%20Spring%20Boot%E5%85%AB%E8%82%A1%E6%96%87/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Spring &amp; Spring Boot八股文
        
      </span>
    </a>
  
  
    <a href="/2022/07/09/Programming/Java%20Tutorial/JUC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">JUC学习笔记</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="Programming/Framework/Netty学习笔记" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyvaQ34l4';
        var conf = 'dfbc2f31fdc91ffc75e2035195b4426d';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    |
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
    <div class="theme-info">
</p>


      <span class="post-count">本站博文总字数：718.2k</span>
      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2018~2023 MU Quanrui<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!--加载prettify代码高亮js-->
  <script type="text/javascript" src="/google-code-prettify/prettify.js"></script>
  <script type="text/javascript">
    $(document).ready(function(){
      $('pre').addClass('prettyprint linenums');
      $('code').addClass('prettyprint');
      prettyPrint();
    })
  </script>

<script>
  var mihoConfig = {
      root: "http://muquanrui.com",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Blog/">Blog</a><a class="category-link" href="/categories/Data-Structures-Algorithms/">Data Structures & Algorithms</a><a class="category-link" href="/categories/Database/">Database</a><a class="category-link" href="/categories/ENSEEIHT/">ENSEEIHT</a><a class="category-link" href="/categories/Framework/">Framework</a><a class="category-link" href="/categories/Franc%CC%A7ais/">Français</a><a class="category-link" href="/categories/Java-Project/">Java Project</a><a class="category-link" href="/categories/Java-Tutorial/">Java Tutorial</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/Methodology/">Methodology</a><a class="category-link" href="/categories/Middleware/">Middleware</a><a class="category-link" href="/categories/Network/">Network</a><a class="category-link" href="/categories/Operating-System/">Operating System</a><a class="category-link" href="/categories/Photography/">Photography</a><a class="category-link" href="/categories/Problem-Solving/">Problem Solving</a><a class="category-link" href="/categories/Software/">Software</a><a class="category-link" href="/categories/Tech-Note/">Tech Note</a><a class="category-link" href="/categories/macOS/">macOS</a><a class="category-link" href="/categories/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/">墓畔回忆录</a><a class="category-link" href="/categories/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/">我的大学</a><a class="category-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Franc%CC%A7ais/" style="font-size: 15px;">Français</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 16.88px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.25px;">读书笔记</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/categories">
                    <i class="fa fa-book"></i><span>Categories</span>
                </a>
            </li>
            
            <li>
                <a  href="/tags">
                    <i class="fa fa-tags"></i><span>Tags</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Franc%CC%A7ais/" style="font-size: 15px;">Français</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 16.88px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.25px;">读书笔记</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>









  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400,"vOffset":-30},"mobile":{"show":false},"react":{"opacity":0.8},"log":false});</script></body>
</html>



