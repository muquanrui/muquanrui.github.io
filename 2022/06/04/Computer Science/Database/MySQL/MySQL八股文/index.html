<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MySQL八股文 | Quanrui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Quanrui's Blog" />
  
  <meta name="description" content="1 数据库基础数据库、数据库管理系统、数据库系统、数据库管理员 数据库：DataBase（DB）是信息的集合。或者说，数据库是由数据库管理系统管理的数据的集合。 数据库管理系统：Database Management System（DBMS）是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统：Data Base System（DBS）通常由软件、数据库和数据管理员组成。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL八股文">
<meta property="og:url" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Quanrui&#39;s Blog">
<meta property="og:description" content="1 数据库基础数据库、数据库管理系统、数据库系统、数据库管理员 数据库：DataBase（DB）是信息的集合。或者说，数据库是由数据库管理系统管理的数据的集合。 数据库管理系统：Database Management System（DBMS）是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统：Data Base System（DBS）通常由软件、数据库和数据管理员组成。">
<meta property="og:locale">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/E-R.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220604101814748.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220609125835526.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220609130007884.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220610091056527.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220610120415057.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220610120953750.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220610134450333.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611115955692.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611195455021.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611195739813.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611195455021.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611195739813.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611200506256.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611200918415.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220611201203407.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220612105753676.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220612110622226.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220612110755663.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220612110725380.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/11.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/12.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/02-20220305234738688.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/03-20220305234742460.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/04-20220305234747840.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/02-20220305234828662.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/03-20220305235104445.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/04-20220305234956774.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/05-20220305234937243.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/06-20220305234907651.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220613100523252.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220613101057288.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220613101628665.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220613104506615.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220613104758765.png">
<meta property="og:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220613175735717.png">
<meta property="article:published_time" content="2022-06-03T23:39:08.000Z">
<meta property="article:modified_time" content="2023-01-01T12:07:47.437Z">
<meta property="article:author" content="MU Quanrui">
<meta property="article:tag" content="Computer Science">
<meta property="article:tag" content="Database">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/images/E-R.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  
<link rel="stylesheet" href="/css/style.css">


 <!--加载prettify代码高亮样式-->
<link href="/google-code-prettify/tranquil-heart.css" type="text/css" rel="stylesheet" />

  
<script src="/js/pace.min.js"></script>

  

  
  


  <!--加载条样式-->
  <style>
    .pace .pace-progress {
    	background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);
    	height: 3px;
    }
    .pace .pace-progress-inner {
     	box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
    	border-top-color: #1E92FB;	/*上边框颜色*/
    	border-left-color: #1E92FB;	/*左边框颜色*/
    }
  </style>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div id="background"></div><!--背景颜色/图片-->
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">

        <div id="header-menu" class="header-menu-pos animated">


<a target="_blank" rel="noopener" href="https://github.com/muquanrui" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FFA500; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Quanrui&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/categories">
                        <i class="fa fa-book"></i>
                        <span>Categories</span>
                    </a>
                    
                    <a  href="/tags">
                        <i class="fa fa-tags"></i>
                        <span>Tags</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Quanrui&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        Carpe diem.
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//muquanrui.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/muquanrui">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Google" target="_blank" href="//google.com">
                            <i class="fa fa-google fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Computer Science/Database/MySQL/MySQL八股文" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      MySQL八股文
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Database/">Database</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-06-04
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>          
        </li>
      </ul>
       <span class="post-count">文章字数:26.6k字 &nbsp &nbsp  
         阅读时长:94分钟</span>
    </div>
  
        
          
      </header>
    

    <div class="article-entry post-content" itemprop="articleBody">

    
    



      
            
            <h1 id="1-数据库基础"><a href="#1-数据库基础" class="headerlink" title="1 数据库基础"></a>1 数据库基础</h1><h2 id="数据库、数据库管理系统、数据库系统、数据库管理员"><a href="#数据库、数据库管理系统、数据库系统、数据库管理员" class="headerlink" title="数据库、数据库管理系统、数据库系统、数据库管理员"></a>数据库、数据库管理系统、数据库系统、数据库管理员</h2><ul>
<li>数据库：DataBase（DB）是信息的集合。或者说，数据库是由数据库管理系统管理的数据的集合。</li>
<li>数据库管理系统：Database Management System（DBMS）是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>
<li>数据库系统：Data Base System（DBS）通常由软件、数据库和数据管理员组成。</li>
<li>数据库管理员：Database Administrator（DBA）负责全面管理和控制数据库系统。</li>
</ul>
<h2 id="元组、码、候选码、主码、外码、主属性、非主属性"><a href="#元组、码、候选码、主码、外码、主属性、非主属性" class="headerlink" title="元组、码、候选码、主码、外码、主属性、非主属性"></a>元组、码、候选码、主码、外码、主属性、非主属性</h2><ul>
<li><p>元组：tuple是关系型数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</p>
</li>
<li><p>码：能唯一标识实体的属性，对应表中的列。</p>
</li>
<li><p>候选码：若关系中的某一个或某一组属性的值能唯一标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。</p>
</li>
<li><p>主码：primary key也叫主键。主码是从候选码中选出来的，一个实体集中只能有一个主码，但可以有多个候选码。</p>
</li>
<li><p>外码：foreign key也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</p>
</li>
<li><p>主属性：候选码中出现过的属性称为主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</p>
</li>
<li><p>非主属性：不包含在任何一个候选码中的属性称为非主属性。</p>
</li>
</ul>
<h2 id="主键和外键"><a href="#主键和外键" class="headerlink" title="主键和外键"></a>主键和外键</h2><ul>
<li>主键(主码)：用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li>外键(外码)：用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>
</ul>
<h2 id="为什么不推荐使用外键与级联？"><a href="#为什么不推荐使用外键与级联？" class="headerlink" title="为什么不推荐使用外键与级联？"></a>为什么不推荐使用外键与级联？</h2><p><strong>级联</strong>：以学生和成绩的关系为例，学生表中的<code>student_id</code>是主键，那么成绩表中的<code>student_id</code>则为外键。如果更新学生表中的<code>student_id</code>，同时触发成绩表中的<code>student_id</code>更新，即为级联更新。</p>
<p>《阿里巴巴Java开发手册》中强制不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<blockquote>
<p>外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风险; 外键影响数据库的插入速度。</p>
</blockquote>
<p>不使用外键的原因主要有：</p>
<ul>
<li>增加了复杂性：每次做<strong>DELETE</strong>或者<strong>UPDATE</strong>都必须考虑外键约束，会导致开发的时候很痛苦，测试数据极为不便。且外键的主从关系是确定的，假如哪天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>
<li>增加了额外工作：数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源。当然了，在应用层做检查也是一样会增加额外工作，因此这个理由比较牵强。</li>
<li>对分库分表不友好：因为分库分表下外键是无法生效的。</li>
</ul>
<h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p><strong>E-R图</strong>也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，是描述现实世界关系概念模型的有效方法，也是表示概念关系模型的一种方式。其中关系可以表示为1对1（1:1），1对多（1:N），多对多（N:N）。</p>
<p><img src="images/E-R.png" alt="E-R"></p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为<strong>范式</strong>（normal form）。可以理解为，一张数据表的设计结构需要满足的某种设计标准的级别。</p>
<img src="images/image-20220604101814748.png" alt="image-20220604101814748" style="zoom:50%;" />

<p><strong>第一范式1NF</strong>：强调的是列的原子性，即列不能够再分成其他几列。 1NF是所有关系型数据库的最基本要求。</p>
<p>考虑一个联系人表：联系人(姓名，性别，电话) </p>
<ul>
<li>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到1NF。</li>
<li>只需把(电话)拆分，即联系人(姓名，性别，家庭电话，公司电话)。</li>
</ul>
<p><strong>第二范式2NF</strong>：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖，即没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。不符合2NF会带来数据冗余，插入、删除、更新的异常。</p>
<p>考虑一个订单明细表：OrderDetail(OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName)。 </p>
<ul>
<li>在一个订单中可以订购多种产品，所以单单一个OrderID是不足以成为主键的，主键应该是(OrderID，ProductID)。显而易见Discount，Quantity完全依赖于主键(OderID，ProductID)，而UnitPrice，ProductName只依赖于ProductID。所以OrderDetail表不符合2NF。</li>
<li>可以把OrderDetail表拆分为OrderDetail(OrderID，ProductID，Discount，Quantity)和Product(ProductID，UnitPrice，ProductName)来消除原订单表中UnitPrice，ProductName多次重复的情况。</li>
</ul>
<p>关于依赖：</p>
<ul>
<li><strong>函数依赖</strong>（functional dependency）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于 X，写作X -&gt; Y。</li>
<li><strong>部分函数依赖</strong>（partial functional dependency）：如果X -&gt; Y，并且存在X的一个真子集X<del>0</del>，使得X<del>0</del> -&gt; Y，则称Y对X部分函数依赖。比如学生表R(学号，身份证号，姓名)中，(学号，身份证号) -&gt; (姓名)，但其中的(学号)/(身份证号) -&gt; (姓名)，因此(姓名)部分依赖于(学号，身份证号)。</li>
<li><strong>完全函数依赖</strong>（full functional dependency）：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如地址表R(街道号，门牌号，户主)中，不同街道可以有同样的门牌，因此要确定户主必须(街道号，门牌号) -&gt; (户主)，因此(户主)完全依赖于(街道号，门牌号)。</li>
<li><strong>传递函数依赖</strong>（transitive functional dependency）：在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩ Z = 空集合，则称 Z 传递函数依赖于X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号 , 姓名, 系名，系主任)中，(学号) → (系名)，(系名) → (系主任)，所以存在非主属性(系主任)对于(学号)的传递函数依赖。。</li>
</ul>
<p><strong>第三范式3NF</strong>：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖，即非主键列必须直接依赖于主键，不能存在传递依赖。</p>
<p>考虑一个订单表Order(OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity)，主键是(OrderID)。 </p>
<ul>
<li>其中OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity等非主键列都完全依赖于主键，所以符合2NF。</li>
<li>不过问题是CustomerName，CustomerAddr，CustomerCity直接依赖的是CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合3NF。 </li>
<li>通过拆分Order为Order(OrderID，OrderDate，CustomerID)和Customer(CustomerID，CustomerName，CustomerAddr，CustomerCity)从而达到3NF。 </li>
</ul>
<p><strong>巴斯科德范式BCNF</strong>：BCNF在3NF的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</p>
<p><strong>第四范式4NF</strong>：消除多值依赖。</p>
<p><strong>第五范式5NF</strong>：消除不是由候选键所蕴含的连接依赖。</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程可以看成是一系列SQL语句的集合，中间加了逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串SQL语句，这时候我们就可以写有一个存储过程，方便下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯SQL语句执行要快，因为存储过程是预编译过的。</p>
<p>但是存储过程在互联网公司应用不多，《阿里巴巴Java开发手册》要求禁止使用存储过程。</p>
<blockquote>
<p>存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<h1 id="2-MySQL基础"><a href="#2-MySQL基础" class="headerlink" title="2 MySQL基础"></a>2 MySQL基础</h1><h2 id="关系型数据库和MySQL"><a href="#关系型数据库和MySQL" class="headerlink" title="关系型数据库和MySQL"></a>关系型数据库和MySQL</h2><p>顾名思义，<strong>关系型数据库</strong>就是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>
<p>大部分关系型数据库都使用<strong>SQL</strong>来操作数据库中的数据，并且大部分关系型数据库都支持事务的四大特性（ACID）。常见的关系型数据库有MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的SQLite）等。</p>
<p><strong>MySQL</strong>是一种关系型数据库，主要用于持久化存储系统中的一些数据。MySQL是开源免费且比较成熟的数据库，因此被大量使用在各种系统中。任何人都可以在GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是<code>3306</code>。</p>
<h2 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a>drop、delete与truncate</h2><p>用法不同：</p>
<ul>
<li><code>drop table 表名</code>：直接将表即表的结构都删除掉，在删除表的时候使用。</li>
<li><code>truncate table 表名</code>：只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中数据的时候使用。</li>
<li><code>delete from 表名 where 列名=值</code>：删除某一行的数据，如果不加where子句和truncate作用类似。</li>
</ul>
<p>属于不同的数据库语言类型：</p>
<ul>
<li><code>truncate</code>和<code>drop</code>属于 <strong>DDL</strong>（Data Definition Language）语句，操作立即生效，原数据不放到rollback segment中，不能回滚，操作不触发 trigger。</li>
<li><code>delete</code>语句是<strong>DML</strong>（Data Manipulation Language语句，操作会放到rollback segement中，事务提交之后才生效。</li>
</ul>
<p>执行速度不同：</p>
<ul>
<li>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></li>
<li><code>delete</code>命令执行的时候会产生数据库的<strong>binlog</strong>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>
<li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li>
<li><code>drop</code>命令会把表占用的空间全部释放掉，因此是最快的。</li>
</ul>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><strong>字符</strong>是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。</p>
<p><strong>字符集</strong>就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同。</p>
<p>计算机只能存储二进制的数据，我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应“a”。我们将字符对应二进制数据的过程称为”字符编码”，反之，二进制数据解析成字符的过程称为“字符解码”。</p>
<p>不同的字符集的主要区别在于可以表示的字符范围和编码方式：</p>
<ul>
<li><strong>ASCII</strong>（American Standard Code for Information Interchange）是一套主要用于现代美国英语的字符集，至今为止共定义了128个字符，其中有33个控制字符（比如回车、删除）无法显示。一个ASCII码长度是1个字节也就是8个bit。</li>
<li><strong>GB2312</strong>是一种对汉字比较友好的字符集，共收录6700多个汉字，基本涵盖了绝大部分常用汉字，不过GB2312字符集不支持绝大部分的生僻字和繁体字。对于英语字符，GB2312编码和ASCII码是相同的，1字节编码即可；对于非英字符，需要2字节编码。</li>
<li><strong>GBK</strong>（K是汉语拼音扩展中“Kuo”的首字母）可以看作是GB2312字符集的扩展，兼容GB2312字符集，共收录了20000多个汉字。</li>
<li><strong>GB18030</strong>完全兼容GB2312和GBK字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字70000多个。</li>
<li><strong>BIG5</strong>主要针对的是繁体中文，收录了13000多个汉字。</li>
</ul>
<p>为了更加适合本国语言，不同的国家地区诞生了很多种字符集，但是使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。<strong>乱码</strong>的本质就是编码和解码时用了不同或者不兼容的字符集。</p>
<p><strong>Unicode</strong>应运而生，Unicode字符集中包含了世界上几乎所有已知的字符，不过Unicode并没有规定如何用二进制存储这些字符。</p>
<p>然后，就有了<strong>UTF-8</strong>（8-bit Unicode Transformation Format），类似的还有<strong>UTF-16</strong>、<strong>UTF-32</strong>。UTF-8使用1到4个字节为每个字符编码，UTF-16使用2或4个字节为每个字符编码，UTF-32固定4个字节为每个字符编码。</p>
<p>UTF-8是目前使用最广的一种字符编码，可以根据不同的符号自动选择编码的长短，像英文字符只需要1个字节就够了，因此，对于英语字符UTF-8编码和ASCII码是相同的。</p>
<p>UTF-32的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是UTF-8的4倍之多。</p>
<p>MySQL支持很多字符集，通常情况下建议使用UTF-8作为默认的字符编码方式。不过，MySQL字符编码集中有两套UTF-8编码实现：</p>
<ul>
<li><strong>utf8</strong>：utf8编码只支持1-3个字节，在utf8编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但emoji符号占4个字节，一些较复杂的文字、繁体字也是4个字节，默认的utf8无法正确存储。</li>
<li><strong>utf8mb4</strong>：UTF-8的完整实现！最多支持使用4个字节表示字符，因此，可以用来存储emoji符号。</li>
</ul>
<h1 id="3-数据目录"><a href="#3-数据目录" class="headerlink" title="3 数据目录"></a>3 数据目录</h1><h2 id="MySQL文件目录"><a href="#MySQL文件目录" class="headerlink" title="MySQL文件目录"></a>MySQL文件目录</h2><p>以下是Linux中MySQL的主要文件路径：</p>
<ul>
<li>MySQL数据库文件的存放路径：<code>show variables like &#39;datadir&#39;;</code>查看。一般在<code>/var/lib/mysql/</code>。</li>
<li>相关命令目录：<code>/usr/bin</code>（mysqladmin、mysqlbinlog、mysqldump等命令）和<code>/usr/sbin</code>。</li>
<li>配置文件目录：<code>/usr/share/mysql-8.0</code>（命令及配置文件），/etc/mysql（my.cnf等）。</li>
</ul>
<h2 id="MySQL系统自带数据库"><a href="#MySQL系统自带数据库" class="headerlink" title="MySQL系统自带数据库"></a>MySQL系统自带数据库</h2><p><code>SHOW DATABASES;</code>可以查看到MySQL系统自带的数据库，主要有：</p>
<ul>
<li><code>mysql</code>：MySQL系统自带的核心数据库，存储MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</li>
<li><code>information_schema</code>：<strong>保存MySQL服务器维护的所有其他数据库的信息</strong>，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为<strong>元数据</strong>。在该数据库中提供了一些以<strong>innodb_sys</strong>开头的表，用于表示内部系统表。</li>
<li><code>performance_schema</code>：主要保存MySQL服务器运行过程中的一些状态信息，可以 <strong>用来监控MySQL服务的各类性能指标</strong>。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等信息。</li>
<li><code>sys</code>：通过<strong>视图</strong>的形式把<code>information_schema</code>和<code>performance_schema</code>结合起来，帮助系统管理员和开发人员监控MySQL的技术性能。</li>
</ul>
<p>在MySQL数据库文件存放路径下，除了<code>information_schema</code>这个系统数据库外，其他的数据库在数据目录下都有对应的子目录。</p>
<h2 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h2><h3 id="InnoDB存储引擎模式"><a href="#InnoDB存储引擎模式" class="headerlink" title="InnoDB存储引擎模式"></a>InnoDB存储引擎模式</h3><ol>
<li><strong>表结构</strong></li>
</ol>
<p><code>InnoDB</code>存储引擎模式下，数据库子目录下会为每个表创建一个专门用于描述表结构的文件<code>表名.frm</code>，该文件以二进制格式存储。</p>
<ol start="2">
<li><strong>表中数据和索引</strong></li>
</ol>
<p>默认情况下，InnoDB会在数据目录下创建一个名为<code>ibdata1</code>，大小为<code>12M</code>的文件，这个文件对应<strong>系统表空间</strong>在文件系统上的表示。MySQL 5.6.6以前数据库中各个表的数据都默认存储在系统表空间。这个文件初始大小只有12M，但是它是<strong>自扩展文件</strong>，当不够用时会自己增加文件大小。</p>
<p>在MySQL 5.6.6及之后的版本中，<code>InnoDB</code>并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个<strong>独立表空间</strong>，也就是说创建了多少个表，就有多少个独立表空间。使用独立表空间来存储表数据时，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，添加了一个<code>.ibd</code>的扩展名。而且<code>InnoDB</code>中<strong>数据即索引</strong>，不用再单独生成文件来保存索引。</p>
<p>比如在数据库<code>temp</code>下创建一个名为<code>test</code>的表，就会在数据目录的该数据库子目录下生成：</p>
<pre><code class="shell">mysql/temp/test.frm # 描述表结构（8.0之后合并在ibd文件中）
mysql/temp/test.ibd # 独立表空间存储表数据的索引</code></pre>
<h3 id="MyISAM存储引擎模式"><a href="#MyISAM存储引擎模式" class="headerlink" title="MyISAM存储引擎模式"></a>MyISAM存储引擎模式</h3><ol>
<li><strong>表结构</strong></li>
</ol>
<p><code>MyISAM</code>和<code>InnoDB</code>一样，也是在数据目录下对应的数据库子目录下创建了一个以<code>.frm</code>为后缀专门用于描述表结构的文件。</p>
<ol start="2">
<li><strong>表中数据和索引</strong></li>
</ol>
<p>在<code>MyISAM</code>中索引全部都是二级索引，<strong>数据和索引是分开存放的</strong>，在文件系统中也是使用不同的文件来存储数据文件和索引文件，同时表数据也都存放在对应的数据库子目录下。</p>
<p>比如在数据库<code>temp</code>下创建一个名为<code>test</code>的表，就会在数据目录的该数据库子目录下生成：</p>
<pre><code class="shell">mysql/temp/test.frm # 描述表结构
mysql/temp/test.MYD # 存储表数据
mysql/temp/test.MYI # 存储表文件</code></pre>
<h1 id="4-逻辑架构"><a href="#4-逻辑架构" class="headerlink" title="4 逻辑架构"></a>4 逻辑架构</h1><p>MySQL服务器进程对客户端的进程请求的处理流程：</p>
<p>![MySQL Framework](images/MySQL Framework.png)</p>
<p>MySQL的逻辑架构主要包括：</p>
<ol>
<li><strong>Connectors</strong>：客户端链接程序。比如JDBC等。</li>
<li>MySQL第1层 - <strong>连接层</strong>：客户端访问MySQL服务器前做的第一件事就是建立<strong>TCP</strong>连接。经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互，所以还会有个<strong>线程池</strong>，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</li>
<li>MySQL第2层 - <strong>服务层</strong>：<ul>
<li><strong>SQL Interface</strong>：SQL接口。接收用户的SQL命令，并且返回用户需要查询的结果。</li>
<li><strong>Parser</strong>：解析器。对SQL语句进行语法分析、语义分析，并为其创建语法树，根据数据字典丰富查询语法树，验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQL查询进行语法上的优化，进行查询重写。之后将这个结构传递到后续步骤。</li>
<li><strong>Optimizer</strong>：查询优化器。SQL语句在语法解析之后、查询之前会使用查询优化器确定SQL语句的执行路径，生成一个<strong>执行计划</strong>。这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何等，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。</li>
<li><strong>Caches &amp; Buffers</strong>：查询缓存组件。MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</li>
</ul>
</li>
<li>MySQL第3层 - <strong>引擎层</strong>：插件式存储引擎层（Storage Engines），真正负责MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。</li>
<li><strong>存储层</strong>：所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在<strong>文件系统</strong>上，以<strong>文件</strong>的方式存在的，并完成与存储引擎的交互。</li>
</ol>
<h1 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5 存储引擎"></a>5 存储引擎</h1><h2 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h2><h3 id="InnoDB：具备外键支持功能的事务存储引擎"><a href="#InnoDB：具备外键支持功能的事务存储引擎" class="headerlink" title="InnoDB：具备外键支持功能的事务存储引擎"></a>InnoDB：具备外键支持功能的事务存储引擎</h3><ul>
<li>MySQL从3.23.34a开始就包含InnoDB存储引擎，5.5之后，InnoDB成为默认的存储引擎。</li>
<li>InnoDB是MySQL的默认事务型引擎，被设计用来处理大量的短期（short-lived）事务。可以确保事务的完整提交（Commit）和回滚（Rollback）。</li>
<li>除了增加和查询外，还需要更新和删除操作，那么应优先选择InnoDB存储引擎。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</li>
<li>数据文件结构：<ul>
<li><code>表名.frm</code>：存储表结构(MySQL8.0时，合并在表名.ibd中)。</li>
<li><code>表名.ibd</code>：存储数据和索引。</li>
</ul>
</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。</li>
<li>对比MyISAM的存储引擎，InnoDB对写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li>
</ul>
<h3 id="MyISAM：主要的非事务处理存储引擎"><a href="#MyISAM：主要的非事务处理存储引擎" class="headerlink" title="MyISAM：主要的非事务处理存储引擎"></a>MyISAM：主要的非事务处理存储引擎</h3><ul>
<li>MyISAM是5.5之前默认的存储引擎，提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li>
<li>优势是访问的速度快，适合对事务完整性没有要求或者以SELECT、INSERT（只读）为主的应用。</li>
<li>针对数据统计有额外的常数存储。故而<code>count(*)</code>的查询效率很高。</li>
<li>数据文件结构：<ul>
<li><code>表名.frm</code>：存储表结构 </li>
<li><code>表名.MYD</code>：存储数据 (MYData) </li>
<li><code>表名.MYI</code>：存储索引 (MYIndex)</li>
</ul>
</li>
</ul>
<h3 id="Memory：置于内存的表"><a href="#Memory：置于内存的表" class="headerlink" title="Memory：置于内存的表"></a>Memory：置于内存的表</h3><ul>
<li>Memory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候 数据会丢失。</li>
<li>要求存储的数据是数据长度不变的格式，比如Blob和Text类型的数据就不可用(长度不固定的)。</li>
<li>同时支持哈希（HASH）和B+树索引。Memory表至少比MyISAM表要快一个数量级。</li>
<li>表的大小受到限制，主要取决于两个参数：<code>max_rows</code>和<code>max_heap_table_size</code>，前者在创建表时指定，后者大小默认16MB，可以按需扩大。</li>
<li>数据文件与索引文件分开存储。</li>
<li>适用于目标数据比较小而且非常频繁访问，或者数据是临时的而且必须立即可用，或者表中数据突然丢失也没太大关系的场景。</li>
</ul>
<h3 id="其他引擎"><a href="#其他引擎" class="headerlink" title="其他引擎"></a>其他引擎</h3><ul>
<li><code>Archive</code>：用于数据存档。</li>
<li><code>Blackhole</code>：丢弃写操作，读操作会返回空内容。</li>
<li><code>CSV</code>：存储数据时，以逗号分隔各个数据项。</li>
<li><code>Federated</code>：访问远程表。</li>
<li><code>Merge</code>：管理多个MyISAM表构成的表集合。</li>
<li><code>NDB</code>：MySQL集群专用存储引擎。</li>
</ul>
<h2 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h2><ol>
<li><strong>锁粒度</strong></li>
</ol>
<p><code>MyISAM</code>只有表级锁（table-level locking）；而<code>InnoDB</code>支持行级锁（row-level locking）和表级锁，默认为行级锁。</p>
<p>也就是说，<code>MyISAM</code>一锁就是锁住了整张表，这在并发写的情况下比<code>InnoDB</code>性能差太多。</p>
<ol start="2">
<li><strong>事务支持</strong></li>
</ol>
<p><code>MyISAM</code>不提供事务支持；<code>InnoDB</code>提供事务支持。</p>
<p><code>InnoDB</code>实现了SQL标准定义了四个隔离级别，具有提交（commit）和回滚（rollback）事务的能力。并且<code>InnoDB</code>默认使用的<code>REPEATABLE-READ</code>（可重读）隔离级别，是可以解决幻读问题发生的（基于<strong>MVCC</strong>和<strong>Next-Key Lock</strong>）。</p>
<ol start="3">
<li><strong>外键支持</strong></li>
</ol>
<p><code>MyISAM</code>不支持；<code>InnoDB</code>支持。</p>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<ol start="4">
<li><strong>数据库异常崩溃后的安全恢复</strong></li>
</ol>
<p><code>MyISAM</code>不支持；<code>InnoDB</code>支持。</p>
<p>使用<code>InnoDB</code>的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复的过程依赖于<strong>redo log</strong>。</p>
<ol start="5">
<li><strong>MVCC</strong></li>
</ol>
<p><code>MyISAM</code>不支持；<code>InnoDB</code>支持。</p>
<p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能，而<code>MyISAM</code>连行级锁都不支持。</p>
<ol start="6">
<li><strong>索引</strong></li>
</ol>
<p><code>MyISAM</code>和<code>InnoDB</code>引擎都使用<strong>B+Tree</strong>作为索引结构，但是两者的实现方式不太一样。</p>
<p><code>InnoDB</code>中，其数据文件本身就是索引文件，其表数据文件就是按B+Tree组织的一个索引结构，树的叶节点<code>data</code>域保存了完整的数据记录；<code>MyISAM</code>索引文件和数据文件是分离的。</p>
<h1 id="6-索引"><a href="#6-索引" class="headerlink" title="6 索引"></a>6 索引</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>MySQL官方对索引的定义为: <strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p>
<p>索引的本质是一种<strong>数据结构</strong>。可以简单理解为「排好序的快速查找数据结构」，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。</p>
<p>优点：</p>
<ul>
<li>提高数据检索效率，降低数据库I/O成本。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行的数据唯一性。</li>
<li>可以加速表和表之间的连接，即对于有依赖关系的子表和父表联合查询时可以提高查询速度。</li>
<li>使用分组和排序子句进行数据查询时，可以显著减少查询分组和排序的时间，降低了CPU的消耗。</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>除了数据表占数据空间之外，每一个索引也需要占磁盘空间，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，但同时却会降低更新表的更新速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ul>
<h2 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p><strong>Hash表</strong>是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近O(1)）。</p>
<p>能够通过key快速取出value的原因在于Hash算法，Hash算法实现了key到index的映射：</p>
<pre><code class="java">hash = hashfunc(key)
index = hash % array_size</code></pre>
<p>因为数组的大小有限，Hash算法不可避免存在Hash冲突的问题，也就是说多个不同的key最后得到的index相同。常用的解决办法是拉链法（链地址法）。链地址法就是将哈希冲突数据存放在链表中。就比如JDK 1.8之前HashMap就是通过链地址法来解决哈希冲突的，1.8以后HashMap为了减少链表过长时搜索时间过长引入了红黑树。</p>
<p>为了减少Hash冲突的发生，一个好的哈希函数应该尽可能“均匀地”将数据分布在整个哈希值集合中。</p>
<p>但是，MySQL并没有使用Hash表作为索引的底层数据结构，原因在于：</p>
<ul>
<li>Hash冲突问题的存在，但这不是主要问题。</li>
<li>Hash索引不支持顺序和范围查询！这是它最大的缺点。当我们要对表中的数据进行排序或者范围查找，Hash索引就不好使了。</li>
</ul>
<p>虽然MyISAM和InnoDB都没有使用Hash索引，但是Memory引擎使用的恰好是Hash索引。</p>
<h3 id="B树-amp-B-树"><a href="#B树-amp-B-树" class="headerlink" title="B树 &amp; B+树"></a>B树 &amp; B+树</h3><p><strong>B树</strong>也称B-树（Hyphen，不是减号），全称为多路平衡查找树，<strong>B+树</strong>是B树的一种变体。B树和B+树中的B是Balanced，平衡。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。</p>
<p>B树和B+树的异同：</p>
<ul>
<li>B树的所有节点既存放键(key) 也存放数据(data)；而B+树只有叶子节点存放key 和data，其他内节点只存放key。</li>
<li>B树的叶子节点都是独立的；B+树的叶子节点有指针指向与它相邻的叶子节点。</li>
<li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了；B+树的检索效率更稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>在MySQL中，<code>MyISAM</code>和<code>InnoDB</code>都是使用B+Tree作为索引结构，但是两者的实现方式不太一样。</p>
<p>MyISAM引擎中，数据和索引是分开存放的，B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录。即MyISAM中的索引是「非聚簇索引」。</p>
<p>InnoDB引擎中，数据即索引，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB 表数据文件本身就是主键索引，这被称为「聚簇索引」（或聚集索引）。而其余的索引都作为辅助索引（或二级索引，非聚簇索引），辅助索引的data域存储相应记录主键的值而不是地址（MyISAM存储的是地址值）。在根据主键索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引，此过程称为回表。因此，在设计表的时候不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂（频繁插入数据引起）。</p>
<h2 id="主键索引-amp-二级索引"><a href="#主键索引-amp-二级索引" class="headerlink" title="主键索引 &amp; 二级索引"></a>主键索引 &amp; 二级索引</h2><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><img src="images/image-20220609125835526.png" alt="image-20220609125835526" style="zoom:50%;" />

<p>数据表的主键列使用的就是主键索引。一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在InnoDB表中，当没有显式指定表的主键时，InnoDB会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6 Byte的自增主键。</p>
<h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><img src="images/image-20220609130007884.png" alt="image-20220609130007884" style="zoom:50%;" />

<p>二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<ul>
<li>唯一索引(Unique Key)：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li>普通索引(Index)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</li>
<li>前缀索引(Prefix)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>
<li>全文索引(Full Text)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql 5.6之前只有MyISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是联合索引，也叫组合索引或复合索引。比如想让B+树按照c1和c2列的大小进行排序：</p>
<ul>
<li>先把各个记录和页按照c1列进行排序。</li>
<li>在c1列相同的情况下，采用c2列进行排序。</li>
</ul>
<h2 id="聚簇索引-amp-非聚簇索引"><a href="#聚簇索引-amp-非聚簇索引" class="headerlink" title="聚簇索引 &amp; 非聚簇索引"></a>聚簇索引 &amp; 非聚簇索引</h2><h3 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h3><p>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</p>
<p>在MySQL中，InnoDB引擎的表的<code>.ibd</code>文件就包含了该表的索引和数据，该文件的底层数据结构就是B+树，将主键作为key组成索引，叶子结点存储的是完整的用户记录。</p>
<p>优点：</p>
<ul>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中。</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快，因为不用回表。</li>
<li>范围查找时，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，节省了大量的I/O操作。</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此对于InnoDB表，一般都会定义一个自增的ID列为主键。</li>
<li>更新主键的代价很高，因为将会导致被更新的行移动。因此对于InnoDB表，一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ul>
<h3 id="非聚簇索引（非聚集索引）"><a href="#非聚簇索引（非聚集索引）" class="headerlink" title="非聚簇索引（非聚集索引）"></a>非聚簇索引（非聚集索引）</h3><p>非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。</p>
<p>非聚集索引的叶子节点并不一定存放数据的指针（地址值），InnoDB表中二级索引的叶子节点存放的就是主键值，根据主键再回表到聚簇索引查数据。</p>
<p>优点：</p>
<ul>
<li>更新代价比聚集索引要小，因为非聚集索引的叶子节点是不存放数据的。</li>
</ul>
<p>缺点：</p>
<ul>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据，频繁插入会导致频繁页分裂带来开销。</li>
<li>可能会二次查询（回表）。当查到索引对应的指针或主键后，可能还需要根据指针或主键值再到数据文件或表中查询，这应该是非聚集索引最大的缺点了。</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>非聚簇索引不一定回表查询，比如用户使用SQL查询用户名，而用户名字段正好建立了索引。</p>
<pre><code class="sql">SELECT name FROM table WHERE name=&#39;guang19&#39;;</code></pre>
<p>这个索引的key本身就是<code>name</code>，查到对应的<code>name</code>直接返回就行了，无需回表查询。</p>
<p>即使是MyISAM也存在不需要回表的情况。虽然MyISAM的主键索引是非聚簇索引，data域存储的是指针即数据的地址偏移量，但当SQL查的就是主键本身时也不需要回表了。</p>
<pre><code class="sql">SELECT id FROM table WHERE id=1;</code></pre>
<p>上述情况称为<strong>覆盖索引</strong>：一个索引的key包含（或者说覆盖）所有需要查询的字段的值。覆盖索引的应用使得查询列与索引key对应时不需要再进行回表操作。</p>
<h2 id="MyISAM与InnoDB对比"><a href="#MyISAM与InnoDB对比" class="headerlink" title="MyISAM与InnoDB对比"></a>MyISAM与InnoDB对比</h2><p><code>MyISAM</code>的索引和文件是分开存储的，索引方式都是非聚簇的；<code>InnoDB</code>中索引即数据，按照B+树的结构根据主键建立了聚簇索引，同时叶子结点存储完整的用户记录。</p>
<ul>
<li>在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录；而在MyISAM中却需要进行一次「回表」操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</li>
<li>InnoDB的数据文件本身就是索引文件；而MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</li>
<li>InnoDB的非聚簇索引data域存储相应记录主键的值；而MyISAM索引记录的是地址。</li>
<li>MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的；反观InnoDB是通过获取主键值之后再去聚簇索引里搜索记录，虽然也不慢，但还是比不上直接用地址去访问。</li>
<li>InnoDB要求表必须有主键，MyISAM可以没有。</li>
</ul>
<h2 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h2><ol>
<li>选择合适的字段创建索引。</li>
</ol>
<p>不为NULL的字段：索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0, 1, true, false这样语义较为清晰的短值或短字符作为替代。</p>
<p>被频繁查询的字段：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p>被作为条件查询的字段：被作为WHERE条件查询的字段，应该被考虑建立索引。</p>
<p>频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
<p>被经常频繁用于连接的字段：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<ol start="2">
<li>被频繁更新的字段应该慎重建立索引。</li>
</ol>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<ol start="3">
<li>尽可能的考虑建立联合索引而不是单列索引。</li>
</ol>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<ol start="4">
<li>注意避免冗余索引。</li>
</ol>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如(name,city)和(name)这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<ol start="5">
<li>考虑在字符串类型的字段上使用前缀索引代替普通索引。</li>
</ol>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h1 id="7-事务"><a href="#7-事务" class="headerlink" title="7 事务"></a>7 事务</h1><p><strong>事务</strong>（transaction）：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p>事务的处理原则是保证事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有事务都被<code>commit</code>，使得这些修改就永久保存下来；要么放弃所作的所有更改，<code>rollback</code>到最初状态。</p>
<h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p><strong>ACID</strong>：</p>
<ul>
<li><p><strong>原子性atomicity</strong>：指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚到最初状态。</p>
</li>
<li><p><strong>一致性consistency</strong>：指事务执行前后，数据从一个「合法性状态」变换到另外一个「合法性状态」。这种状态是语义上的而不是语法上的，跟具体的业务有关，满足预定的约束的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束，转账必须转出账户减少，转入账户增加），满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。</p>
</li>
<li><p><strong>隔离性isolation</strong>：指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
</ul>
<p><img src="images/image-20220610091056527.png" alt="image-20220610091056527"></p>
<ul>
<li><strong>持久性durability</strong>：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。持久性是通过<strong>日志</strong>来保证的。日志包括了<strong>redo日志</strong>和<strong>undo日志</strong>。通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到redo日志中，然后再对数据库中对应的行进行修改。这样做的好处是即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的redo日志，重新执行，从而使事务具有持久性。</li>
</ul>
<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说A、I、D是手段，C是目的！</p>
<h2 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h2><p>MySQL根据事务操作所执行的不同阶段把事务大致划分成几个状态:</p>
<ul>
<li>活动的active：事务对应的数据库操作正在执行过程中。</li>
<li></li>
<li>部分提交的partially committed：当事务中的最后一个操作执行完成，但由于操作此时都在内存中执行，所造成的影响还没有刷新到磁盘。</li>
<li>失败的failed：事务处在<code>活动的</code>或<code>部分提交的</code>状态时，可能遇到某些错误，比如数据库自身的错误、操作系统错误或者直接断电等，从而无法继续执行，或者人为停止当前事务的执行。</li>
<li>终止的aborted：如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态，即撤销失败事务对当前数据库造成的影响。这个撤销的过程称之为<strong>回滚</strong>。当回滚操作执行完毕时，数据库就恢复到了执行事务之前的状态，我们就说该事务处在了<code>中止的</code>状态。</li>
<li>提交的committed：当一个处在<code>部分提交的</code>状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了<code>提交的</code>状态。</li>
</ul>
<h2 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h2><ol>
<li><strong>脏写(Dirty Write)</strong></li>
</ol>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，如果事务<code>Session A</code>修改了另一个未提交事务<code>Session B</code>修改过的数据，那就意味着发生了脏写。</p>
<ol start="2">
<li><strong>脏读(Dirty Read)</strong></li>
</ol>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，<code>Session A</code>读取了已经被<code>Session B</code>更新但还没有被提交的字段。之后若<code>Session B</code>回滚，<code>Session A</code>读取的内容就是临时且无效的。</p>
<p>比如<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>studentno</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>张三</code>，然后<code>Session A</code>中的事务再去查询这条<code>studentno</code>为<code>1</code>的记录，如果读到列<code>name</code>的值为<code>张三</code>，而<code>Session B</code>中的事务稍后进行了回滚，那么<code>Session A</code>中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。</p>
<ol start="3">
<li><strong>不可重复读(Non-Repeatable Read)</strong></li>
</ol>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，<code>Session A</code>读取了一个字段，然后<code>Session B</code>更新了该字段。之后<code>Session A</code>再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。<br>比如我们在<code>Session B</code>中提交了几个隐式事务 (隐式事务意味着语句结束事务就提交了)，这些事务都修改了<code>studentno</code>列为<code>1</code>的记录的列<code>name</code>的值，每次事务提交之后，如果Session A中的事务都可以读取查看到最新的值，这种现象也被称之为不可重复读 。</p>
<ol start="4">
<li><strong>幻读(Phantom Read)</strong></li>
</ol>
<p>对于两个事务<code>Session A</code>、<code>Session B</code>，<code>Session A</code>从一个表中读取了一个字段，然后 <code>Session B</code>在该表中插入了一些新的行。之后, 如果<code>Session A</code>再次读取同一个表，就会多出几行，那就意味着发生了幻读。</p>
<p>比如<code>Session A</code>中的事务先根据条件<code>studentno &gt; 0</code>这个条件查询表<code>student</code>，得到了<code>name</code>列值为<code>张三</code>的记录；之后<code>Session B</code>中提交了一个隐式事务，该事务向表<code>student</code>中插入了一条新记录；之后<code>Session A</code>中的事务再根据相同的条件<code>studentno &gt; 0</code>查询表<code>student</code>，得到的结果集中包含<code>Session B</code>中的事务新插入的那条记录，这种现象也被称之为幻读。我们把新插入的那些记录称之为幻影记录。</p>
<h2 id="SQL中的四种隔离级别"><a href="#SQL中的四种隔离级别" class="headerlink" title="SQL中的四种隔离级别"></a>SQL中的四种隔离级别</h2><p>上述的并发事务问题按严重程度排序：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读。</p>
<p>对于这些问题不同程度的解决也就是SQL标准中设立的4种<strong>隔离级别</strong>：</p>
<ol>
<li><code>READ UNCOMMITTED</code>：读未提交。在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</li>
<li><code>READ COMMITTED</code>：读已提交。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。可以避免脏读，但不可重复读、幻读问题仍然存在。</li>
<li><code>REPEATABLE READ</code>：可重复读。事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</li>
<li><code>SERIALIZABLE</code>：可串行化。确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</li>
</ol>
<p>脏写怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差。</p>
<h1 id="8-锁"><a href="#8-锁" class="headerlink" title="8 锁"></a>8 锁</h1><p>事务的隔离性由<strong>锁</strong>或<strong>MVCC</strong>来实现。在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源，为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL的各个隔离级别提供了保证，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>
<h2 id="并发事务访问相同记录的情况"><a href="#并发事务访问相同记录的情况" class="headerlink" title="并发事务访问相同记录的情况"></a>并发事务访问相同记录的情况</h2><h3 id="读-读情况"><a href="#读-读情况" class="headerlink" title="读-读情况"></a>读-读情况</h3><p><strong>读-读</strong>情况，即并发事务相继读取相同的记录，读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<h3 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a>写-写情况</h3><p><strong>写-写</strong>情况，即并发事务相继对相同的记录做出改动。在这种情况下会发生<strong>脏写</strong>的问题，任何一种隔离级别都不允许这种问题的发生。</p>
<p>所以在多个未提交事务相继对一条记录做改动时，需要让它们<strong>排队执行</strong>，这个排队的过程其实是通过<code>锁</code>来实现的。这个所谓的<code>锁</code>其实是一个内存中的结构，在事务执行前本来是没有<code>锁</code>的，也就是说一开始是没有<code>锁结构</code>和记录进行关联。当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候就会在内存中生成一个<code>锁结构</code>与之关联。比如，事务T1要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联:</p>
<p><img src="images/image-20220610120415057.png" alt="image-20220610120415057"></p>
<h3 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a>读-写或写-读情况</h3><p><strong>读-写</strong>或<strong>写-读</strong>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生脏读、不可重复读、幻读的问题。</p>
<p>各个数据库厂商对SQL标准的支持都可能不一样，比如MySQL在<code>REPEATABLE READ</code>隔离级别上就已经解决了<strong>幻读</strong>问题。</p>
<p>解决脏读、不可重复读、幻读这些问题其实有两种可选的解决方案:</p>
<ol>
<li>读操作利用<strong>多版本并发控制</strong>(MVCC ，下章讲解)，写操作进行加锁。</li>
<li>读、写操作都采用<strong>加锁</strong>的方式。</li>
</ol>
<p>采用MVCC方式的话，读-写操作彼此并不冲突；采用加锁方式的话，读-写操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用MVCC来解决读-写操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用加锁的方式执行。</p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="images/image-20220610120953750.png" alt="image-20220610120953750"></p>
<h2 id="从数据操作的类型划分：读锁、写锁"><a href="#从数据操作的类型划分：读锁、写锁" class="headerlink" title="从数据操作的类型划分：读锁、写锁"></a>从数据操作的类型划分：读锁、写锁</h2><p><strong>读锁</strong>：也称为<strong>共享锁</strong>，英文用<code>S</code>表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。</p>
<p><strong>写锁</strong>：也称为<strong>排他锁</strong>，英文用<code>X</code>表示。当前写操作没有完成前，它会阻断其他写锁和读锁，确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p>
<p>需要注意的是对于<code>InnoDB</code>引擎来说，读锁和写锁可以加在表上，也可以加在行上。</p>
<h2 id="从数据操作的粒度划分：表级锁、页级锁、行级锁"><a href="#从数据操作的粒度划分：表级锁、页级锁、行级锁" class="headerlink" title="从数据操作的粒度划分：表级锁、页级锁、行级锁"></a>从数据操作的粒度划分：表级锁、页级锁、行级锁</h2><p>表级锁和行级锁对比：</p>
<ul>
<li>表级锁：MySQL中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁。实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和InnoDB引擎都支持表级锁。</li>
<li>行级锁：MySQL中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的记录进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。只有InnoDB引擎支持表级锁。</li>
</ul>
<h3 id="表锁-Table-Lock"><a href="#表锁-Table-Lock" class="headerlink" title="表锁(Table Lock)"></a>表锁(Table Lock)</h3><ol>
<li><strong>表级别的S锁、X锁</strong></li>
</ol>
<p>MyISAM中锁粒度是在表级，表锁有两种模式，即<strong>表共享读锁</strong>(Table Read Lock)和<strong>表独占写锁</strong>(Table Write Lock)。</p>
<p>而InnoDB的锁粒度是在行级，在对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。</p>
<p>但是server层使用的一种称之为<strong>元数据锁</strong> (Metadata Locks，简称MDL)结构的存在，使得在对某个表执行一些诸如<code>ALTER TABLE</code>、<code>DROP TABLE</code>这类DDL语句时，其他事务对这个表并发执行诸如<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>的语句会发生阻塞；某个事务中对某个表执行<code>SELECT</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。</p>
<ol start="2">
<li><strong>意向锁 (intention lock)</strong></li>
</ol>
<p>InnoDB支持<strong>多粒度锁</strong>(multiple granularity locking)，它允许行级锁与表级锁共存，而<strong>意向锁</strong>就是其中的一种表锁，它被用来快速判断是否可以对表使用表锁。</p>
<p>比如事务T1和T2，T1给表中某一条记录加了X锁，如果T2此时试图在该表级别上应用S/X锁，在没有意向锁的情况下，T2需要遍历检查每个页或每条记录是否存在锁，效率低下；在意向锁存在的情况下，T1给记录加X锁时，InnoDB引擎自动给表加上了意向排它锁即IX锁，T2检查到这个IX锁的存在就阻塞了。</p>
<p>简单来说，意向锁就是InnoDB在用户给某一行记录上锁时，自动对更大一级空间，比如数据页或数据表加上的锁，告诉其他人这个页或表中已经有人上过相应的锁了。</p>
<p>意向锁分为两种：</p>
<ul>
<li><strong>意向共享锁</strong>(intention shared lock, IS)：事务有意向对表中的某些行加共享锁(S锁)，要获取某些行的<code>S锁</code>，必须先获得表的<code>IS锁</code>。</li>
<li><strong>意向排它锁</strong>(intention exclusive lock, IX)：事务有意向对表中的某些行加排他锁(X锁)，要获取某些行的<code>X锁</code>，必须先获得表的<code>IX锁</code>。</li>
</ul>
<p>注意：</p>
<ul>
<li>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB会先获取（添加）该数据行所在数据表的意向锁。</li>
<li>意向锁不会与行级的共享/排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。</li>
<li>但是在表级，除了IS锁与表级S锁兼容外，其余意向锁和S/X锁都是互斥关系。</li>
<li>意向锁在保证并发性的前提下，实现了行锁与表锁共存且满足事务隔离性的要求。</li>
</ul>
<ol start="3">
<li><strong>自增锁(AUTO-INC锁)</strong></li>
</ol>
<p>在使用MySQL过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性，<code>AUTO-INC锁</code>就是在使用含有<code>AUTO_INCREMENT</code>列的表中插入数据时需要获取的特殊的表级锁。执行<code>INSERT</code>语句时就先获取<code>AUTO-INC锁</code>，执行完再释放掉。</p>
<p>一个事务在持有<code>AUTO-INC锁</code>的过程中，其他事务的插入语句都要阻塞，从而保证分配的递增值是连续且不重复的，但显然也会降低并发性。InnoDB通过<code>innodb_autoinc_lock_mode</code>字段值来分别对应不同的锁定模式：</p>
<ul>
<li><code>innodb_autoinc_lock_mode = 0</code>(“传统”锁定模式)：所有类型的<code>INSERT</code>语句都要获得<code>AUTO-INC锁</code>才能进行插入。</li>
<li><code>innodb_autoinc_lock_mode = 1</code>(“连续”锁定模式)：对于“Simple inserts”(简单插入)，即通过<code>INSERT...VALUES()</code>语句的插入，因为插入数据条数已知，通过<code>mutex(轻量锁)</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁；对于“Bulk inserts” (批量插入)，即通过<code>INSERT...SELECT</code>语句的插入，因为插入数据条数未知，同一时刻还是只能有一条语句持有<code>AUTO-INC锁</code>。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>(“交错”锁定模式)：所有类型<code>INSERT</code>语句都不使用<code>AUTO-INC锁</code>，这是并发度最高的模式。自动递增值保证在所有并发执行的<code>INSERT</code>语句中是唯一且单调递增的，但是可能不是连续的。</li>
</ul>
<ol start="4">
<li><strong>元数据锁(Metadata Locks，简称MDL)</strong></li>
</ol>
<p><code>MDL</code>的作用是保证读写的正确性，解决DML和DDL操作的一致性问题，在访问表时会自动加上。</p>
<p>比如当一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>因此当对一个表做增删改查操作的时候，要加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<h3 id="InnoDB中的行锁"><a href="#InnoDB中的行锁" class="headerlink" title="InnoDB中的行锁"></a>InnoDB中的行锁</h3><ol>
<li><strong>记录锁(Record Locks)</strong></li>
</ol>
<p>记录锁也就是仅仅把一条记录锁上，对其他记录没有影响。官方的类型名称为<code>LOCK_REC_NOT_GAP</code>。</p>
<p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁; </li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<ol start="2">
<li><strong>间隙锁(Gap Locks)</strong></li>
</ol>
<p>MySQL在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上<code>记录锁</code>。</p>
<p>InnoDB提出了一种称之为Gap Locks的锁，官方的类型名称为<code>LOCK_GAP</code>，gap锁的提出就是为了防止插入幻影记录而提出的。</p>
<p><img src="images/image-20220610134450333.png" alt="image-20220610134450333"></p>
<ol start="3">
<li><strong>临键锁(Next-Key Locks)</strong></li>
</ol>
<p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB提出<code>Next-Key Locks</code>的锁，官方名称为<code>LOCK_ORDINARY</code>，简称为<code>next-key锁</code>。<code>Next-Key Locks</code>是在存储引擎InnoDB、事务级别在<code>REPEATABLE READ</code>的情况下使用的数据库锁，也是InnoDB默认的锁。</p>
<p>简而言之，<code>Next-Key Locks</code>就是记录锁和间隙锁的合体！</p>
<ol start="4">
<li><strong>插入意向锁(Insert Intention Locks)</strong></li>
</ol>
<p>一个事务在插入一条记录时需要判断插入位置是不是被别的事务加了<code>gap锁</code>，如果有的话，插入需要等待直到拥有这个gap锁的事务提交。</p>
<p>但是InnoDB还规定想要插入的事务在等待的时候也需要在内存中生成一个锁，表明事务想在某个间隙中插入新记录，只是现在处于等待状态。这种锁类型就称为<code>Insert Intention Locks</code>，官方名称<code>LOCK_INSERT_INTENTION</code>，称为<code>插入意向锁</code>。</p>
<p>插入意向锁本质是在插入记录前因为<code>INSERT</code>操作产生的一种一种<code>gap锁</code>，不是意向锁。事实上 插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁。</p>
<h3 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h3><p><strong>页锁</strong>就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录</p>
<p>使用页锁的时候会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销 介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行<strong>锁升级</strong>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h2 id="从对待锁的态度划分：乐观锁、悲观锁"><a href="#从对待锁的态度划分：乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分：乐观锁、悲观锁"></a>从对待锁的态度划分：乐观锁、悲观锁</h2><p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，这两种锁是两种看待数据并发的思维方式。需要注意的是，乐观锁和悲观锁并不是具体的锁，只是锁的设计思想。</p>
<h3 id="悲观锁-Pessimistic-Locking"><a href="#悲观锁-Pessimistic-Locking" class="headerlink" title="悲观锁(Pessimistic Locking)"></a>悲观锁(Pessimistic Locking)</h3><p><strong>悲观锁</strong>顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现对并发事务，从而保证数据操作的排它性。</p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞 直到它拿到锁(共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程)。</p>
<p>比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中synchronized和ReentrantLock等独占锁也是悲观锁思想的实现。</p>
<h3 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁(Optimistic Locking)"></a>乐观锁(Optimistic Locking)</h3><p><strong>乐观锁</strong>认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用<strong>版本号机制</strong>或者<strong>CAS机制</strong>（compare and swap）实现。</p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量 。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就使用了CAS机制实现乐观锁。</p>
<ol>
<li><strong>乐观锁的版本号机制</strong></li>
</ol>
<p>在表中设计一个版本号字段<code>version</code>，第一次读的时候会获取<code>version</code>字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version = version + 1 WHERE version = version</code>。此时如果已经有事务对这条数据进行了更改，修改就不会成功。</p>
<ol start="2">
<li><strong>乐观锁的时间戳机制</strong></li>
</ol>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。</p>
<h3 id="两种锁的适用场景"><a href="#两种锁的适用场景" class="headerlink" title="两种锁的适用场景"></a>两种锁的适用场景</h3><ul>
<li>乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁 问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止读-写和写-写的冲突。</li>
</ul>
<h1 id="9-MVCC"><a href="#9-MVCC" class="headerlink" title="9 MVCC"></a>9 MVCC</h1><p><strong>MVCC (Multiversion Concurrency Control)**，多版本并发控制。顾名思义，MVCC是</strong>通过数据行的多个版本管理来实现数据库的并发控制**。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h2 id="快照读-amp-当前读"><a href="#快照读-amp-当前读" class="headerlink" title="快照读 &amp; 当前读"></a>快照读 &amp; 当前读</h2><p>MVCC在InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写</code>冲突，做到即使有读写冲突时，也能做到<strong>不加锁</strong>，<strong>非阻塞并发读</strong>。</p>
<p>而这个读指的就是<strong>快照读</strong>，而非<strong>当前读</strong>。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<ol>
<li><strong>快照读</strong></li>
</ol>
<p>快照读又叫<strong>一致性读</strong>，读取的是快照数据。不加锁的简单的<code>SELECT</code>都属于快照读，即不加锁的非阻塞读。比如：</p>
<pre><code class="sql">SELECT * FROM player WHERE ...</code></pre>
<p>既然是基于多版本，那么<strong>快照读可能读到的并不一定是数据的最新版本</strong>，而有可能是之前的历史版本。快照读的前提是隔离级别不是<code>SERIALIZABLE</code>，<code>SERIALIZABLE</code>级别下的快照读会退化成当前读。</p>
<ol start="2">
<li><strong>当前读</strong></li>
</ol>
<p>当前读<strong>读取的是记录的最新版本</strong>(最新数据，而不是历史版本的数据)，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的<code>SELECT</code>，或者对数据进行增删改都会进行当前读。比如:</p>
<pre><code class="sql">SELECT * FROM student LOCK IN SHARE MODE; # 共享锁 
SELECT * FROM student FOR UPDATE; # 排他锁
INSERT INTO student values ... # 排他锁
DELETE FROM student WHERE ... # 排他锁
UPDATE student SET ... # 排他锁</code></pre>
<h2 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h2><p><img src="images/image-20220611115955692.png" alt="image-20220611115955692"></p>
<p>MySQL默认隔离级别是<code>REPEATABLE READ</code>，能解决脏读和不可重复读的问题，但是解决不了幻读问题，通过MVCC，可以在这个隔离级别下采用乐观锁的思想来解决幻读问题，代替行级锁，降低系统开销，提高并发度。</p>
<h2 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h2><p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p>
<ul>
<li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给<code>trx_id</code>隐藏列。</li>
<li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo log</code>中，然后隐藏列<code>roll_pointer</code>就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>每次对记录进行改动，都会记录一条<code>undo log</code>，每条<code>undo log</code>也都有一个<code>roll_pointer</code>属性(<code>INSERT</code>操作对应的<code>undo log</code>没有该属性，因为该记录并没有更早的版本)，可以将这些<code>undo log</code>都连起来，串成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值，每个版本中还包含生成该版本时对应的<code>事务id</code>。</p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p><strong>MVCC的实现依赖于：隐藏字段、Undo Log和ReadView</strong>。</p>
<p><code>ReadView</code>就是事务在使用MVCC机制进行快照读操作时产生的读视图，当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID（「活跃」指的是启动了还没提交）。</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p><code>ReadView</code>中主要包含4个重要内容:</p>
<ol>
<li><code>creator_trx_id</code>：创建这个ReadView的<code>事务ID</code>。<ul>
<li>只有在对表中的记录做改动时(<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>这些语句时)才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为<code>0</code>。</li>
</ul>
</li>
<li><code>trx_ids</code>：表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。</li>
<li><code>up_limit_id</code>：活跃的事务中最小的事务ID。</li>
<li><code>low_limit_id</code>：表示生成ReadView时系统中应该分配给下一个事务的id。low_limit_id是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</li>
</ol>
<h3 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ol>
<li>如果被访问版本的<code>trx_id</code> = ReadView中的<code>creator_trx_id</code>，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code> &lt; ReadView中的<code>up_limit_id</code>，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code> &gt;= ReadView中的<code>low_limit_id</code>，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code> &gt;= <code>up_limit_id</code> &amp;&amp; <code>trx_id</code> &lt; <code>low_limit_id</code>，那就需要判断一下<code>trx_id</code>属性值是不是在<code>trx_ids</code>列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ol>
<h2 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h2><p>当查询一条记录的时候，系统如何通过MVCC找到它:</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务ID;</li>
<li>获取ReadView;</li>
<li>查询得到的数据，然后与ReadView中的事务版本号进行比较;</li>
<li>如果不符合ReadView规则，就需要从Undo Log中获取历史快照;</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p>MVCC只能在读已提交和可重复读两个隔离级别下工作：</p>
<ul>
<li>在隔离级别为<code>READ COMMITTED</code>时，一个事务中的每一次SELECT查询都会重新获取一次ReadView。</li>
<li>当隔离级别为<code>REPEATABLE READ</code>时，就可以避免不可重复读，因为一个事务只在第一次SELECT的时候会获取一次ReadView，而后面所有的SELECT都会复用这个ReadView。</li>
</ul>
<h2 id="MVCC解决脏读"><a href="#MVCC解决脏读" class="headerlink" title="MVCC解决脏读"></a>MVCC解决脏读</h2><p>在隔离级别为<code>READ COMMITTED</code>时，一个事务中的每一次SELECT查询都会重新获取一次ReadView。</p>
<p>现在有两个事务id分别为<code>10</code>、<code>20</code>的事务在执行：</p>
<pre><code class="sql"># Transaction 10
BEGIN;
UPDATE student SET name=&quot;李四&quot; WHERE id=1; UPDATE student SET name=&quot;王五&quot; WHERE id=1;
# Transaction 20
BEGIN;
# 更新了一些别的表的记录 ...</code></pre>
<p>此刻，表student中id为<code>1</code>的记录得到的版本链表如下所示:</p>
<p><img src="images/image-20220611195455021.png" alt="image-20220611195455021"></p>
<p>假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行:</p>
<pre><code class="sql"># 使用READ COMMITTED隔离级别的事务 BEGIN;
# SELECT1:Transaction 10、20未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#39;张三&#39;</code></pre>
<p>之后，我们把事务id为<code>10</code>的事务提交一下:</p>
<pre><code class="sql"># Transaction 10
BEGIN;
UPDATE student SET name=&quot;李四&quot; WHERE id=1;
UPDATE student SET name=&quot;王五&quot; WHERE id=1; COMMIT;</code></pre>
<p>然后再到事务id为<code>20</code>的事务中更新一下表student中id为<code>1</code>的记录:</p>
<pre><code class="sql"># Transaction 20
BEGIN;
# 更新了一些别的表的记录
...
UPDATE student SET name=&quot;钱七&quot; WHERE id=1; 
UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</code></pre>
<p>此刻，表student中id为<code>1</code>的记录的版本链就长这样：</p>
<p><img src="images/image-20220611195739813.png" alt="image-20220611195739813"></p>
<p>然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p>
<pre><code class="sql"># 使用READ COMMITTED隔离级别的事务 BEGIN;
# SELECT1:Transaction 10、20均未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#39;张三&#39;
# SELECT2:Transaction 10提交，Transaction 20未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#39;王五&#39;</code></pre>
<h2 id="MVCC解决不可重复读"><a href="#MVCC解决不可重复读" class="headerlink" title="MVCC解决不可重复读"></a>MVCC解决不可重复读</h2><p>当隔离级别为<code>REPEATABLE READ</code>时，就可以避免不可重复读，因为一个事务只在第一次SELECT的时候会获取一次ReadView，而后面所有的SELECT都会复用这个ReadView。</p>
<p>比如，系统里有两个事务id分别为<code>10</code>、<code>20</code>的事务在执行:</p>
<pre><code class="sql"># Transaction 10
BEGIN;
UPDATE student SET name=&quot;李四&quot; WHERE id=1; UPDATE student SET name=&quot;王五&quot; WHERE id=1;
# Transaction 20
BEGIN;
# 更新了一些别的表的记录 ...</code></pre>
<p>此刻，表student中id为<code>1</code>的记录得到的版本链表如下所示：</p>
<p><img src="images/image-20220611195455021.png" alt="image-20220611195455021"></p>
<p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p>
<pre><code class="sql"># 使用REPEATABLE READ隔离级别的事务 BEGIN;
# SELECT1:Transaction 10、20未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#39;张三&#39;</code></pre>
<p>之后，我们把事务id为<code>10</code>的事务提交一下，就像这样：</p>
<pre><code class="sql"># Transaction 10
BEGIN;
UPDATE student SET name=&quot;李四&quot; WHERE id=1;
UPDATE student SET name=&quot;王五&quot; WHERE id=1; 
COMMIT;</code></pre>
<p>然后再到事务id为<code>20</code>的事务中更新一下表student中id为<code>1</code>的记录：</p>
<pre><code class="sql"># Transaction 20
BEGIN;
# 更新了一些别的表的记录
...
UPDATE student SET name=&quot;钱七&quot; WHERE id=1; 
UPDATE student SET name=&quot;宋八&quot; WHERE id=1;</code></pre>
<p>此刻，表student中id为<code>1</code>的记录的版本链就长这样：</p>
<p><img src="images/image-20220611195739813.png" alt="image-20220611195739813"></p>
<p>然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个id为<code>1</code>的记录，如下：</p>
<pre><code class="sql"># 使用REPEATABLE READ隔离级别的事务 BEGIN;
# SELECT1:Transaction 10、20均未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值为&#39;张三&#39;
# SELECT2:Transaction 10提交，Transaction 20未提交
SELECT * FROM student WHERE id = 1; # 得到的列name的值仍为&#39;张三&#39;</code></pre>
<h2 id="MVCC解决幻读"><a href="#MVCC解决幻读" class="headerlink" title="MVCC解决幻读"></a>MVCC解决幻读</h2><p>还是在<code>REPEATABLE READ</code>隔离级别下。假设现在表student中只有一条数据，数据内容中，主键<code>id=1</code>，隐藏的<code>trx_id=10</code>，它的undo log如下图：</p>
<p><img src="images/image-20220611200506256.png" alt="image-20220611200506256"></p>
<p>假设现在有事务A和事务B并发执行，事务A的事务id为<code>20</code>，事务B的事务id为<code>30</code>。</p>
<p>步骤1：事务A开始第一次查询数据，查询的SQL语句如下。</p>
<pre><code class="sql">select * from student where id &gt;= 1;</code></pre>
<p>在开始查询之前，MySQL会为事务A产生一个ReadView，此时ReadView内容如下：</p>
<pre><code>trx_ids = [20,30]
up_limit_id = 20 
low_limit_id = 31 
creator_trx_id = 20</code></pre>
<p>由于此时表student中只有一条数据，且符合<code>where id&gt;=1</code>条件，因此会查询出来。然后根据ReadView机制，发现该行数据的<code>trx_id=10</code>，小于事务A的ReadView里<code>up_limit_id</code>，这表示这条数据是事务A开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务A的第一次查询，能读取到一条数据，<code>id=1</code>。</p>
<p>步骤2:接着事务B(trx_id=30)，往表student中新插入两条数据，并提交事务。</p>
<pre><code class="sql"> insert into student(id,name) values(2,&#39;李四&#39;); 
 insert into student(id,name) values(3,&#39;王五&#39;);</code></pre>
<p>此时表student中就有三条数据了，对应的undo log如下：</p>
<p><img src="images/image-20220611200918415.png" alt="image-20220611200918415"></p>
<p>步骤3：接着事务A开启第二次查询，根据可重复读隔离级别的规则，此时事务A并不会再重新生成 ReadView。此时表student中的3条数据都满足<code>where id&gt;=1</code>的条件，因此会先查出来。然后根据ReadView机制，判断每条数据是不是都可以被事务A看到。</p>
<ul>
<li>首先<code>id=1</code>的这条数据，前面已经说过了，可以被事务 A 看到。</li>
<li>然后是<code>id=2</code>的数据，它的<code>trx_id=30</code>，此时事务A发现，这个值处于<code>up_limit_id</code>和<code>low_limit_id</code>之间，因此还需要再判断30是否处于<code>trx_ids</code>数组内。由于事务A的<code>trx_ids=[20,30]</code>，因此在数组内，这表示<code>id=2</code>的这条数据是与事务A在同一时刻启动的其他事务提交的，所以这条数据不能让事务A看到。</li>
<li>同理，<code>id=3</code>的这条数据，<code>trx_id</code>也为<code>30</code>，因此也不能被事务A看见。</li>
</ul>
<p><img src="images/image-20220611201203407.png" alt="image-20220611201203407"></p>
<p>结论：最终事务A的第二次查询，只能查询出<code>id=1</code>的这条数据，这和事务A的第一次查询的结果一样，因此没有出现幻读现象，所以因为MVCC的作用，在MySQL的<code>REPEATABLE READ</code>隔离级别下，也不存在幻读问题。</p>
<h1 id="10-日志"><a href="#10-日志" class="headerlink" title="10 日志"></a>10 日志</h1><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><strong>redo log</strong>重做日志：</p>
<ul>
<li>是一种事务日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li>是存储引擎层（InnoDB独有）生成的日志，记录的是物理级别上的页修改操作，比如页号、偏移量、写入了xx数据，主要为了保证数据的可靠性。</li>
</ul>
<h3 id="为什么需要redo-log？"><a href="#为什么需要redo-log？" class="headerlink" title="为什么需要redo log？"></a>为什么需要redo log？</h3><p>InnoDB以页为单位来管理存储空间，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer pool</code>之后才可以访问，所以变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页以一定频率刷入磁盘（checkpoint机制），通过缓冲池来优化CPU和磁盘I/O之间的速率鸿沟，保证整体性能。</p>
<p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发，而是master线程隔一段时间才去处理。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p>
<p>另一方面，事务包含持久性的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p>
<p>那么如何保证这个持久性呢? 一个简单的做法：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘。但是这个简单粗暴的做法有些问题：</p>
<ul>
<li>修改量与刷新磁盘工作严重不成比例：比如有时候仅仅修改了某个页面中的一个字节，InnoDB以页为单位刷新磁盘，默认页面大小16KB，刷新到磁盘的成本就不划算了。</li>
<li>随机I/O刷新较慢：一个事务包含多条语句，一条语句也可能修改多条页面，如果这些页面不相邻，意味着刷新到磁盘需要很多随机I/O，肯定比顺序I/O要慢。</li>
</ul>
<p>另一个解决思路：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。</p>
<ul>
<li>比如，某个事务将系统表空间中第10号页面中偏移量为100处的那个字节的值1改成2。我们只需要记录一下这条语句：将第0号表空间的10号页面的偏移量为100处的值更新为2。</li>
</ul>
<p>由此，InnoDB采用了WAL技术（Write-Ahead Logging），思想是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功。这里的日志就是redo log，当发生宕机且数据未刷新到磁盘的时候，可以通过redo log来恢复，保证ACID中的durability。</p>
<h3 id="优势和特点"><a href="#优势和特点" class="headerlink" title="优势和特点"></a>优势和特点</h3><p>优势：</p>
<ul>
<li>redo log降低了刷盘频率。</li>
<li>redo log占用的存储空间很小，刷盘速度快。</li>
</ul>
<p>特点：</p>
<ul>
<li>redo log是顺序写入磁盘的：执行事务过程中每执行一条语句就可能产生若干redo日志，这些日志按照产生顺序写入磁盘，也就是使用顺序I/O。</li>
<li>事务执行过程中，redo log不断记录：redo log跟bin log的区别在于redo log是存储引擎层产生的，而bin log是数据库层产生的。加入一个事务对表做10万行的记录插入，在这个过程中一直不断向redo log顺序记录，而bin log不会记录，直到事务提交才会一次写入bin log文件中。</li>
</ul>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol>
<li><strong>redo log buffer</strong>：保存在内存中，容易丢失。</li>
</ol>
<p>服务器启动时向操作系统申请一大片称之为redo log buffer的连续内存空间。通过参数<code>innodb_log_buffer_size</code>设置，默认16M，范围是1~4096M。</p>
<p>内部划分为若干个连续的redo log block，一个block占512字节。</p>
<ol start="2">
<li>redo log file：保存在硬盘中，是持久的。</li>
</ol>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>以一个UPDATE事务为例：</p>
<p><img src="images/image-20220612105753676.png" alt="image-20220612105753676"></p>
<ol>
<li>先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝。</li>
<li>生成一条redo log并写入redo log buffer，记录的是数据被修改后的值。</li>
<li>当事务commit时，将redo log buffer中的内容刷新到redo log file，对redo log file采用追加写的方式（Write-Ahead Log预先日志持久化，在持久化一个数据页之前，先将内存中相应的日志页持久化）。</li>
<li>定期将内存中修改的数据刷新到磁盘的数据库文件中。</li>
</ol>
<h3 id="刷盘策略"><a href="#刷盘策略" class="headerlink" title="刷盘策略"></a>刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以一定频率刷入到真正的redo log file中。这里的一定频率就由刷盘策略决定。</p>
<p>还要注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存（page cache）中去，这是现代操作系统为了提高文件写入效率做的一个优化，真正的写入时机会交给系统自己来决定。那么对于InnoDB来说实际还存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p>
<p>InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制commit提交事务时，如何将redo log buffer中的日志刷新到redo log file中。它支持三种策略:</p>
<ol>
<li>设置为<code>1</code>：表示每次事务提交时都将进行同步刷盘操作。这是默认值。<ul>
<li>只要事务提交成功，redo log记录就一定在磁盘里，不会有任何数据丢失；如果事务执行过程中MySQL宕机，事务没有commit，所以日志丢了也没关系，不影响事务的durability。</li>
<li>效率是最差的，但是建议使用。</li>
</ul>
</li>
</ol>
<p><img src="images/image-20220612110622226.png" alt="image-20220612110622226"> </p>
<ol start="2">
<li>设置为<code>2</code>：表示每次事务提交时都只把redo log buffer内容写入page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。<ul>
<li>只要事务提交成功，redo log buffer中的内容只写入page cache。</li>
<li>仅仅是MySQL挂了不会有数据丢失，但是操作系统宕机1s内的数据就丢失了，无法满足durability，但是效率最高。</li>
</ul>
</li>
</ol>
<p><img src="images/image-20220612110755663.png" alt="image-20220612110755663"></p>
<ol start="3">
<li>设置为<code>0</code>：表示每次事务提交时不进行刷盘操作。系统默认master thread每隔1s异步进行一次redo log的同步。<ul>
<li>MySQL宕机最多丢失1s内的事务。</li>
<li>是一种折中做法，I/O效率理论高于1，低于2，但也有丢失数据风险，不能保证durability。</li>
</ul>
</li>
</ol>
<p><img src="images/image-20220612110725380.png" alt="image-20220612110725380"></p>
<h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><p>硬盘上存储的redo log file不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的redo日志文件大小都是一样的。比如可以配置为一组4个文件，每个文件的大小是1GB，整个redo log日志文件组可以记录4G的内容。它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写。</p>
<p>在个日志文件组中还有两个重要的属性：</p>
<ul>
<li><code>write pos</code>：是当前记录的位置，一边写一边后移。</li>
<li><code>checkpoint</code>：是当前要擦除的位置，也是往后推移。</li>
</ul>
<p>每次刷盘redo log到日志文件组中，write pos位置就会后移更新；每次MySQL加载日志文件组恢复数据时，会清空加载过的redo log，并把checkpoint后移更新；write pos和checkpoint之间的还空着的部分可以用来写入新的redo log记录。</p>
<img src="images/11.png" alt="11" style="zoom: 80%;" />

<p>如果write pos追上checkpoint，表示日志文件组满了，这时候不能再写入新的redo log记录，MySQL得停下来清空一些记录，把checkpoint推进一下。</p>
<img src="images/12.png" alt="12" style="zoom:80%;" />

<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>undo log回滚日志：</p>
<ul>
<li>也是一种事务日志，回滚记录到某个特定版本，用来保证事务的原子性、一致性。</li>
<li>也是存储引擎层（InnoDB独有）生成的日志，记录的是逻辑操作，比如某一行数据进行了INSERT，那么undo log就记录一条与之相反的DELETE操作。</li>
<li>主要用于事务的回滚（undo log记录了每个操作的逆操作）和一致性非锁定读（undo log回滚记录到某个特定版本，即MVCC）。</li>
</ul>
<h3 id="如何理解undo-log？"><a href="#如何理解undo-log？" class="headerlink" title="如何理解undo log？"></a>如何理解undo log？</h3><p>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p>
<ul>
<li>情况一：事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误，甚至是突然断电导致的错误。</li>
<li>情况二：程序员可以在事务执行过程中手动输入ROLLBACK语句结束当前事务的执行。</li>
</ul>
<p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为rollback回滚，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合原子性要求。</p>
<p>比如，INSERT一条记录，至少要记录这条记录的主键，便于回滚时DELETE这条插入的记录；DELETE一条记录，至少要把记录内容记录下来，便于回滚时INSERT这条删除的记录；UPDATE一条记录，至少要把修改的内容记录下来，便于回滚时UPDATE回原来的内容。</p>
<p>此外，undo log也会产生redo log，因为undo log也需要持久性的保护。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li><strong>回滚数据</strong></li>
</ol>
<p>undo log是逻辑日志，只是将数据库逻辑地恢复为原来的样子，所有修改被逻辑性取消，但是数据结构和页在物理上和修改前可能并不完全一样。</p>
<ol start="2">
<li><strong>MVCC</strong></li>
</ol>
<p>undo log版本链结合行格式的隐藏列、MVCC提供的ReadView共同实现多版本并发控制。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ol>
<li>回滚段与undo页</li>
</ol>
<p>InnoDB对undo log的管理采用<strong>segment</strong>的方式，也就是每个回滚段记录了1024个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo page</code>的申请。</p>
<ol start="2">
<li><p>回滚段与事务</p>
<ul>
<li>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</li>
<li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li>
<li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</li>
<li>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</li>
<li>当事务提交时，InnoDB存储引擎会做以下两件事情: 将undo log放入列表中，以供之后的purge操作；判断undo log所在的页是否可以重用，若可以分配给下个事务使用。</li>
</ul>
</li>
<li><p>回滚段中的数据分类</p>
<ul>
<li>未提交的回滚数据(uncommitted undo information)：该数据关联的事务未被提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。</li>
<li>已经提交但未过期的回滚数据(committed undo information)：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间影响。</li>
<li>事务已经提交并过期的数据(expired undo information)：事务已经提交且数据保存时间超过undo retention参数指定的时间，属于已过期数据，回滚段满后，会优先覆盖这部分数据。</li>
</ul>
</li>
</ol>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><strong>binlog</strong>可以说是MySQL中比较重要的日志了，在日常开发及运维过程中，经常会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫作变更日志(update log)。它记录了数据库所有执行的DDL和DML等数据库更新事件的语句，但是不包含没有修改任何数据的语句(如数据查询语句select、show等)。</p>
<p>binlog的主要应用场景是数据恢复和数据复制。</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>binlog日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ol>
<li><strong>statement</strong></li>
</ol>
<p>记录的内容是SQL语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下：</p>
<p><img src="images/02-20220305234738688.png" alt="02-20220305234738688"></p>
<p>同步数据时，会执行记录的SQL语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<ol start="2">
<li><strong>row</strong></li>
</ol>
<p>为了解决上面的问题，需要指定记录格式为<code>row</code>，记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下：</p>
<p><img src="images/03-20220305234742460.png" alt="03-20220305234742460"></p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗I/O资源，影响执行速度。</p>
<ol start="3">
<li><strong>mixed</strong></li>
</ol>
<p>所以有了折中方案<code>mixed</code>，记录的内容是前两者的混合。MySQL会判断这条SQL语句是否可能引起数据不一致，如果是就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<strong>binlog cache</strong>，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<p>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p>可以通过<code>binlog_cache_size</code>参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。</p>
<p>binlog刷盘流程：</p>
<p><img src="images/04-20220305234747840.png" alt="04-20220305234747840"></p>
<ul>
<li>上图的<code>write</code>，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>上图的<code>fsync</code>，才是将数据持久化到磁盘的操作。</li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是0。</p>
<ul>
<li>为0的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。虽然性能得到提升，但是机器宕机，page cache里面的 binlog 会丢失。虽然性能得到提升，但是机器宕机，page cache里面的 binlog 会丢失。</li>
<li>为了安全起见，可以设置为1，表示每次提交事务都会执行fsync，就如同redo log同步刷盘。</li>
<li>最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</li>
</ul>
<h3 id="binlog与redo-log比较"><a href="#binlog与redo-log比较" class="headerlink" title="binlog与redo log比较"></a>binlog与redo log比较</h3><p>binlog和redo log都属于持久化的保证，但是侧重点不同。</p>
<ul>
<li>redo log是物理日志，记录内容是“在某个数据页上做了什么修改”；属于InnoDB存储引擎层产生的；redo log让InnoDB存储引擎拥有了崩溃恢复能力；redo log在事务执行过程中可以不断写入。</li>
<li>而binlog是逻辑日志，记录内容是语句的原始逻辑，类似于“给ID=2这一行的c段加1”；属于Server层；保证了MySQL集群架构的数据一致性；binlog只有在提交事务时才写入。</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="images/02-20220305234828662.png" alt="02-20220305234828662"></p>
<p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录，因此之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。</p>
<p><img src="images/03-20220305235104445.png" alt="03-20220305235104445"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将redo log的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>：</p>
<p><img src="images/04-20220305234956774.png" alt="04-20220305234956774"></p>
<p>使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p>
<p><img src="images/05-20220305234937243.png" alt="05-20220305234937243"></p>
<p>再看一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="images/06-20220305234907651.png" alt="06-20220305234907651"></p>
<p>并不会回滚事务，它会执行上图框中的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>
<h2 id="其他日志"><a href="#其他日志" class="headerlink" title="其他日志"></a>其他日志</h2><p>MySQL有6类日志分别为:</p>
<ul>
<li><strong>慢查询日志</strong>:记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li>
<li><strong>通用查询日志</strong>: 记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li>
<li><strong>错误日志</strong>: 记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</li>
<li><strong>二进制日志</strong>: 记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li>
<li><strong>中继日志</strong>: 用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li>
<li><strong>数据定义语句日志</strong>: 记录数据定义语句执行的元数据操作。</li>
</ul>
<h1 id="11-主从复制"><a href="#11-主从复制" class="headerlink" title="11 主从复制"></a>11 主从复制</h1><h2 id="中继日志-relay-log"><a href="#中继日志-relay-log" class="headerlink" title="中继日志(relay log)"></a>中继日志(relay log)</h2><p><strong>relay log</strong>只在主从服务器架构的<strong>从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取binlog的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫relay log。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p>
<p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下：</p>
<ul>
<li>文件名格式：<code>从服务器名-relay-bin.序号</code></li>
<li>还有一个索引文件：<code>从服务器名-relay-bin.index</code>，用来定位当前正在使用的中继日志。</li>
</ul>
<h2 id="如何提升数据库的并发能力？"><a href="#如何提升数据库的并发能力？" class="headerlink" title="如何提升数据库的并发能力？"></a>如何提升数据库的并发能力？</h2><ol>
<li><p>首先考虑的是优化SQL查询语句和索引，这是成本最小的方案。</p>
</li>
<li><p>其次，实际工作中，常将<strong>Redis</strong>作为缓存与MySQL配合使用，当有请求时，首先从缓存中进行查找，如果存在就取出，不存在再访问数据库，提升了读取的效率，也减少了对后端数据库的访问压力。</p>
</li>
</ol>
<p><img src="images/image-20220613100523252.png" alt="image-20220613100523252"></p>
<ol start="3">
<li>最后，一般对于数据库而言都是「读多写少」，也就是说对数据库读取数据的压力比较大，因此可以采取数据库集群方案，做<strong>主从架构</strong>，实现<strong>读写分离</strong>。但是主从架构本身也是有成本的。</li>
</ol>
<h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><ol>
<li><strong>读写分离</strong></li>
</ol>
<p><img src="images/image-20220613101057288.png" alt="image-20220613101057288"></p>
<ul>
<li>Master主库：写库，负责写入数据。</li>
<li>Slave从库：读库，负责读取数据。</li>
</ul>
<p>当主库进行更新时，会主动将数据复制到从库中，在客户端读取数据时，就会从从库中进行读取。</p>
<p>面对「读多写少」的场景，读写分离可以实现更高的并发访问，同时还能对服务器进行负载均衡，让不同的读请求按照策略均匀分发到不同的从服务器上，让读取更加顺畅。</p>
<ol start="2">
<li><strong>数据备份</strong></li>
</ol>
<p>通过主从复制将主库数据复制到从库上，实现了热备份机制，即在主库正常运行的情况下进行的备份，不会影响到服务。</p>
<ol start="3">
<li><strong>高可用</strong></li>
</ol>
<p>数据备份这种冗余机制使得当服务器出现宕机或故障情况下，可以切换到从服务器上，保证服务的正常运行。</p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>主从同步的原理就是基于binlog进行数据同步。在主从复制过程中，会基于3个线程来操作，一个主库线程，两个从库线程。</p>
<p><img src="images/image-20220613101628665.png" alt="image-20220613101628665"></p>
<ul>
<li><strong>binlog dump thread</strong>（二进制日志转储线程）：主库线程，当从库线程连接时，主库可以将binlog发送给从库，当主库读取binlog时，会在binlog上加锁，读取完成后，再将锁释放掉。</li>
<li><strong>I/O thread</strong>（从库I/O线程）：从库线程，连接到主库，向主库发送请求更新binlog。这时从库的I/O线程就可以读取到主库的binlog dump thread发送的binlog更新部分，并且拷贝到本地的relay log。</li>
<li><strong>SQL thread</strong>（从库SQL线程）：读取从库中的relay log，并且执行日志中的事件，将从库中的数据与主库保持同步。</li>
</ul>
<p>复制三步骤：</p>
<ol>
<li>Master将写操作记录到binlog；</li>
<li>Slave将Master的binlog events拷贝到它的relay log；</li>
<li>Slave重做relay log中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的，而且重启后从接入点开始复制。</li>
</ol>
<p>复制的原则：</p>
<ul>
<li>每个Slave只有一个Master。</li>
<li>每个Slave只能有一个唯一的服务器ID。</li>
<li>每个Master可以有多个Slave。</li>
</ul>
<p>复制的最大问题: <strong>延时</strong></p>
<h2 id="同步数据一致性问题"><a href="#同步数据一致性问题" class="headerlink" title="同步数据一致性问题"></a>同步数据一致性问题</h2><p>主从同步的要求：</p>
<ul>
<li>读库和写库的数据一致(最终一致)。</li>
<li>写数据必须写到写库。</li>
<li>读数据必须到读库(不一定)。</li>
</ul>
<h3 id="主从延迟"><a href="#主从延迟" class="headerlink" title="主从延迟"></a>主从延迟</h3><p>主从延迟是指主机数据更新完成到从机上的数据更新完成存在一定延迟的问题。</p>
<p>主从延迟的原因：</p>
<ul>
<li>在网络正常的时候，日志从主库传给从库所需的时间是很短的，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</li>
<li>主备延迟最直接的表现是，从库消费中继日志(relay log)的速度，比主库生产binlog的速度要慢。造成这个现象的原因可能是从库的机器性能比主库要差，从库的压力大，大事务（比如一次删除或插入太多数据）的执行。</li>
</ul>
<p>如何减少主从延迟：</p>
<ul>
<li>降低多线程大事务并发的概率，优化业务逻辑。</li>
<li>优化SQL，避免慢SQL，减少批量操作，建议写脚本以update-sleep这样的形式完成。</li>
<li>提高从库机器的配置，减少主库写binlog和从库读binlog的效率差。</li>
<li>尽量采用短链路，即主库和从库机器的距离尽量短，并提升端口带宽，减少binlog传输的网络延时。</li>
<li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li>
</ul>
<h3 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h3><p>进行主从同步的内容是binlog，它是一个文件，在进行网络传输和从机执行事务的过程中就一定会存在主从延迟，这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的不一致性问题。</p>
<p>如果读取数据也走主库，那么对数据进行更新的时候，可以对记录加写锁，这样在就不会发生数据不一致的情况。但这时从库的作用就只是备份数据，并没有起到读写分离，分担主库读压力的作用。</p>
<p>读写分离情况下，解决主从同步中数据不一致的问题，就是解决主从之间数据复制方式的问题，如果照数据一致性从弱到强来进行划分，有以下3种复制方式：</p>
<ol>
<li><strong>异步复制</strong></li>
</ol>
<p><img src="images/image-20220613104506615.png" alt="image-20220613104506615"></p>
<p>默认的方式。客户端提交commit之后，主库不需要等从库返回任何结果，而是直接将结果返回给客户端。好处是不会影响主库写的效率，但可能会存在主库宕机，binlog没有同步到从库的情况，此时主库和从库数据就不一致了，这时从机中选择一个作为新的主机，那么新主机就缺少了之前主机中已经提交的事务。所以这种复制模式下数据一致性是最弱的。</p>
<ol start="2">
<li><strong>半同步复制</strong></li>
</ol>
<p><img src="images/image-20220613104758765.png" alt="image-20220613104758765"></p>
<p>5.5之后开始支持半同步复制方式。原理是在客户端提交commit之后不直接将结果返回客户端，而是等待至少有一个从库接收到binlog并成功写入relay log后，再返回给客户端。好处是提高了数据的一致性，但是相比于异步复制至少增加了一个网络连接的延迟，降低了主库写的效率</p>
<p>5.7开始还增加了参数<code>rpl_semi_sync_master_wait_for_slave_count</code>，可以对应答从库的数量进行设置，默认值为1，表示只要有一个1从库响应了就可以返回给客户端。调大这个参数可以提升数据的一致性，但是也增加了主库等待从库响应的时间。</p>
<ol start="3">
<li><strong>组复制</strong></li>
</ol>
<p><img src="images/image-20220613175735717.png" alt="image-20220613175735717"></p>
<p>组复制技术，简称<strong>MGR</strong>(MySQL Group Replication)是MySQL在5.7版本中推出的一种新的数据复制技术，MGR将MySQL带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR是基于Paxos协议的，事实上，Paxos算法提出来之后就作为分布式一致性算法被广泛应用，比如Apache的ZooKeeper也是基于Paxos实现的。</p>
<p>首先我们将多个节点共同组成一个复制组，在执行读写(RW)事务的时候，需要通过一致性协议层 (Consensus层)的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”(对应Node 节点)的同意，大多数指的是同意的节点数量需要大于(N/2+1)，这样才可以进行提交，而不是原发起方一个说了算。而针对只读(RO)事务则不需要经过组内同意，直接COMMIT即可。</p>
<p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/">JavaGuide</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj">尚硅谷宋红康老师MySQL教程</a></p>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2023年01月01日 20:07</p>
        <p>原始链接： <a class="post-url" href="/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/" title="MySQL八股文">http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/</a></p>
        <footer>
            <a href="http://muquanrui.com">
                <img src="/images/logo.png" alt="MU Quanrui">
                MU Quanrui
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/&title=《MySQL八股文》 — Quanrui's Blog&pic=cover.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/&title=《MySQL八股文》 — Quanrui's Blog&source=Carpe diem." data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MySQL八股文》 — Quanrui's Blog&url=http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/&via=http://muquanrui.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://muquanrui.com/2022/06/04/Computer%20Science/Database/MySQL/MySQL%E5%85%AB%E8%82%A1%E6%96%87/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Computer-Science/" class="color2">Computer Science</a>
      
    <a href="/tags/Database/" class="color4">Database</a>
      
    <a href="/tags/MySQL/" class="color1">MySQL</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
        <div class= "post-toc-name">Table of Contents</div>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="post-toc-text">1 数据库基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98"><span class="post-toc-text">数据库、数据库管理系统、数据库系统、数据库管理员</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%83%E7%BB%84%E3%80%81%E7%A0%81%E3%80%81%E5%80%99%E9%80%89%E7%A0%81%E3%80%81%E4%B8%BB%E7%A0%81%E3%80%81%E5%A4%96%E7%A0%81%E3%80%81%E4%B8%BB%E5%B1%9E%E6%80%A7%E3%80%81%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7"><span class="post-toc-text">元组、码、候选码、主码、外码、主属性、非主属性</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E9%94%AE%E5%92%8C%E5%A4%96%E9%94%AE"><span class="post-toc-text">主键和外键</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94%EF%BC%9F"><span class="post-toc-text">为什么不推荐使用外键与级联？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ER%E5%9B%BE"><span class="post-toc-text">ER图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="post-toc-text">范式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="post-toc-text">存储过程</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-MySQL%E5%9F%BA%E7%A1%80"><span class="post-toc-text">2 MySQL基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CMySQL"><span class="post-toc-text">关系型数据库和MySQL</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#drop%E3%80%81delete%E4%B8%8Etruncate"><span class="post-toc-text">drop、delete与truncate</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="post-toc-text">字符集</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="post-toc-text">3 数据目录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MySQL%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="post-toc-text">MySQL文件目录</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MySQL%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="post-toc-text">MySQL系统自带数据库</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A1%A8%E5%9C%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="post-toc-text">表在文件系统中的表示</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">InnoDB存储引擎模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">MyISAM存储引擎模式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="post-toc-text">4 逻辑架构</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="post-toc-text">5 存储引擎</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">引擎介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InnoDB%EF%BC%9A%E5%85%B7%E5%A4%87%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="post-toc-text">InnoDB：具备外键支持功能的事务存储引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MyISAM%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9D%9E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="post-toc-text">MyISAM：主要的非事务处理存储引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Memory%EF%BC%9A%E7%BD%AE%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E8%A1%A8"><span class="post-toc-text">Memory：置于内存的表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E6%93%8E"><span class="post-toc-text">其他引擎</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MyISAM%E5%92%8CInnoDB"><span class="post-toc-text">MyISAM和InnoDB</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-%E7%B4%A2%E5%BC%95"><span class="post-toc-text">6 索引</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-text">索引底层数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Hash%E8%A1%A8"><span class="post-toc-text">Hash表</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#B%E6%A0%91-amp-B-%E6%A0%91"><span class="post-toc-text">B树 &amp; B+树</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-amp-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="post-toc-text">主键索引 &amp; 二级索引</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-Primary-Key"><span class="post-toc-text">主键索引(Primary Key)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="post-toc-text">二级索引(辅助索引)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="post-toc-text">联合索引</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-amp-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="post-toc-text">聚簇索引 &amp; 非聚簇索引</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="post-toc-text">聚簇索引（聚集索引）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="post-toc-text">非聚簇索引（非聚集索引）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="post-toc-text">覆盖索引</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MyISAM%E4%B8%8EInnoDB%E5%AF%B9%E6%AF%94"><span class="post-toc-text">MyISAM与InnoDB对比</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="post-toc-text">创建索引的注意事项</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-%E4%BA%8B%E5%8A%A1"><span class="post-toc-text">7 事务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ACID"><span class="post-toc-text">ACID</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="post-toc-text">事务状态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="post-toc-text">并发事务的问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SQL%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="post-toc-text">SQL中的四种隔离级别</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-%E9%94%81"><span class="post-toc-text">8 锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="post-toc-text">并发事务访问相同记录的情况</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BB-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="post-toc-text">读-读情况</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="post-toc-text">写-写情况</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="post-toc-text">读-写或写-读情况</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="post-toc-text">锁的分类</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="post-toc-text">从数据操作的类型划分：读锁、写锁</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="post-toc-text">从数据操作的粒度划分：表级锁、页级锁、行级锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A8%E9%94%81-Table-Lock"><span class="post-toc-text">表锁(Table Lock)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81"><span class="post-toc-text">InnoDB中的行锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%A1%B5%E9%94%81"><span class="post-toc-text">页锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="post-toc-text">锁升级</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="post-toc-text">从对待锁的态度划分：乐观锁、悲观锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81-Pessimistic-Locking"><span class="post-toc-text">悲观锁(Pessimistic Locking)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-Optimistic-Locking"><span class="post-toc-text">乐观锁(Optimistic Locking)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="post-toc-text">两种锁的适用场景</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#9-MVCC"><span class="post-toc-text">9 MVCC</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB-amp-%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="post-toc-text">快照读 &amp; 当前读</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%8D%E8%B0%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="post-toc-text">再谈隔离级别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E3%80%81Undo-Log%E7%89%88%E6%9C%AC%E9%93%BE"><span class="post-toc-text">隐藏字段、Undo Log版本链</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ReadView"><span class="post-toc-text">ReadView</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="post-toc-text">设计思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ReadView%E7%9A%84%E8%A7%84%E5%88%99"><span class="post-toc-text">ReadView的规则</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MVCC%E6%95%B4%E4%BD%93%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="post-toc-text">MVCC整体操作流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MVCC%E8%A7%A3%E5%86%B3%E8%84%8F%E8%AF%BB"><span class="post-toc-text">MVCC解决脏读</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MVCC%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="post-toc-text">MVCC解决不可重复读</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MVCC%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB"><span class="post-toc-text">MVCC解决幻读</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#10-%E6%97%A5%E5%BF%97"><span class="post-toc-text">10 日志</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#redo-log"><span class="post-toc-text">redo log</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81redo-log%EF%BC%9F"><span class="post-toc-text">为什么需要redo log？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BC%98%E5%8A%BF%E5%92%8C%E7%89%B9%E7%82%B9"><span class="post-toc-text">优势和特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%84%E6%88%90"><span class="post-toc-text">组成</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="post-toc-text">整体流程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="post-toc-text">刷盘策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#redo-log-file"><span class="post-toc-text">redo log file</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#undo-log"><span class="post-toc-text">undo log</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3undo-log%EF%BC%9F"><span class="post-toc-text">如何理解undo log？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="post-toc-text">作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="post-toc-text">存储结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#binlog"><span class="post-toc-text">binlog</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="post-toc-text">记录格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="post-toc-text">写入机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#binlog%E4%B8%8Eredo-log%E6%AF%94%E8%BE%83"><span class="post-toc-text">binlog与redo log比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="post-toc-text">两阶段提交</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E6%97%A5%E5%BF%97"><span class="post-toc-text">其他日志</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#11-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="post-toc-text">11 主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97-relay-log"><span class="post-toc-text">中继日志(relay log)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E8%83%BD%E5%8A%9B%EF%BC%9F"><span class="post-toc-text">如何提升数据库的并发能力？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="post-toc-text">主从复制的作用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="post-toc-text">主从复制原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="post-toc-text">同步数据一致性问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F"><span class="post-toc-text">主从延迟</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="post-toc-text">如何解决一致性问题</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2022/06/13/Programming/Middleware/Redis%E5%85%AB%E8%82%A1%E6%96%87/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Redis八股文
        
      </span>
    </a>
  
  
    <a href="/2022/05/28/Computer%20Science/Operating%20System/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPart5%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">操作系统Part5：设备管理</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="Computer Science/Database/MySQL/MySQL八股文" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyvaQ34l4';
        var conf = 'dfbc2f31fdc91ffc75e2035195b4426d';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    |
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
    <div class="theme-info">
</p>


      <span class="post-count">本站博文总字数：724.9k</span>
      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2018~2023 MU Quanrui<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!--加载prettify代码高亮js-->
  <script type="text/javascript" src="/google-code-prettify/prettify.js"></script>
  <script type="text/javascript">
    $(document).ready(function(){
      $('pre').addClass('prettyprint linenums');
      $('code').addClass('prettyprint');
      prettyPrint();
    })
  </script>

<script>
  var mihoConfig = {
      root: "http://muquanrui.com",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Blog/">Blog</a><a class="category-link" href="/categories/Data-Structures-Algorithms/">Data Structures & Algorithms</a><a class="category-link" href="/categories/Database/">Database</a><a class="category-link" href="/categories/ENSEEIHT/">ENSEEIHT</a><a class="category-link" href="/categories/Framework/">Framework</a><a class="category-link" href="/categories/Java-Project/">Java Project</a><a class="category-link" href="/categories/Java-Tutorial/">Java Tutorial</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/Methodology/">Methodology</a><a class="category-link" href="/categories/Middleware/">Middleware</a><a class="category-link" href="/categories/Network/">Network</a><a class="category-link" href="/categories/Operating-System/">Operating System</a><a class="category-link" href="/categories/Photography/">Photography</a><a class="category-link" href="/categories/Problem-Solving/">Problem Solving</a><a class="category-link" href="/categories/Software/">Software</a><a class="category-link" href="/categories/Tech-Note/">Tech Note</a><a class="category-link" href="/categories/macOS/">macOS</a><a class="category-link" href="/categories/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/">墓畔回忆录</a><a class="category-link" href="/categories/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/">我的大学</a><a class="category-link" href="/categories/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/">法语学习</a><a class="category-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 17.5px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">法语学习</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.88px;">读书笔记</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/categories">
                    <i class="fa fa-book"></i><span>Categories</span>
                </a>
            </li>
            
            <li>
                <a  href="/tags">
                    <i class="fa fa-tags"></i><span>Tags</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 17.5px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">法语学习</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.88px;">读书笔记</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>









  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400,"vOffset":-30},"mobile":{"show":false},"react":{"opacity":0.8},"log":false});</script></body>
</html>



