<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java基础八股文 | Quanrui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Quanrui's Blog" />
  
  <meta name="description" content="1 基础概念JVM vs JRE vs JDK  JVM  Java Virtual Machine（Java虚拟机）是一种能够执行Java bytecode的虚拟机，有针对不同操作系统的特定实现，目的是可以使用相同的字节码在不同的操作系统下都得到同样的运行结果，即所谓的“Write once, run anywhere”。 我们平时最常用的HotSpot VM只是JVM规范的一种实现，只要符合J">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础八股文">
<meta property="og:url" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Quanrui&#39;s Blog">
<meta property="og:description" content="1 基础概念JVM vs JRE vs JDK  JVM  Java Virtual Machine（Java虚拟机）是一种能够执行Java bytecode的虚拟机，有针对不同操作系统的特定实现，目的是可以使用相同的字节码在不同的操作系统下都得到同样的运行结果，即所谓的“Write once, run anywhere”。 我们平时最常用的HotSpot VM只是JVM规范的一种实现，只要符合J">
<meta property="og:locale">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/1626006585428.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/image-20220530073139955.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/java-value-passing-02.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/java-value-passing.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/shallow&deep-copy.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/types-of-exceptions-in-java.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/20190624122126398.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/1631609961612.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/7980749234585f364651f522f7e45c73.png.webp">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/java-collection-hierarchy.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/820406-20160529134155569-877986274.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/820406-20160529133801631-1126275604.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/jdk1.8%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/java8_concurrenthashmap.c9951bb5.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/treeify.webp">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/put%E6%96%B9%E6%B3%95.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/image-20200405151029416.49a48864.png">
<meta property="article:published_time" content="2022-05-02T12:16:26.000Z">
<meta property="article:modified_time" content="2023-01-01T12:00:39.497Z">
<meta property="article:author" content="MU Quanrui">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Java Tutorial">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/images/1626006585428.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  
<link rel="stylesheet" href="/css/style.css">


 <!--加载prettify代码高亮样式-->
<link href="/google-code-prettify/tranquil-heart.css" type="text/css" rel="stylesheet" />

  
<script src="/js/pace.min.js"></script>

  

  
  


  <!--加载条样式-->
  <style>
    .pace .pace-progress {
    	background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);
    	height: 3px;
    }
    .pace .pace-progress-inner {
     	box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
    	border-top-color: #1E92FB;	/*上边框颜色*/
    	border-left-color: #1E92FB;	/*左边框颜色*/
    }
  </style>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div id="background"></div><!--背景颜色/图片-->
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">

        <div id="header-menu" class="header-menu-pos animated">


<a target="_blank" rel="noopener" href="https://github.com/muquanrui" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FFA500; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Quanrui&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/categories">
                        <i class="fa fa-book"></i>
                        <span>Categories</span>
                    </a>
                    
                    <a  href="/tags">
                        <i class="fa fa-tags"></i>
                        <span>Tags</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Quanrui&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        Carpe diem.
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//muquanrui.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/muquanrui">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Google" target="_blank" href="//google.com">
                            <i class="fa fa-google fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Programming/Java Tutorial/Java基础/Java基础八股文" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      Java基础八股文
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Java-Tutorial/">Java Tutorial</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-05-02
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>          
        </li>
      </ul>
       <span class="post-count">文章字数:31.2k字 &nbsp &nbsp  
         阅读时长:125分钟</span>
    </div>
  
        
          
      </header>
    

    <div class="article-entry post-content" itemprop="articleBody">

    
    



      
            
            <h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念</h1><h2 id="JVM-vs-JRE-vs-JDK"><a href="#JVM-vs-JRE-vs-JDK" class="headerlink" title="JVM vs JRE vs JDK"></a>JVM vs JRE vs JDK</h2><p><img src="images/1626006585428.png" alt="img"></p>
<ol>
<li><strong>JVM</strong></li>
</ol>
<p>Java Virtual Machine（Java虚拟机）是一种能够执行Java bytecode的虚拟机，有针对不同操作系统的特定实现，目的是可以使用相同的字节码在不同的操作系统下都得到同样的运行结果，即所谓的“Write once, run anywhere”。</p>
<p>我们平时最常用的HotSpot VM只是JVM规范的一种实现，只要符合JVM规范，任何公司、组织或个人都可以开发自己的专属JVM。</p>
<ol start="2">
<li><strong>JRE</strong></li>
</ol>
<p>Java Runtime Environment（Java运行时环境）是运行已编译Java程序所需的内容集合，包括JVM，Java SE标准类库和其他一些基础构件。</p>
<ol start="3">
<li><strong>JDK</strong></li>
</ol>
<p>Java Development Kit是功能齐全的Java SDK，拥有JRE的一切，再加上编译器（javac）和其他的指令工具（比如javadoc），能够创建和编译程序。</p>
<h2 id="Java-bytecode"><a href="#Java-bytecode" class="headerlink" title="Java bytecode"></a>Java bytecode</h2><p>JVM可以理解的代码叫做<strong>Java字节码</strong>（即编译后生成的<code>.class</code>文件），它不面相任何特定的处理器或操作系统，只面向虚拟机，字节码一定程度上解决了解释性语言执行效率低的问题，又保留了解释性语言可以移植的特点。</p>
<p><img src="images/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png" alt="Java程序转变为机器代码的过程"></p>
<p>上图中**.class -&gt; 机器码**中，JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这也是传统解释性语言的特点，但是这样的执行速度相对比较慢。</p>
<p>事实上在程序中有些方法或代码块会被经常调用，这些代码段被称为<strong>热点代码</strong>，所以后面引进了JIT编译器（Just-In-Time Compilation），JIT属于运行时编译，第一次完成编译后会将字节码生成的机器码保存下来，下次可以直接使用，机器码的运行效率是高于Java解释器的，所以我们常说Java是编译与解释共存的语言。</p>
<h1 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2 基本语法"></a>2 基本语法</h1><h2 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h2><p>Java有8种基本数据类型：</p>
<ul>
<li><p>6种数字类型：</p>
<ul>
<li>4种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li><p>1种字符类型：<code>char</code></p>
</li>
<li><p>1种布尔型：<code>boolean</code>。</p>
</li>
</ul>
<p><img src="images/image-20220530073139955.png" alt="image-20220530073139955"></p>
<p><code>boolean</code>的位数在官方文档里没有明确定义，依赖于JVM厂商的具体实现，逻辑上理解为占用1位。</p>
<p>Java的<strong>每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化</strong>,这种所占存储空间大小的不变性是Java程序比用其他大多数语言编写的程序更具可移植性的原因之一。</p>
<h3 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h3><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。</p>
<p>基本类型和包装类型的主要区别是：</p>
<ul>
<li>作为成员变量的包装类型不赋值就是<code>null</code>，而基本类型有默认值。</li>
<li>包装类型可用于泛型，而基本类型不可。</li>
<li>基本数据类型的局部变量存放在Java虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被static修饰）存放在Java虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li>相比于对象类型，基本数据类型占用的空间非常小。</li>
</ul>
<p>为什么说是几乎所有对象实例呢？这是因为HotSpot虚拟机引入了JIT优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。</p>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p>Java基本数据类型的包装类型的大部分都用到了<strong>缓存机制</strong>来提升性能。</p>
<p><code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>这4种包装类默认创建了数值[-128，127]的相应类型的缓存数据，<code>Character</code>创建了数值在[0,127]范围的缓存数据，Boolean直接返回<code>True</code> or <code>False</code>。</p>
<p>两种浮点数类型的包装类<code>Float</code>, <code>Double</code>并没有实现缓存机制。</p>
<p>如果要使用超出对应范围值的包装类对象，构造器仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
<pre><code class="java">Integer i1 = 40; // 使用缓存对象
Integer i2 = new Integer(40); // 创建新对象
System.out.println(i1==i2); // 输出false</code></pre>
<p>因此，<strong>所有整型包装类对象之间值的比较，全部使用equals方法比较</strong>。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的包装类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型。</li>
</ul>
<pre><code class="java">Integer i = 10; // 装箱, Integer i = Integer.valueOf(10)
int n = i; // 拆箱, int n = i.intValue();</code></pre>
<p>装箱其实就是调用了包装类的<code>valueOf()</code>方法，拆箱其实就是调用了<code>xxxValue()</code>方法。</p>
<p>注意：如果频繁拆装箱的话，也会严重影响系统的性能，我们应该尽量避免不必要的拆装箱操作。</p>
<h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h2><p>形式：字符常量是单引号引起的一个字符，字符串常量是双引号引起的0个或若干个字符。</p>
<p>含义：字符常量相当于一个整型值(ASCII值)，可以参加表达式运算；字符串常量代表一个地址值(引用类型，表示该字符串在内存中存放位置)。<br>占内存大小：字符常量只占2个字节（char在Java中）；字符串常量占若干个字节。</p>
<h2 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h2><p>所谓可变长参数就是允许在调用方法时传入不定长度的参数。可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<pre><code class="java">public static void method2(String arg1, String... args) &#123;
   //......
&#125;</code></pre>
<p>遇到方法重载的情况，编译器会优先匹配固定参数而不是可变参数的方法。另外，Java的可变参数编译后实际会被转换成一个数组。</p>
<h2 id="为什么Java中只有值传递？"><a href="#为什么Java中只有值传递？" class="headerlink" title="为什么Java中只有值传递？"></a>为什么Java中只有值传递？</h2><h3 id="形参-amp-实参"><a href="#形参-amp-实参" class="headerlink" title="形参&amp;实参"></a>形参&amp;实参</h3><p>方法的定义可能会用到<strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>
<ul>
<li><strong>实参</strong>（实际参数）：用于传递给函数/方法的参数，必须有确定的值。</li>
<li><strong>形参</strong>（形式参数）：用于定义函数/方法，接收实参，不需要有确定的值。</li>
</ul>
<h3 id="值传递-amp-引用传递"><a href="#值传递-amp-引用传递" class="headerlink" title="值传递&amp;引用传递"></a>值传递&amp;引用传递</h3><p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如C++、Pascal)提供了两种参数传递的方式，不过，在Java中只有值传递。</p>
<h3 id="为什么Java只有值传递？"><a href="#为什么Java只有值传递？" class="headerlink" title="为什么Java只有值传递？"></a>为什么Java只有值传递？</h3><p>案例1：传递基本类型参数</p>
<pre><code class="java">public static void main(String[] args) &#123;
    int num1 = 10;
    int num2 = 20;
    swap(num1, num2);
    System.out.println(&quot;num1 = &quot; + num1);
    System.out.println(&quot;num2 = &quot; + num2);
&#125;

public static void swap(int a, int b) &#123;
    int temp = a;
    a = b;
    b = temp;
    System.out.println(&quot;a = &quot; + a);
    System.out.println(&quot;b = &quot; + b);
&#125;</code></pre>
<p>输出：</p>
<pre><code>a = 20
b = 10
num1 = 10
num2 = 20</code></pre>
<p>解析：</p>
<p>在<code>swap()</code>方法中，<code>a</code>、<code>b</code>的值进行交换，并不会影响到<code>num1</code>、<code>num2</code>。因为a、b的值，只是从num1、num2的复制过来的。也就是说a、b相当于num1、num2的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p>案例2：传递引用类型参数1</p>
<pre><code class="java">    public static void main(String[] args) &#123;
      int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;
      System.out.println(arr[0]);
      change(arr);
      System.out.println(arr[0]);
    &#125;

    public static void change(int[] array) &#123;
      // 将数组的第一个元素变为0
      array[0] = 0;
    &#125;</code></pre>
<p>输出：</p>
<pre><code>1
0</code></pre>
<p><img src="images/java-value-passing-02.png" alt="java-value-passing-02"></p>
<p>这里传递的还是值，不过，这个值是实参的地址！</p>
<p>也就是说<code>change()</code>的参数拷贝的是<code>arr</code>（实参）的地址，因此，它和arr指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p>案例3 ：传递引用类型参数2</p>
<pre><code class="java">public class Person &#123;
    private String name;
   // 省略构造函数、Getter&amp;Setter方法
&#125;

public static void main(String[] args) &#123;
    Person xiaoZhang = new Person(&quot;小张&quot;);
    Person xiaoLi = new Person(&quot;小李&quot;);
    swap(xiaoZhang, xiaoLi);
    System.out.println(&quot;xiaoZhang:&quot; + xiaoZhang.getName());
    System.out.println(&quot;xiaoLi:&quot; + xiaoLi.getName());
&#125;

public static void swap(Person person1, Person person2) &#123;
    Person temp = person1;
    person1 = person2;
    person2 = temp;
    System.out.println(&quot;person1:&quot; + person1.getName());
    System.out.println(&quot;person2:&quot; + person2.getName());
&#125;</code></pre>
<p>输出：</p>
<pre><code>person1:小李
person2:小张
xiaoZhang:小张
xiaoLi:小李</code></pre>
<p><img src="images/java-value-passing.png" alt="java-value-passing"></p>
<p><code>swap()</code>的参数<code>person1</code>和<code>person2</code>只是拷贝的实参<code>xiaoZhang</code>和<code>xiaoLi</code>的地址。因此，person1和person2的互换只是拷贝的两个地址的互换罢了，并不会影响到实参xiaoZhang和xiaoLi。</p>
<p>Java 中将实参传递给方法（或函数）的方式是 值传递 ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
<h1 id="3-面向对象"><a href="#3-面向对象" class="headerlink" title="3 面向对象"></a>3 面向对象</h1><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ol>
<li><strong>封装</strong>（encapsulation）：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</li>
<li><strong>继承</strong>（inheritance）：使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，同时也拥有父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间，提高我们的开发效率。<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
<li><strong>多态</strong>（Polymorphism）：一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系。</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定。</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法。</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ol>
<h2 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h2><ul>
<li>语法形式：成员变量在类中定义，而局部变量是在代码块、方法中定义的变量，或是方法的参数；成员变量可以被 <code>public</code>, <code>private</code>, <code>static</code>等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被<code>final</code>所修饰。</li>
<li>存储方式：如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于类的实例的；对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>生存时间：成员变量是类或对象的一部分，它随着类或对象的创建而存在；而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li>默认值：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（但是被<code>final</code>修饰的成员变量也必须显式地赋值），而局部变量则不会默认初始化，必须手动赋值后再进行使用。</li>
</ul>
<h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><ul>
<li><strong>重载</strong>（overload）就是同样的一个方法能够根据输入数据的不同，做出不同的处理。</li>
<li><strong>重写</strong>（override）就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法。</li>
</ul>
<p>重载：</p>
<ul>
<li>发生阶段：编译阶段</li>
<li>使用范围：同一个类（或父类与子类之间）</li>
<li>方法名：必须相同</li>
<li>返回类型：可以不同</li>
<li>访问修饰符：可以不同</li>
<li>参数列表：必须不同（即可以参数类型不同、个数不同、顺序不同）</li>
<li>异常：可以不同</li>
</ul>
<p>重写：</p>
<ul>
<li>发生阶段：运行阶段</li>
<li>使用范围：子类</li>
<li>方法名：必须相同</li>
<li>返回类型：小于等于父类</li>
<li>访问修饰符：大于等于父类</li>
<li>参数列表：必须相同</li>
<li>异常：小于等于父类</li>
</ul>
<p>对于重写，需要注意：</p>
<ul>
<li><p>遵循「<strong>两同两小一大</strong>」：「两同」即方法名相同、形参列表相同；「两小」指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类型应比父类方法声明抛出的异常类更小或相等；「一大」指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p>
</li>
<li><p>如果父类方法访问修饰符为<code>private</code>/<code>final</code>/<code>static</code>则子类就不能重写该方法。</p>
</li>
<li><p>构造方法无法被重写。</p>
</li>
</ul>
<p>此外，对于重写的返回值类型：</p>
<ul>
<li>如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。</li>
<li>但是如果方法的返回值是引用类型，重写时可以返回该引用类型的子类的。</li>
</ul>
<h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
<p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<h2 id="静态方法和实例方法的区别"><a href="#静态方法和实例方法的区别" class="headerlink" title="静态方法和实例方法的区别"></a>静态方法和实例方法的区别</h2><ol>
<li><strong>调用方式</strong></li>
</ol>
<p>在外部调用静态方法时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象.方法名</code>的方式，而实例方法只有后面这种方式。不过，需要注意的是一般不建议使用<code>对象.方法名</code>的方式来调用静态方法，这种方式非常容易造成混淆，事实上静态方法不属于类的某个对象而是属于这个类。</p>
<ol start="2">
<li><strong>访问类成员的限制</strong></li>
</ol>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h2 id="接口和抽象类的共同点和区别"><a href="#接口和抽象类的共同点和区别" class="headerlink" title="接口和抽象类的共同点和区别"></a>接口和抽象类的共同点和区别</h2><p>共同点：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8可以用<code>default</code>关键字在接口中定义默认方法）。</li>
</ul>
<p>区别：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为；抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类；但是一个类可以实现多个接口。</li>
<li>接口中的成员变量只能是<code>public static final</code>类型的，不能被修改且必须有初始值；而抽象类的成员变量可以有默认初始值，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<h2 id="深拷贝、浅拷贝、引用拷贝"><a href="#深拷贝、浅拷贝、引用拷贝" class="headerlink" title="深拷贝、浅拷贝、引用拷贝"></a>深拷贝、浅拷贝、引用拷贝</h2><p>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p>引用拷贝：两个不同的引用指向同一个对象。</p>
<p><img src="images/shallow&deep-copy.png" alt="shallow&amp;deep-copy"></p>
<h1 id="4-常用类"><a href="#4-常用类" class="headerlink" title="4 常用类"></a>4 常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><code>Object</code>类是所有类的父类，主要提供方法有：</p>
<pre><code class="java">/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class&lt;?&gt; getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable &#123; &#125;</code></pre>
<h3 id="和equals-的区别"><a href="#和equals-的区别" class="headerlink" title="==和equals()的区别"></a>==和equals()的区别</h3><p><code>==</code>对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型，<code>==</code>比较的是值。</li>
<li>对于引用数据类型，<code>==</code>比较的是对象的内存地址。</li>
</ul>
<p>Java只有值传递，所以其实对于<code>==</code>来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><code>equals()</code>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。</p>
<p><code>Object</code>类<code>equals()</code>方法：</p>
<pre><code class="java">public boolean equals(Object obj) &#123;
     return (this == obj);
&#125;</code></pre>
<p><code>equals()</code>方法存在两种使用情况：</p>
<ul>
<li>类没有重写：通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象，因为使用的默认是<code>Object</code>类<code>equals()</code>方法。</li>
<li>类重写了<code>equals()</code>方法 ：一般我们都重写equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回true。</li>
</ul>
<p>比如<code>String</code>中的equals方法是被重写过的，当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</p>
<p>String类equals()方法：</p>
<pre><code class="java">public boolean equals(Object anObject) &#123;
    if (this == anObject) &#123;
        return true;
    &#125;
    if (anObject instanceof String) &#123;
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) &#123;
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) &#123;
                if (v1[i] != v2[i])
                    return false;
                i++;
            &#125;
            return true;
        &#125;
    &#125;
    return false;
&#125;</code></pre>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p><code>hashCode()</code>的作用是获取<strong>hash code</strong>（int 整数），也称为散列码，作用是确定该对象在哈希表中的索引位置。</p>
<p>hashCode()定义在JDK的<code>Object</code>类中，这就意味着Java中的任何类都包含有hashCode()方法。另外需要注意的是Object的hashCode()方法是<code>native</code>方法，也就是用C语言或C++实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>
<p>散列表<strong>Hash Table</strong>存储的是<strong>键值对</strong>（key-value），它的特点是能根据key快速的检索出对应的value，使用原理就是hash code。</p>
<p><code>hashCode()</code>和<code>equals()</code>都是用于比较两个对象是否相等，<strong>为什么JDK还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如<code>HashMap</code>、<code>HashSet</code>）中，有了hashCode()之后，判断元素是否在对应容器中的效率会更高！比如《Head First Java》中写道：</p>
<blockquote>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同hashCode值的对象，这时会调用equals()方法来检查hashCode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p><strong>那为什么不只提供 hashCode() 方法呢？</strong></p>
<p>这是因为两个对象的hashCode值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的hashCode值，它们也不一定是相等的？</strong></p>
<p>因为hashCode()所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的hashCode)。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的hashCode值相等，那这两个对象不一定相等（可能是哈希碰撞）。</li>
<li>如果两个对象的hashCode值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li>
<li>如果两个对象的hashCode值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h3 id="什么重写equals-时必须重写hashCode-方法？"><a href="#什么重写equals-时必须重写hashCode-方法？" class="headerlink" title="什么重写equals()时必须重写hashCode()方法？"></a>什么重写equals()时必须重写hashCode()方法？</h3><p>因为按照hash code的使用规定：两个相等对象的hashCode值必须也相等。也就是说如果equals方法判断两个对象是相等的，那这两个对象的hashCode值也要相等。</p>
<p>但是如果重写equals()时没有重写hashCode()方法的话，就可能会导致equals方法判断是相等的两个对象，hashCode值却不相等。</p>
<p>因为此时hashCode是调用的父类即Object类中的hashCode()，该方法把对象在内存中的地址转换为int。</p>
<ul>
<li>比如创建了两个属性值相同的对象，它们的地址经过hashCode方法转换后生成了各自的hash code，且不相同；</li>
<li>在放入基于hash的容器比如HashSet中时，这两个逻辑上相同的对象因为hash code不相等就都被放入容器，显然是不符合规范的。</li>
</ul>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="String、StringBuffer、StringBuilder的区别？"><a href="#String、StringBuffer、StringBuilder的区别？" class="headerlink" title="String、StringBuffer、StringBuilder的区别？"></a>String、StringBuffer、StringBuilder的区别？</h3><ol>
<li><strong>可变性</strong></li>
</ol>
<p><code>String</code>是不可变的。</p>
<p><code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>也使用字符数组保存字符串，但没有使用<code>final</code>和<code>private</code>关键字修饰，因此内容是可改变的。</p>
<ol start="2">
<li><strong>线程安全性</strong></li>
</ol>
<p><code>String</code>中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p><code>AbstractStringBuilder</code>定义了一些字符串的基本操作，如<code>expandCapacity()</code>、<code>append()</code>、<code>insert()</code>、<code>indexOf()</code>，<code>StringBuffer</code>对这些方法加了同步锁，所以是线程安全的。<code>StringBuilder</code>并没有加同步锁，所以是非线程安全的。</p>
<ol start="3">
<li><strong>性能</strong></li>
</ol>
<p><code>String</code>是不可变的，每次对字符串内容进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。</p>
<p><code>StringBuffer</code>每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<code>StringBuilder</code>相比使用 StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。</p>
<p>对于三者使用的总结：</p>
<ul>
<li>操作少量的数据: 适用<code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用<code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用<code>StringBuffer</code></li>
</ul>
<h3 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h3><pre><code class="java">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;
    private final char value[];
    //...
&#125;</code></pre>
<p>String类中使用<code>final</code>关键字修饰字符数组来保存字符串，被final关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。但是final关键字修饰char数组并不是String不可变的根本原因，因为这里是final修饰引用类型变量的情况，虽然这个引用类型变量不能再指向其他对象，但是其内部元素却可以被修改。</p>
<p>String真正不可变的原因有：</p>
<ul>
<li>保存字符串的数组被<code>final</code>修饰且为<code>private</code>的，并且String类没有提供/暴露修改这个字符串的方法。</li>
<li>String类被final修饰导致其不能被继承，进而避免了子类破坏String的不可变性。</li>
</ul>
<p>补充：在Java 9之后，String、StringBuilder与StringBuffer的实现改用<strong>byte数组</strong>存储字符串。</p>
<pre><code class="java">public final class String implements java.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;
    // @Stable 注解表示变量最多被修改一次，称为“稳定的”。
    @Stable
    private final byte[] value;
&#125;

abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;
    byte[] value;
&#125;</code></pre>
<p>新版的String其实支持两个编码方案：<code>Latin-1</code>和<code>UTF-16</code>。如果字符串中包含的汉字没有超过Latin-1可表示范围内的字符，那就会使用Latin-1作为编码方案。Latin-1 编码方案下，byte占1个字节(8 位)，char占2个字节（16位），byte相较 char节省一半的内存空间。JDK官方表示绝大部分字符串对象只包含Latin-1就可编码的字符。如果字符串中包含的汉字超过Latin-1可表示范围内的字符，byte就和char所占用的空间是一样的了。</p>
<h3 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h3><p><strong>字符串常量池</strong>是JVM为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<pre><code class="java">// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = &quot;ab&quot;;
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = &quot;ab&quot;;
System.out.println(aa==bb); // true</code></pre>
<p><code>String s1 = new String(&quot;abc&quot;);</code>会创建 1 或 2 个字符串对象。这取决于常亮翅中是否存在”abc”这个对象的引用。</p>
<h3 id="intern方法有什么作用"><a href="#intern方法有什么作用" class="headerlink" title="intern方法有什么作用?"></a>intern方法有什么作用?</h3><p><code>String.intern()</code>是一个<strong>native</strong>方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<pre><code class="java">// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = &quot;Java&quot;;
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String(&quot;Java&quot;);
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true</code></pre>
<h3 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h3><pre><code class="java">String str1 = &quot;str&quot;;
String str2 = &quot;ing&quot;;
String str3 = &quot;str&quot; + &quot;ing&quot;;
String str4 = str1 + str2;
String str5 = &quot;string&quot;;
System.out.println(str3 == str4); // false
System.out.println(str3 == str5); // true
System.out.println(str4 == str5); // false</code></pre>
<p>对于编译期可以确定值的字符串，也就是常量字符串，jvm会将其存入字符串常量池。并且字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<p>在编译过程中，Javac编译器会进行一个叫做<strong>常量折叠</strong>（Constant Folding）的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）。</p>
<p>因此对于<code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code>编译器会优化成<code>String str3 = &quot;string&quot;;</code>。</p>
<p>但并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以，主要包括：</p>
<ul>
<li>基本数据类型以及字符串常量。</li>
<li>final修饰的基本数据类型变量或字符串变量。</li>
<li>字符串通过<code>+</code>拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）。</li>
</ul>
<p>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</p>
<p>对象引用和<code>+</code>的字符串拼接方式，实际上是通过<code>StringBuilder</code>调用<code>append()</code>方法实现的，拼接完成之后调用<code>toString()</code>得到一个String对象 。</p>
<pre><code class="java">String str4 = new StringBuilder().append(str1).append(str2).toString();</code></pre>
<p>我们在平时写代码的时候，尽量避免多个String对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用<code>StringBuilder</code>或<code>StringBuffer</code>。</p>
<p>不过字符串变量使用final关键字声明之后，可以让编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<pre><code class="java">final String str1 = &quot;str&quot;;
final String str2 = &quot;ing&quot;;
// 下面两个表达式其实是等价的
String c = &quot;str&quot; + &quot;ing&quot;; // 常量池中的对象
String d = str1 + str2;  // 常量池中的对象
System.out.println(c == d);// true</code></pre>
<p>如果，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<pre><code class="java">final String str1 = &quot;str&quot;;
final String str2 = getStr(); // 运行时才能确定的值
String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象
String d = str1 + str2; // 在堆上创建的新的对象
System.out.println(c == d);// false
public static String getStr() &#123;
      return &quot;ing&quot;;
&#125;</code></pre>
<h2 id="BigDecimal-详解"><a href="#BigDecimal-详解" class="headerlink" title="BigDecimal 详解"></a>BigDecimal 详解</h2><p><code>BigDecimal</code>可以实现对浮点数的运算，不会造成精度丢失。通常情况下大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code>来做的。</p>
<pre><code class="java">float a = 2.0f - 1.9f;
float b = 1.8f - 1.7f;
System.out.println(a);// 0.100000024
System.out.println(b);// 0.099999905
System.out.println(a == b);// false</code></pre>
<h3 id="为什么浮点数运算会有精度丢失风险？"><a href="#为什么浮点数运算会有精度丢失风险？" class="headerlink" title="为什么浮点数运算会有精度丢失风险？"></a>为什么浮点数运算会有精度丢失风险？</h3><p>这个和计算机保存浮点数的机制有很大关系。计算机是二进制的，而且计算机在表示一个数字时宽度是有限的，无限循环的小数存储在计算机时只能被截断，导致小数精度发生损失的情况。</p>
<p>就比如说十进制下的0.2就没办法精确转换成二进制小数：</p>
<pre><code>// 0.2转换为二进制数的过程是断乘以2，直到不存在小数为止，
// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。
0.2 * 2 = 0.4 -&gt; 0
0.4 * 2 = 0.8 -&gt; 0
0.8 * 2 = 1.6 -&gt; 1
0.6 * 2 = 1.2 -&gt; 1
0.2 * 2 = 0.4 -&gt; 0（发生循环）
...</code></pre>
<h3 id="BigDecimal的用处"><a href="#BigDecimal的用处" class="headerlink" title="BigDecimal的用处"></a>BigDecimal的用处</h3><p>《阿里巴巴Java开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。这是因为上述提到的精度丢失问题，解决办法是使用<code>BigDecimal</code>。</p>
<pre><code class="java">BigDecimal a = new BigDecimal(&quot;1.0&quot;);
BigDecimal b = new BigDecimal(&quot;0.9&quot;);
BigDecimal c = new BigDecimal(&quot;0.8&quot;);

BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);

System.out.println(x); /* 0.1 */
System.out.println(y); /* 0.1 */
System.out.println(Objects.equals(x, y)); /* true */</code></pre>
<h1 id="5-异常"><a href="#5-异常" class="headerlink" title="5 异常"></a>5 异常</h1><p><img src="images/types-of-exceptions-in-java.png" alt="types-of-exceptions-in-java"></p>
<h2 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a>Exception和Error有什么区别？</h2><p>在Java中，所有的异常都有一个共同的祖先<code>java.lang.Throwable</code>。<code>Throwable</code>类有两个重要的子类:</p>
<ul>
<li><code>Exception</code>：程序本身可以处理的异常，可以通过<code>catch</code>来进行捕获。Exception又可以分为Checked Exception（受检查异常，必须处理）和Unchecked Exception（不受检查异常，可以不处理）。</li>
<li><code>Error</code>：<code>Error</code>属于程序无法处理的错误 ，不建议通过catch捕获。例如Java虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择终止线程。</li>
</ul>
<h2 id="Checked-Exception和Unchecked-Exception有什么区别？"><a href="#Checked-Exception和Unchecked-Exception有什么区别？" class="headerlink" title="Checked Exception和Unchecked Exception有什么区别？"></a>Checked Exception和Unchecked Exception有什么区别？</h2><p><code>Checked Exception</code>（受检查异常）：Java代码在编译过程中，如果没有被<code>catch</code>或者<code>throws</code>关键字处理的话，就没办法通过编译。</p>
<ul>
<li>除了<code>RuntimeException</code>及其子类以外，其他的Exception类及其子类都属于受检查异常。</li>
<li>常见的受检查异常有：IO相关的异常、ClassNotFoundException、SQLException…。</li>
</ul>
<p><code>Unchecked Exception</code>（不受检查异常）：Java代码在编译过程中即使不处理也可以正常通过编译。RuntimeException及其子类都统称为非受检查异常，常见的有：</p>
<ul>
<li>NullPointerException(空指针错误)</li>
<li>IllegalArgumentException(参数错误比如方法入参类型错误)</li>
<li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li>
<li>ArrayIndexOutOfBoundsException（数组越界错误）</li>
<li>ClassCastException（类型转换错误）</li>
<li>ArithmeticException（算术错误）</li>
<li>SecurityException （安全错误比如权限不够）</li>
<li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
<h2 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h2><ul>
<li><code>String getMessage()</code>：返回异常发生时的简要描述。</li>
<li><code>String toString()</code>：返回异常发生时的详细信息。</li>
<li><code>String getLocalizedMessage()</code>：返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage()返回的结果相同。</li>
<li><code>void printStackTrace()</code>：在控制台上打印 Throwable 对象封装的异常信息。</li>
</ul>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><code>finally</code>：无论是否捕获或处理异常，finally块里的语句都会被执行。当在<code>try</code>块或<code>catch</code>块中遇到<code>return</code>语句时，finally语句块将在方法返回之前被执行。</p>
<p>注意：不要在finally语句块中使用<code>return</code>！</p>
<ul>
<li>当try语句和finally语句中都有return语句时，try语句块中的return语句会被忽略。这是因为try语句中的return返回值会先被暂存在一个本地变量中，当执行到finally语句中的return之后，这个本地变量的值就变为了finally语句中的return返回值。</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
    System.out.println(f(2));
&#125;

public static int f(int value) &#123;
    try &#123;
        return value * value;
    &#125; finally &#123;
        if (value == 2) &#123;
            return 0;
        &#125;
    &#125;
&#125;

// 输出：0</code></pre>
<p>事实上finally中的代码也不是一定会执行！在某些情况下，finally中的代码不会被执行，比如finally之前虚拟机被终止。</p>
<pre><code class="java">try &#123;
    System.out.println(&quot;Try to do something&quot;);
    throw new RuntimeException(&quot;RuntimeException&quot;);
&#125; catch (Exception e) &#123;
    System.out.println(&quot;Catch Exception -&gt; &quot; + e.getMessage());
    // 终止当前正在运行的Java虚拟机
    System.exit(1);
&#125; finally &#123;
    System.out.println(&quot;Finally&quot;);
&#125;

// 输出
// Try to do something
// Catch Exception -&gt; RuntimeException</code></pre>
<p>另外，在以下2种特殊情况下，finally块的代码也不会被执行：</p>
<ul>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h2 id="如何使用try-with-resources代替try-catch-finally？"><a href="#如何使用try-with-resources代替try-catch-finally？" class="headerlink" title="如何使用try-with-resources代替try-catch-finally？"></a>如何使用try-with-resources代替try-catch-finally？</h2><p>适用范围（资源的定义）：任何实现<code>java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code>的对象。</p>
<p>关闭资源和finally块的执行顺序：在<code>try-with-resources</code>语句中，任何catch或finally块在声明的资源关闭后运行。</p>
<pre><code class="java">// 读取文本文件的内容

// 使用try-catch-finally
Scanner scanner = null;
try &#123;
    scanner = new Scanner(new File(&quot;D://read.txt&quot;));
    while (scanner.hasNext()) &#123;
        System.out.println(scanner.nextLine());
    &#125;
&#125; catch (FileNotFoundException e) &#123;
    e.printStackTrace();
&#125; finally &#123;
    if (scanner != null) &#123;
        scanner.close();
    &#125;
&#125;

// 使用try-with-resources
try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123;
    while (scanner.hasNext()) &#123;
        System.out.println(scanner.nextLine());
    &#125;
&#125; catch (FileNotFoundException fnfe) &#123;
    fnfe.printStackTrace();
&#125;

// 如果有多个资源使用“;”分隔
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(&quot;test.txt&quot;)));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(&quot;out.txt&quot;)))) &#123;
    int b;
    while ((b = bin.read()) != -1) &#123;
        bout.write(b);
    &#125;
&#125;
catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre>
<h2 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h2><ul>
<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动new一个异常对象抛出。</li>
<li>抛出的异常信息一定要有意义。</li>
<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。</li>
<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>
<li>……</li>
</ul>
<h1 id="6-I-O"><a href="#6-I-O" class="headerlink" title="6 I/O"></a>6 I/O</h1><h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><p>方法 1：通过<code>Scanner</code></p>
<pre><code class="java">Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();</code></pre>
<p>方法 2：通过<code>BufferedReader</code></p>
<pre><code class="java">BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();</code></pre>
<h2 id="Java中I-O流分为几种"><a href="#Java中I-O流分为几种" class="headerlink" title="Java中I/O流分为几种?"></a>Java中I/O流分为几种?</h2><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系。Java IO流的40多个类都是从如下4个抽象类基类中派生出来的：</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><img src="images/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.jpeg" alt="IO-操作方式分类"></p>
<p><img src="images/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.jpeg" alt="IO-操作对象分类"></p>
<h2 id="I-O模型详解"><a href="#I-O模型详解" class="headerlink" title="I/O模型详解"></a>I/O模型详解</h2><p><strong>I/O</strong>（Input/Outpu） 即输入／输出。</p>
<p>先<strong>从计算机结构的角度</strong>来解读一下I/O。根据冯·诺依曼结构，计算机结构分为5大部分：运算器、控制器、存储器、输入设备、输出设备。</p>
<p><img src="images/20190624122126398.jpeg" alt="20190624122126398"></p>
<ul>
<li>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</li>
<li>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</li>
<li>从计算机结构的视角来看的话，I/O描述了计算机系统与外部设备之间通信的过程。</li>
</ul>
<p>再先<strong>从应用程序的角度</strong>来解读一下I/O。</p>
<ul>
<li>为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为用户空间（User space）和内核空间（Kernel space）。</li>
<li>平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说想要进行I/O操作，一定是要依赖内核空间的能力。</li>
<li>但是，用户空间的程序不能直接访问内核空间。</li>
<li>因此当想要执行I/O操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</li>
<li>应用程序对操作系统的内核发起I/O调用（系统调用），操作系统负责的内核执行具体的I/O操作。也就是说，我们的应用程序实际上只是发起了I/O操作的调用而已，具体I/O的执行是由操作系统的内核来完成的。</li>
</ul>
<p>当应用程序发起I/O调用后，会经历两个步骤：</p>
<ol>
<li>内核等待I/O设备准备好数据。</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<p>有哪些常见的I/O模型？<br>UNIX 系统下，I/O模型一共有5种：同步阻塞I/O、同步非阻塞I/O、I/O多路复用、信号驱动I/O和异步I/O。</p>
<h2 id="Java中3种常见I-O模型"><a href="#Java中3种常见I-O模型" class="headerlink" title="Java中3种常见I/O模型"></a>Java中3种常见I/O模型</h2><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h3><p><strong>BIO属于同步阻塞IO模型</strong>。</p>
<p>同步阻塞IO模型中，应用程序发起<code>read()</code>调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<p><img src="images/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image.png" alt="6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image"></p>
<p>在客户端连接数量不高的情况下，是没问题的。但是当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。因此需要一种更高效的I/O处理模型来应对更高的并发量。</p>
<h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h3><p>Java中的<strong>NIO</strong>于Java 1.4引入，对应<code>java.nio</code>包，提供了<code>Channel</code> ，<code>Selector</code>，<code>Buffer</code>等抽象。NIO中的N可以理解为N<strong>on-blocking</strong>，不单纯是New。它是支持面向缓冲的，基于通道的I/O操作方法，对于高负载、高并发的（网络）应用，应使用NIO。</p>
<p>Java中的NIO可以看作是<strong>I/O多路复用模型</strong>。也有很多人认为NIO属于同步非阻塞I/O模型。</p>
<p><img src="images/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image.png" alt="bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image"></p>
<p>同步非阻塞I/O模型中，应用程序会一直发起<code>read()</code>调用，这个期间如果数据还没准备好，该线程不会阻塞，直到数据就绪后，<code>read()</code>调用生效，开始把数据从内核空间拷贝到用户空间，这个过程线程会阻塞直到拷贝完成。</p>
<p>相比于同步阻塞I/O模型，同步非阻塞I/O模型确实有了很大改进：<strong>通过轮询操作，避免了一直阻塞</strong>。</p>
<p>但是这种I/O模型同样存在问题：应用程序不断进行I/O系统调用轮询数据是否已经准备好的<strong>过程十分消耗CPU资源</strong>。</p>
<p><img src="images/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image.png" alt="88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image"></p>
<p>I/O多路复用模型中，线程首先发起<code>select()</code>调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起<code>read()</code>调用，read调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<p>目前支持I/O多路复用的系统调用有<code>select()</code>，<code>epoll()</code>等等：</p>
<ul>
<li>select调用：内核提供的系统调用，它支持一次查询多个系统调用的可用状态，几乎所有的操作系统都支持。</li>
<li>epoll调用：linux 2.6内核，属于select调用的增强版本，优化了I/O的执行效率。</li>
</ul>
<p>I/O多路复用模型，通过减少无效的系统调用，减少了对CPU资源的消耗。</p>
<p>Java中的NIO，有一个非常重要的选择器<strong>Selector</strong>的概念，也可以被称为多路复用器。通过它，只需要一个线程便可以管理多个客户端连接，当客户端数据到了之后才会为其服务。</p>
<p><img src="images/0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image.png" alt="0f483f2437ce4ecdb180134270a00144~tplv-k3u1fbpfcp-watermark.image"></p>
<h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p><strong>AIO</strong>也就是NIO2，Java 7中引入，是异步I/O模型。</p>
<p>异步I/O是<strong>基于事件和回调机制实现</strong>的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="images/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image.png" alt="3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image"></p>
<p>目前来说AIO的应用还不是很广泛。Netty之前也尝试使用过 AIO不过又放弃了，这是因为Netty使用了AIO之后，在Linux系统上的性能并没有多少提升。</p>
<h2 id="Java序列化详解"><a href="#Java序列化详解" class="headerlink" title="Java序列化详解"></a>Java序列化详解</h2><h3 id="什么是序列化、反序列化"><a href="#什么是序列化、反序列化" class="headerlink" title="什么是序列化、反序列化?"></a>什么是序列化、反序列化?</h3><p>如果我们需要持久化Java对象比如将Java对象保存在文件中，或者在网络传输Java对象时，都需要用到序列化：</p>
<ul>
<li>序列化：将数据结构或对象转换成二进制字节流的过程。</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程。</li>
</ul>
<p>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</p>
<h3 id="Java序列化中如果有些字段不想进行序列化怎么办？"><a href="#Java序列化中如果有些字段不想进行序列化怎么办？" class="headerlink" title="Java序列化中如果有些字段不想进行序列化怎么办？"></a>Java序列化中如果有些字段不想进行序列化怎么办？</h3><p>对于不想进行序列化的变量，使用<code>transient</code>关键字修饰。</p>
<p><code>transient</code>关键字的作用是：</p>
<ul>
<li>阻止实例中那些用此关键字修饰的的变量序列化；</li>
<li>当对象被反序列化时，被transient修饰的变量值不会被恢复。</li>
</ul>
<p>关于<code>transient</code>还有几点注意：</p>
<ul>
<li><code>transient</code>只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code>修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰int类型，那么反序列后结果就是0。</li>
<li><code>static</code>变量因为不属于任何对象，所以无论有没有<code>transient</code>关键字修饰，均不会被序列化。</li>
</ul>
<h3 id="实际开发中有哪些用到序列化和反序列化的场景？"><a href="#实际开发中有哪些用到序列化和反序列化的场景？" class="headerlink" title="实际开发中有哪些用到序列化和反序列化的场景？"></a>实际开发中有哪些用到序列化和反序列化的场景？</h3><ul>
<li>对象在进行网络传输（比如远程方法调用RPC的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化。</li>
<li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li>
<li>将对象存储到缓存数据库（如Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li>
</ul>
<h3 id="常见序列化协议对比"><a href="#常见序列化协议对比" class="headerlink" title="常见序列化协议对比"></a>常见序列化协议对比</h3><p>JDK自带的序列化方式一般不会用，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有<strong>Hessian</strong>、<strong>Kyro</strong>、<strong>Protostuff</strong>。</p>
<p>下面提到的都是基于二进制的序列化协议，像<strong>JSON</strong>和<strong>XML</strong>这种属于文本类序列化方式，虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h3 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h3><p>JDK自带的序列化，只需实现<code>java.io.Serializable</code>接口即可。</p>
<pre><code class="java">@AllArgsConstructor
@NoArgsConstructor
@Getter
@Builder
@ToString
public class RpcRequest implements Serializable &#123;
    private static final long serialVersionUID = 1905122041950251207L;
    private String requestId;
    private String interfaceName;
    private String methodName;
    private Object[] parameters;
    private Class&lt;?&gt;[] paramTypes;
    private RpcMessageTypeEnum rpcMessageTypeEnum;
&#125;</code></pre>
<p>序列化号<code>serialVersionUID</code>的作用是版本控制。序列化的时候<code>serialVersionUID</code>也会被写入二级制序列，当反序列化时会检查<code>serialVersionUID</code>是否和当前类的<code>serialVersionUID</code>一致。如果<code>serialVersionUID</code>不一致则会抛出<code>InvalidClassException</code>异常。强烈推荐每个序列化类都手动指定其<code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的序列化号。</p>
<p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p>
<ul>
<li>不支持跨语言调用：如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li>性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ul>
<h1 id="7-反射"><a href="#7-反射" class="headerlink" title="7 反射"></a>7 反射</h1><p><strong>Reflection</strong>（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<p>相关API：</p>
<ul>
<li>java.lang.Class -&gt; 反射的源头</li>
<li>java.lang.reflect.Method</li>
<li>java.lang.reflect.Field</li>
<li>java.lang.reflect.Constructor</li>
<li>…</li>
</ul>
<h2 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h2><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>反射主要用来：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>实现动态代理。</li>
</ul>
<h2 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h2><ol>
<li>性能问题：反射包括了一些动态类型（多态，运行时才能确定其具体的类型），所以 JVM 无法对这些代码进行优化，因此反射操作的效率要比那些非反射操作低得多。</li>
<li>安全问题：由于反射允许代码执行一些在正常情况下不被允许的操作，比如访问私有的属性和方法，所以使用反射破坏了面向对象的封装特性，会产生安全问题。</li>
</ol>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><p><img src="images/1631609961612.png" alt="img"></p>
<ol>
<li>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。</li>
<li>接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。</li>
<li>加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。换句话说，Class的实例就对应着一个运行时类。</li>
<li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li>
</ol>
<h2 id="获取Class实例的几种方式"><a href="#获取Class实例的几种方式" class="headerlink" title="获取Class实例的几种方式"></a>获取Class实例的几种方式</h2><pre><code class="java">//方式一：调用运行时类的属性：.class
Class clazz1 = Person.class;
System.out.println(clazz1);

//方式二：通过运行时类的对象, 调用getClass()
Person p1 = new Person();
Class clazz2 = p1.getClass();
System.out.println(clazz2);

//方式三：调用Class的静态方法：forName(String classPath)
Class clazz3 = Class.forName(&quot;com.atguigu.java.Person&quot;);
// clazz3 = Class.forName(&quot;java.lang.String&quot;);
System.out.println(clazz3);
System.out.println(clazz1 == clazz2);
System.out.println(clazz1 == clazz3);

//方式四：使用类的加载器：ClassLoader  (了解)
ClassLoader classLoader = ReflectionTest.class.getClassLoader();
Class clazz4 = classLoader.loadClass(&quot;com.atguigu.java.Person&quot;);
System.out.println(clazz4);
System.out.println(clazz1 == clazz4);</code></pre>
<h2 id="代理模式和动态代理"><a href="#代理模式和动态代理" class="headerlink" title="代理模式和动态代理"></a>代理模式和动态代理</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p><strong>代理模式</strong>（Proxy Pattern）是常用的Java设计模式，特征是代理类与被代理类有同样的接口，代理类主要负责为被代理类预处理消息、过滤消息、把消息转发给被代理类，以及事后处理消息等。</p>
<p>代理类与被代理类之间通常会存在关联关系，一个代理类的对象与一个被代理类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用被代理类对象的相关方法，来提供特定的服务。 </p>
<p>代理模式在生活中很常见，比如明星都有经纪人，打官司要找律师，买房会找房产中介，这些都是代理模式的实例。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><img src="images/7980749234585f364651f522f7e45c73.png.webp" alt="7980749234585f364651f522f7e45c73.png"></p>
<ul>
<li>用户只关心接口功能，而不在乎谁提供了功能。比如上图中接口是<code>Subject</code>。</li>
<li>接口真正实现者即被代理类是上图的<code>RealSubject</code>，但是它不与用户直接接触，而是通过代理被用户使用。</li>
<li>代理类就是上图中的<code>Proxy</code>，由于它实现了<code>Subject</code>接口，所以它也能够直接与用户接触。</li>
<li>用户调用<code>Proxy</code>的时候，<code>Proxy</code>内部调用了<code>RealSubject</code>。所以<code>Proxy</code>是中介者，它还可以增强<code>RealSubject</code>操作。</li>
<li>代理又可以分为静态代理和动态代理两种。</li>
</ul>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>场景假设：电影是电影公司委托给影院进行播放的，但是影院可以在播放电影之前或之后，产生一些自己的经济收益，比如提供按摩椅，娃娃机，卖爆米花、饮料，在影片开始结束阶段都会播放广告等。</p>
<p>播放电影的接口：</p>
<pre><code class="java">public interface Movie &#123;
    void play();
&#125;</code></pre>
<p>实现了该接口，放映《美国队长》的被代理类：</p>
<pre><code class="java">public class CaptainAmericaMovie implements Movie &#123;
    @Override
    public void play() &#123;
        System.out.println(&quot;普通影厅正在播放的电影是《美国队长》&quot;);
    &#125;
&#125;</code></pre>
<p>实现了该接口，电影院放映电影的代理类：</p>
<pre><code class="java">public class MovieStaticProxy implements Movie &#123;
    Movie movie;

    public MovieStaticProxy(Movie movie) &#123;
        this.movie = movie;
    &#125;

    @Override
    public void play() &#123;
        playStart();
        movie.play();
        playEnd();
    &#125;

    public void playStart() &#123;
        System.out.println(&quot;电影开始前正在播放广告&quot;);
    &#125;
    public void playEnd() &#123;
        System.out.println(&quot;电影结束了，接续播放广告&quot;);
    &#125;
&#125;</code></pre>
<p>测试类：</p>
<pre><code class="java">public class StaticProxyTest &#123;
    public static void main(String[] args) &#123;
        Movie captainAmericaMovie = new CaptainAmericaMovie();
        Movie movieStaticProxy = new MovieStaticProxy(captainAmericaMovie);
        movieStaticProxy.play();
    &#125;
&#125;</code></pre>
<p>运行结果：</p>
<pre><code>电影开始前正在播放广告
正在播放的电影是《美国队长》
电影结束了，接续播放广告</code></pre>
<p>通过上述过程可以发现<strong>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强</strong>。值得注意的是，<strong>代理类和被代理类应该共同实现一个接口，或者是共同继承某个类</strong>。</p>
<p>之所以称为静态代理，是因为在代理类中指定了实现的接口和使用的对象类型，比如上面的<code>Movie</code>,这个类型是实现约定好的。</p>
<p>优点：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。</li>
<li>代理对象可以扩展目标对象的功能。</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。</li>
</ul>
<p>缺点：</p>
<ul>
<li>代理对象需要与被代理对象实现一样的接口，意味着不同的接口就要对应不同的代理类，导致出现很多代理类。同时，一旦接口增加方法，代理类与被代理类都要维护，十分繁琐。</li>
</ul>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>与静态代理类对照的是<strong>动态代理</strong>类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。</p>
<p>动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。<code>java.lang.reflect</code>包中的 <code>Proxy</code>类和<code>InvocationHandler</code>接口提供了生成动态代理类的能力。 </p>
<p>场景假设：刚看完《美国队长》不过瘾，还想继续去看一场《钢铁侠》。一直在普通影厅看电影觉得没啥意思，选择去VIP影厅体验一把。</p>
<p>VIP影厅播放电影的接口：</p>
<pre><code class="java">public interface VIPMovie &#123;
    void vipPlay();
&#125;</code></pre>
<p>VIP影厅播放《钢铁侠》的被代理类：</p>
<pre><code class="java">public class IronManVIPMovie implements VIPMovie &#123;
    @Override
    public void vipPlay() &#123;
        System.out.println(&quot;VIP影厅正在播放的电影是《钢铁侠》&quot;);
    &#125;
&#125;</code></pre>
<p>创建用来实现动态代理的Invocation Handler：</p>
<pre><code class="java">public class MyInvocationHandler implements InvocationHandler &#123;

    private Object object;

    public MyInvocationHandler(Object object) &#123;
        this.object = object;
    &#125;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        playStart();
        Object invoke = method.invoke(object, args);
        playEnd();
        return invoke;
    &#125;

    public void playStart() &#123;
        System.out.println(&quot;电影开始前正在播放广告&quot;);
    &#125;
    public void playEnd() &#123;
        System.out.println(&quot;电影结束了，接续播放广告&quot;);
    &#125;
&#125;</code></pre>
<p>测试类：（为了体现此时代理的动态性，我们可以用同样的Invocation Handler再看一遍之前普通影厅播放的美国队长）</p>
<pre><code class="java">public class DynamicProxyTest &#123;
    public static void main(String[] args) &#123;
        // VIP 影厅《钢铁侠》
        IronManVIPMovie ironManVIPMovie = new IronManVIPMovie();
        InvocationHandler invocationHandler = new MyInvocationHandler(ironManVIPMovie);
        VIPMovie dynamicProxy = (VIPMovie) Proxy.newProxyInstance(IronManVIPMovie.class.getClassLoader(), 
                                                                  IronManVIPMovie.class.getInterfaces(), 
                                                                  invocationHandler);
        dynamicProxy.vipPlay();

        // 普通影厅《美国队长》
        CaptainAmericaMovie captainAmericaMovie = new CaptainAmericaMovie();
        InvocationHandler invocationHandler1 = new MyInvocationHandler(captainAmericaMovie);
        Movie dynamicProxy1 = (Movie) Proxy.newProxyInstance(CaptainAmericaMovie.class.getClassLoader(), 
                                                             CaptainAmericaMovie.class.getInterfaces(), 
                                                             invocationHandler1);
        dynamicProxy1.play();
    &#125;
&#125;</code></pre>
<p>输出结果：</p>
<pre><code>电影开始前正在播放广告
VIP影厅正在播放的电影是《钢铁侠》
电影结束了，接续播放广告
电影开始前正在播放广告
正在播放的电影是《美国队长》
电影结束了，接续播放广告</code></pre>
<p>通过<code>Proxy.newProxyInstance()</code>方法，产生了Movie和VIPMovie两种接口实现类代理。<code>Proxy</code>是动态代理实现的关键，在生成代理类之前加上下面的代码可以查看通过反射动态生成的代理类：</p>
<pre><code class="java">public static void main(String[] args) &#123;
    System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);
    // VIP 影厅《钢铁侠》
    ...
    // 普通影厅《美国队长》
    ...
    System.out.println(&quot;VIP 影厅《钢铁侠》代理类：&quot;+dynamicProxy.getClass());
    System.out.println(&quot;普通影厅《美国队长》：&quot;+dynamicProxy1.getClass());
&#125;</code></pre>
<p>输出：</p>
<pre><code>IP 影厅《钢铁侠》代理类：class com.sun.proxy.$Proxy0
普通影厅《美国队长》：class com.sun.proxy.$Proxy1</code></pre>
<p>通过IDEA反编译查看生成的代理类<code>$Proxy0</code>内容：</p>
<pre><code class="java">public final class $Proxy0 extends Proxy implements VIPMovie &#123;
    private static Method m1;
    private static Method m3;
    private static Method m2;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  &#123;
        super(var1);
    &#125;

    public final void vipPlay() throws  &#123;
        try &#123;
            super.h.invoke(this, m3, (Object[])null);
        &#125; catch (RuntimeException | Error var2) &#123;
            throw var2;
        &#125; catch (Throwable var3) &#123;
            throw new UndeclaredThrowableException(var3);
        &#125;
    &#125;

    public final boolean equals(Object var1) throws  &#123;
        try &#123;
            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);
        &#125; catch (RuntimeException | Error var3) &#123;
            throw var3;
        &#125; catch (Throwable var4) &#123;
            throw new UndeclaredThrowableException(var4);
        &#125;
    &#125;

    public final String toString() throws  &#123;
        try &#123;
            return (String)super.h.invoke(this, m2, (Object[])null);
        &#125; catch (RuntimeException | Error var2) &#123;
            throw var2;
        &#125; catch (Throwable var3) &#123;
            throw new UndeclaredThrowableException(var3);
        &#125;
    &#125;

    public final int hashCode() throws  &#123;
        try &#123;
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        &#125; catch (RuntimeException | Error var2) &#123;
            throw var2;
        &#125; catch (Throwable var3) &#123;
            throw new UndeclaredThrowableException(var3);
        &#125;
    &#125;

    static &#123;
        try &#123;
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));
            m3 = Class.forName(&quot;com.workit.demo.proxy.VIPMovie&quot;).getMethod(&quot;vipPlay&quot;);
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);
        &#125; catch (NoSuchMethodException var2) &#123;
            throw new NoSuchMethodError(var2.getMessage());
        &#125; catch (ClassNotFoundException var3) &#123;
            throw new NoClassDefFoundError(var3.getMessage());
        &#125;
    &#125;
&#125;,</code></pre>
<p>第一行<code>$Proxy0 extends Proxy implements VIPMovie</code>表示该代理类继承了<code>Proxy</code>且实现了<code>VIPMovie</code>接口，因为Java是单继承的，所以JDK动态代理才必须基于接口。</p>
<p>实现方法<code>vipPlay()</code>中的<code>supper.h.invoke Proxy</code>中的h的invoke方法，即<code>InvocationHandler.invoke</code>也就是上面 <code>MyInvocationHandler.invoke</code>方法。</p>
<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB可以实现关于类的动态代理。CGLIB是一个强大、高性能、高质量的代码生成类库，它可以在运行期扩展Java类与实现Java接口：</p>
<ul>
<li>用CGLIB生成的代理类是被代理类的子类。</li>
<li>用CGLIB生成代理类不需要接口。</li>
<li>用CGLIB生成的代理类重写了父类的各个方法。</li>
<li>拦截器中的<code>intercept()</code>方法内容正好就是代理类中的方法体。</li>
</ul>
<p>引入CGLIB依赖：</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;3.3.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<p>放映《美国队长2》的被代理类：（注意：此时没有实现Movie接口）</p>
<pre><code class="java">public class CaptainAmerica2MovieImpl &#123;
    public void play()&#123;
        System.out.println(&quot;正在播放的电影是《美国队长2》&quot;);
    &#125;
&#125;</code></pre>
<p>创建一个自定义MethodInterceptor:</p>
<pre><code class="java">public class CglibProxyInterceptor implements MethodInterceptor &#123;
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;
        playStart();
        Object object = methodProxy.invokeSuper(o, objects);
        playEnd();
        return object;
    &#125;

    public void playStart() &#123;
        System.out.println(&quot;电影开始前正在播放广告&quot;);
    &#125;

    public void playEnd() &#123;
        System.out.println(&quot;电影结束了，接续播放广告&quot;);
    &#125;
&#125;</code></pre>
<p>测试类：</p>
<pre><code class="java">public class CglibProxyTest &#123;
    public static void main(String[] args) &#123;
        // 在指定目录下生成动态代理类
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;C:\\class&quot;);
        // 创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
        Enhancer enhancer = new Enhancer();
        // 设置目标类的字节码文件
        enhancer.setSuperclass(CaptainAmerica2MovieImpl.class);
        // 设置回调函数
        enhancer.setCallback(new CglibProxyInterceptor());
        //这里的creat方法就是正式创建代理类
        CaptainAmerica2MovieImpl captainAmerica2Movie = (CaptainAmerica2MovieImpl)enhancer.create();
        // 调用代理类的play方法
        captainAmerica2Movie.play();
        System.out.println(&quot;cglib动态代理《美国队长2》：&quot;+captainAmerica2Movie.getClass());
    &#125;
&#125;</code></pre>
<p>输出结果：</p>
<pre><code>电影开始前正在播放广告
正在播放的电影是《美国队长2》
电影结束了，接续播放广告
cglib动态代理《美国队长2》：class com.workit.demo.proxy.CaptainAmerica2MovieImpl$$EnhancerByCGLIB$$5c3ddcfe</code></pre>
<p>查看生成代理类反编译的源码：</p>
<pre><code class="java">public class CaptainAmerica2MovieImpl$$EnhancerByCGLIB$$5c3ddcfe extends CaptainAmerica2MovieImpl implements Factory &#123;

  public final void play() &#123;

        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;

        if (var10000 == null) &#123;
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        &#125;

        if (var10000 != null) &#123;
            var10000.intercept(this, CGLIB$play$0$Method, CGLIB$emptyArgs, CGLIB$play$0$Proxy);
        &#125; else &#123;
            super.play();
        &#125;
    &#125;
&#125;</code></pre>
<p>从以上源码可知：</p>
<ul>
<li>代理对象继承于<code>CaptainAmerica2MovieImpl</code>；</li>
<li>拦截器调用<code>intercept()</code>方法，<code>intercept()</code>方法由自定义<code>CglibProxyInterceptor</code>实现；</li>
<li>最后调用<code>CglibProxyInterceptor</code>中的<code>intercept()</code>方法，从而完成了由代理对象访问被代理的目标对象的动态代理实现。</li>
</ul>
<h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>Java<strong>集合</strong>，也叫作<strong>容器</strong>（Container），主要是由两大接口派生而来：</p>
<ol>
<li><code>Collection</code>接口，主要用于存放单一元素。下面又有三个主要的子接口：<code>List</code>、<code>Set</code>和<code>Queue</code>。</li>
<li><code>Map</code>接口，主要用于存放键值对。</li>
</ol>
<p><img src="images/java-collection-hierarchy.png" alt="java-collection-hierarchy"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>，<code>NavigableSet</code>等抽象类以及其他的一些辅助类。</p>
<p>完整结构：</p>
<p><img src="images/820406-20160529134155569-877986274.png" alt="820406-20160529134155569-877986274"></p>
<p><img src="images/820406-20160529133801631-1126275604.jpeg" alt="img"></p>
<h2 id="List-Set-Queue-Map四者的区别"><a href="#List-Set-Queue-Map四者的区别" class="headerlink" title="List, Set, Queue, Map四者的区别"></a>List, Set, Queue, Map四者的区别</h2><ul>
<li><strong>List</strong>(对付顺序的好帮手)：存储的元素是有序的、可重复的。</li>
<li><strong>Set</strong>(注重独一无二的性质)：存储的元素是无序的、不可重复的。</li>
<li><strong>Queue</strong>(实现排队功能的叫号机)：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><strong>Map</strong>(用key来搜索的专家)：使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，x代表key，y代表value，key 是无序的、不可重复的，value是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>Arraylist</code>： Object[]数组</li>
<li><code>Vector</code>：Object[]数组</li>
<li><code>LinkedList</code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li><code>HashSet</code>(无序，唯一)：基于HashMap实现的，底层采用HashMap来保存元素</li>
<li><code>LinkedHashSet</code>：LinkedHashSet是HashSet的子类，并且其内部是通过LinkedHashMap来实现的。</li>
<li><code>TreeSet</code>(有序，唯一)：红黑树(自平衡的排序二叉树)</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul>
<li><code>PriorityQueue</code>：Object[]数组来实现二叉堆</li>
<li><code>ArrayQueue</code>：Object[]数组 + 双指针</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>HashMap</code>：JDK 1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK 1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时：如果当前数组的长度小于64，那么会选择先进行数组扩容；否则将链表转化为红黑树，以减少搜索时间。</p>
<p><code>LinkedHashMap</code>：LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</p>
<p><code>Hashtable</code>：数组+链表组成的，数组是Hashtable的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</p>
<h2 id="为什么要使用集合？"><a href="#为什么要使用集合？" class="headerlink" title="为什么要使用集合？"></a>为什么要使用集合？</h2><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是使用数组存储对象具有一定的弊端，因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="Collection子接口-List"><a href="#Collection子接口-List" class="headerlink" title="Collection子接口 - List"></a>Collection子接口 - List</h2><h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><p><code>ArrayList</code>的底层是数组队列，相当于动态数组。与数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity()</code>操作来增加<code>ArrayList</code>实例的容量，这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code>继承于<code>AbstractList</code>，实现了<code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code>这些接口。</p>
<ul>
<li><code>RandomAccess</code>是一个标志接口，表明实现这个这个接口的List集合是支持快速随机访问的。</li>
<li>实现了<code>Cloneable</code>接口，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li>实现了<code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
<h3 id="ArrayList与Vector的区别"><a href="#ArrayList与Vector的区别" class="headerlink" title="ArrayList与Vector的区别"></a>ArrayList与Vector的区别</h3><ul>
<li><code>ArrayList</code>是List的主要实现类，底层使用Object[]存储，适用于频繁的查找工作，线程不安全；</li>
<li><code>Vector</code>是List的古老实现类，底层使用Object[]存储，线程安全的。</li>
</ul>
<h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h3><ul>
<li>是否保证线程安全：<code>ArrayList</code>和<code>LinkedList</code>都是不同步的，即都是线程不安全；</li>
<li>底层数据结构：<code>Arraylist</code>底层使用的是Object数组；<code>LinkedList</code>底层使用的是双向链表（JDK 1.6之前为循环链表，JDK 1.7取消了循环。注意双向链表和双向循环链表的区别）</li>
<li>插入和删除是否受元素位置的影响：<ul>
<li><code>ArrayList</code>采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。比如：执行<code>add(E e)</code>方法的时候，<code>ArrayList</code>会默认将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)；但是如果要在指定位置i插入和删除元素的话，<code>add(int index, E element)</code>时间复杂度就为O(n-i)。因为在进行上述操作的时候集合中第i和第i个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code>采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响，<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code>、<code>removeLast()</code>，时间复杂度为O(1)；如果是要在指定位置i插入和删除元素的话，<code>add(int index, E element)</code>，<code>remove(Object o)</code>，时间复杂度为O(n)，因为需要先移动到指定位置再插入。</li>
</ul>
</li>
<li>是否支持快速随机访问： <code>ArrayList</code>支持高效的随机元素访问<code>LinkedList</code>不支持。快速随机访问就是通过元素的序号快速获取元素对象，<code>get(int index)</code>。</li>
<li>内存空间占用：<code>ArrayList</code>的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间，因为要存放直接后继和直接前驱以及数据。</li>
</ul>
<h3 id="补充内容：RandomAccess接口"><a href="#补充内容：RandomAccess接口" class="headerlink" title="补充内容：RandomAccess接口"></a>补充内容：RandomAccess接口</h3><pre><code class="java">public interface RandomAccess &#123;
&#125;</code></pre>
<p>查看源码我们发现实际上<code>RandomAccess</code>接口中什么都没有定义。所以<code>RandomAccess</code>接口可以理解为一个标识，标识实现这个接口的类具有随机访问功能。</p>
<p>在<code>Arrays</code>工具类<code>binarySearch()</code>方法中，它要判断传入的list是否是<code>RandomAccess</code>的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法。</p>
<pre><code class="java">public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;
    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
&#125;</code></pre>
<p><code>ArrayList</code>实现了<code>RandomAccess</code>接口， 而<code>LinkedList</code>没有实现。<code>ArrayList</code>底层是数组，而<code>LinkedList</code>底层是链表。数组天然支持随机访问，时间复杂度为O(1)，所以称为快速随机访问；链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为O(n)，所以不支持快速随机访问。因此<code>ArrayList</code>实现了<code>RandomAccess</code>接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code>接口只是标识，并不是说<code>ArrayList</code>实现 <code>RandomAccess</code>接口才具有快速随机访问功能的！</p>
<h2 id="Collection子接口-Set"><a href="#Collection子接口-Set" class="headerlink" title="Collection子接口 - Set"></a>Collection子接口 - Set</h2><h3 id="Comparable与Comparator的区别"><a href="#Comparable与Comparator的区别" class="headerlink" title="Comparable与Comparator的区别"></a>Comparable与Comparator的区别</h3><ul>
<li><code>Comparable</code>接口实际上是出自<code>java.lang</code>包 它有一个<code>compareTo(Object obj)</code>方法用来排序。</li>
<li><code>Comparator</code>接口实际上是出自<code>java.util</code>包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序。</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法。</p>
<p>当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>compare()</code>或者以两个<code>compare()</code>来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort()。</p>
<p>实现Comparable接口的类中重写<code>compareTo()</code>：</p>
<pre><code class="java">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列
// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他
// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了
public  class Person implements Comparable&lt;Person&gt; &#123;
    private String name;
    private int age;

    public Person(String name, int age) &#123;
        super();
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    /**
     * T重写compareTo方法实现按年龄来排序
     */
    @Override
    public int compareTo(Person o) &#123;
        if (this.age &gt; o.getAge()) &#123;
            return 1;
        &#125;
        if (this.age &lt; o.getAge()) &#123;
            return -1;
        &#125;
        return 0;
    &#125;
&#125;

public static void main(String[] args) &#123;
    TreeMap&lt;Person, String&gt; pdata = new TreeMap&lt;Person, String&gt;();
    pdata.put(new Person(&quot;张三&quot;, 30), &quot;zhangsan&quot;);
    pdata.put(new Person(&quot;李四&quot;, 20), &quot;lisi&quot;);
    pdata.put(new Person(&quot;王五&quot;, 10), &quot;wangwu&quot;);
    pdata.put(new Person(&quot;小红&quot;, 5), &quot;xiaohong&quot;);
    // 得到key的值的同时得到key所对应的值
    Set&lt;Person&gt; keys = pdata.keySet();
    for (Person key : keys) &#123;
        System.out.println(key.getAge() + &quot;-&quot; + key.getName());
    &#125;
&#125;</code></pre>
<p><code>sort()</code>参数中传入Comparator接口并重写<code>compare()</code>方法的匿名实现类对象定制化排序：</p>
<pre><code class="java">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();
arrayList.add(-1);
arrayList.add(3);
arrayList.add(3);
arrayList.add(-5);
arrayList.add(7);
arrayList.add(4);
arrayList.add(-9);
arrayList.add(-7);
System.out.println(&quot;原始数组:&quot;);
System.out.println(arrayList);
// void reverse(List list)：反转
Collections.reverse(arrayList);
System.out.println(&quot;Collections.reverse(arrayList):&quot;);
System.out.println(arrayList);

// void sort(List list),按自然排序的升序排序
Collections.sort(arrayList);
System.out.println(&quot;Collections.sort(arrayList):&quot;);
System.out.println(arrayList);
// 定制排序的用法
Collections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123;

    @Override
    public int compare(Integer o1, Integer o2) &#123;
        return o2.compareTo(o1);
    &#125;
&#125;);
System.out.println(&quot;定制排序后：&quot;);
System.out.println(arrayList);</code></pre>
<h3 id="无序性和不可重复性的含义"><a href="#无序性和不可重复性的含义" class="headerlink" title="无序性和不可重复性的含义"></a>无序性和不可重复性的含义</h3><ul>
<li>什么是无序性？无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。因此在遍历输出时的顺序还是固定的，只是作为开发者的我们没法确定这个顺序。</li>
<li>什么是不可重复性？不可重复性是指添加的元素按照<code>equals()</code>判断时，返回false。需要同时重写<code>equals()</code>方法和<code>hashCode()</code>方法。</li>
</ul>
<h3 id="比较HashSet、LinkedHashSet和TreeSet三者的异同"><a href="#比较HashSet、LinkedHashSet和TreeSet三者的异同" class="headerlink" title="比较HashSet、LinkedHashSet和TreeSet三者的异同"></a>比较HashSet、LinkedHashSet和TreeSet三者的异同</h3><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code>和<code>TreeSet</code>都是<code>Set</code>接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code>和<code>TreeSet</code>的主要区别在于底层数据结构不同：<ul>
<li><code>HashSet</code>的底层数据结构是哈希表（基于<code>HashMap</code>实现）。</li>
<li><code>LinkedHashSet</code>的底层数据结构是链表和哈希表，元素的插入和取出顺序满足FIFO。</li>
<li><code>TreeSet</code>底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
</ul>
</li>
<li>底层数据结构不同又导致这三者的应用场景不同：<ul>
<li>HashSet用于不需要保证元素插入和取出顺序的场景</li>
<li>LinkedHashSet用于保证元素的插入和取出顺序满足FIFO的场景。</li>
<li>TreeSet用于支持对元素自定义排序规则的场景。</li>
</ul>
</li>
</ul>
<h2 id="Collection子接口-Queue"><a href="#Collection子接口-Queue" class="headerlink" title="Collection子接口 - Queue"></a>Collection子接口 - Queue</h2><h3 id="Queue与Deque的区别"><a href="#Queue与Deque的区别" class="headerlink" title="Queue与Deque的区别"></a>Queue与Deque的区别</h3><p><code>Queue</code>是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循FIFO规则。</p>
<p><code>Queue</code>扩展了<code>Collection</code>的接口。根据因为队列容量有限或队列为空而导致操作失败后处理方式的不同，可以分为两类方法: </p>
<ul>
<li>一种在操作失败后会抛出异常（比如<code>IllegalStateException</code>）：<code>add(E e)</code>，<code>remove()</code>，<code>element()</code></li>
<li>另一种则会返回特殊值（比如<code>false</code>，<code>null</code>）：<code>offer(E e)</code>，<code>poll()</code>，<code>peek()</code></li>
</ul>
<p><code>Deque</code>是双端队列，在队列的两端均可以插入或删除元素。</p>
<p><code>Deque</code>扩展了<code>Queue</code>的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<ul>
<li>一种在操作失败后会抛出异常：<code>addFirst(E e)</code>，<code>addLast(E e)</code>，<code>removeFirst()</code>，<code>removeLast()</code>，<code>getFirst()</code>，<code>getLast()</code></li>
<li>另一种则会返回特殊值：<code>offerFirst(E e)</code>，<code>offerLast(E e)</code>，<code>pollFirst()</code>，<code>pollLast()</code>，<code>peekFirst()</code>，<code>peekLast()</code></li>
</ul>
<p>此外，Deque还提供有<code>push()</code>和<code>pop()</code>等其他方法，可用于模拟栈。</p>
<h3 id="ArrayDeque与LinkedList的区别"><a href="#ArrayDeque与LinkedList的区别" class="headerlink" title="ArrayDeque与LinkedList的区别"></a>ArrayDeque与LinkedList的区别</h3><p><code>ArrayDeque</code>和<code>LinkedList</code>都实现了<code>Deque</code>接口，两者都具有队列的功能：</p>
<ul>
<li><code>ArrayDeque</code>是基于可变长的数组和双指针来实现，而<code>LinkedList</code>则通过链表来实现。</li>
<li><code>ArrayDeque</code>不支持存储<code>null</code>数据，但<code>LinkedList</code>支持。</li>
<li><code>ArrayDeque</code>是在JDK 1.6才被引入的，而<code>LinkedList</code>早在JDK 1.2就已经存在。</li>
<li><code>ArrayDeque</code>插入时可能存在扩容过程，不过均摊后的插入操作依然为 O(1)。虽然<code>LinkedList</code>不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用<code>ArrayDeque</code>来实现队列要比<code>LinkedList</code>更好。此外，<code>ArrayDeque</code>也可以用于实现栈。</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p><code>PriorityQueue</code>是在JDK 1.5中被引入的, 其与<code>Queue</code>的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素会插入到队头，先出队。</p>
<p><code>PriorityQueue</code>的主要特点有：</p>
<ul>
<li>利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li>通过堆元素的上浮和下沉，实现了在O(logn)的时间复杂度内插入元素和删除堆顶元素。</li>
<li>是非线程安全的，且不支持存储<code>null</code>和<strong>non-comparable</strong>的对象。</li>
<li>默认是小顶堆，但可以接收一个<code>Comparator</code>作为构造参数，从而来自定义元素优先级的先后。</li>
<li>在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等。</li>
</ul>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><ul>
<li>线程是否安全：<code>HashMap</code>是非线程安全的；<code>Hashtable</code>是线程安全的,因为其内部的方法基本都经过<code>synchronized</code> 修饰。（如果要保证线程安全的话就使用<code>ConcurrentHashMap</code>吧！）</li>
<li>效率：因为线程安全的问题，<code>HashMap</code>要比<code>Hashtable</code>效率高一点。另外，<code>Hashtable</code>基本被淘汰，不要在代码中使用它。</li>
<li>对<strong>null key</strong>和<strong>null value</strong>的支持：<code>HashMap</code>可以存储<code>null</code>的key和value，但<code>null</code>作为键只能有一个，<code>null</code>作为值可以有多个；<code>Hashtable</code>不允许有<code>null</code>键和<code>null</code>值，否则会抛出<code>NullPointerException</code>。</li>
<li>初始容量大小和每次扩充容量大小的不同：<ul>
<li>创建时如果不指定容量初始值，<code>Hashtable</code>默认的初始大小为11，之后每次扩充，容量变为原来的2n+1；<code>HashMap</code>默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。</li>
<li>创建时如果给定了容量初始值，那么<code>Hashtable</code>会直接使用你给定的大小；而<code>HashMap</code>会将其扩充为2的幂次方大小，因为HashMap总是通过<code>tableSizeFor()</code>方法保证使用2的幂作为哈希表的大小。</li>
</ul>
</li>
<li>底层数据结构：JDK 1.8以后的<code>HashMap</code>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）且数组长度大于64时，会将链表转换为红黑树（如果当前数组的长度小于64，那么会选择先进行数组扩容），以减少搜索时间。<code>Hashtable</code>没有这样的机制。</li>
</ul>
<h3 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h3><p><code>HashSet</code>底层就是基于<code>HashMap</code>实现的。<code>HashSet</code>的源码非常非常少，因为除了<code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是<code>HashSet</code>自己不得不实现之外，其他方法都是直接调用<code>HashMap</code>中的方法。</p>
<h3 id="HashMap和TreeMap区别"><a href="#HashMap和TreeMap区别" class="headerlink" title="HashMap和TreeMap区别"></a>HashMap和TreeMap区别</h3><p><code>TreeMap</code>和<code>HashMap</code>都继承自<code>AbstractMap</code>，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code>接口。</p>
<ul>
<li>实现<code>NavigableMap</code>接口让<code>TreeMap</code>有了对集合内元素的搜索的能力。</li>
<li>实现<code>SortedMap</code>接口让<code>TreeMap</code>有了对集合中的元素根据键排序的能力。默认是按key的升序排序，不过我们也可以指定排序的比较器。</li>
</ul>
<pre><code class="java">public class Person &#123;
    private Integer age;

    public Person(Integer age) &#123;
        this.age = age;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;


    public static void main(String[] args) &#123;
        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person person1, Person person2) &#123;
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            &#125;
        &#125;);
        treeMap.put(new Person(3), &quot;person1&quot;);
        treeMap.put(new Person(18), &quot;person2&quot;);
        treeMap.put(new Person(35), &quot;person3&quot;);
        treeMap.put(new Person(16), &quot;person4&quot;);
        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;
            System.out.println(personStringEntry.getValue());
        &#125;);
    &#125;
&#125;</code></pre>
<h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>当把对象加入<code>HashSet</code>时，<code>HashSet</code>会先计算对象的<strong>hashcode</strong>值来判断对象加入的位置，同时也会与其他加入的对象的<strong>hashcode</strong>值作比较，如果没有相符的<strong>hashcode</strong>，<code>HashSet</code>会假设对象没有重复出现。但是如果发现有相同<strong>hashcode</strong>值的对象，这时会调用<code>equals()</code>方法来检查<strong>hashcode</strong>相等的对象是否真的相同。如果两者相同，<code>HashSet</code>就不会让加入操作成功。</p>
<p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素:</p>
<pre><code class="java">// HashSet
// Returns: true if this set did not already contain the specified element
public boolean add(E e) &#123;
        return map.put(e, PRESENT)==null;
&#125;

// HashMap
// Returns : previous value, or null if none
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;
...
&#125;</code></pre>
<p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>
<blockquote>
<p>[hashcode()与equals()](# hashcode())</p>
</blockquote>
<h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><p>JDK 1.8之前<code>HashMap</code>底层是数组和链表结合在一起使用，也就是链表散列。</p>
<p><code>HashMap</code>通过<code>key</code>的<code>hashCode()</code>经过扰动函数处理过后得到hash值，然后通过<code>(n - 1) &amp; hash</code>判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是HashMap的<code>hash()</code>方法。使用该方法也就是扰动函数是为了优化一些实现比较差的hashCode()方法，换句话说，使用扰动函数之后可以减少哈希碰撞。</p>
<pre><code class="java">// JDK 1.8中HashMap的hash()方法源码
static final int hash(Object key) &#123;
    int h;
    // key.hashCode()：返回散列值也就是hashcode
    // ^ ：按位异或
    // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;

// JDK 1.7中HashMap的hash()方法源码
// 相比于 JDK 1.8，1.7的hash方法的性能会稍差一点点，毕竟扰动了4次。
static int hash(int h) &#123;
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).

    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
&#125;</code></pre>
<p>所谓「<strong>拉链法</strong>」就是将链表和数组相结合。创建一个链表数组，数组中每一格就是一个链表，若遇到哈希冲突，则将冲突的值加到数组当前位置链表中即可。</p>
<p><img src="images/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之前的内部结构-HashMap"></p>
<p>JDK 1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8），数组长度大于64时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="images/jdk1.8%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之后的内部结构-HashMap"></p>
<h3 id="HashMap的长度为什么是2的幂次方"><a href="#HashMap的长度为什么是2的幂次方" class="headerlink" title="HashMap的长度为什么是2的幂次方"></a>HashMap的长度为什么是2的幂次方</h3><p>为了能让<code>HashMap</code>存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。</p>
<p>Hash值是整数类型，范围值-2147483648 ~ 2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的，所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。</p>
<p>要实现这个算法，我们首先可能会想到采用<code>%</code>取余的操作来实现。但是，重点来了：取余<code>%</code>操作中如果除数是2的幂次方则等价于与其除数减一的与<code>&amp;</code>操作，也就是说<code>hash % length == hash &amp; (length-1)</code>，这个等式成立的前提是length是2的n次方。并且采用二进制位操作<code>&amp;</code>相对于<code>%</code>能够提高运算效率，这就解释了HashMap的长度为什么是2的幂次方。</p>
<p>观察HashMap源码也能发现。这个数组下标的计算方法就是<code>(n - 1) &amp; hash</code>（n 代表数组长度）。</p>
<h3 id="HashMap多线程操作导致死循环问题"><a href="#HashMap多线程操作导致死循环问题" class="headerlink" title="HashMap多线程操作导致死循环问题"></a>HashMap多线程操作导致死循环问题</h3><p>主要原因在于并发下的<strong>Rehash</strong>会造成元素之间会形成一个循环链表。不过，JDK 1.8后解决了这个问题，但是还是不建议在多线程下使用<code>HashMap</code>，因为多线程下使用<code>HashMap</code>还是会存在其他问题比如数据丢失。并发环境下推荐使用<code>ConcurrentHashMap</code> 。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46405589/article/details/109206432">JDK 1.8之前头插法在Rehash时带来的循环链表问题</a></p>
</blockquote>
<h3 id="HashMap有哪几种常见的遍历方式"><a href="#HashMap有哪几种常见的遍历方式" class="headerlink" title="HashMap有哪几种常见的遍历方式?"></a>HashMap有哪几种常见的遍历方式?</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">HashMap的7种遍历方式与性能分析!</a></p>
</blockquote>
<h3 id="ConcurrentHashMap和Hashtable的区别"><a href="#ConcurrentHashMap和Hashtable的区别" class="headerlink" title="ConcurrentHashMap和Hashtable的区别"></a>ConcurrentHashMap和Hashtable的区别</h3><p><code>ConcurrentHashMap</code>和<code>Hashtable</code>的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li>底层数据结构：JDK 1.7的<code>ConcurrentHashMap</code>底层采用<strong>分段的数组+链表</strong>实现，JDK 1.8采用的数据结构跟1.8中的<code>HashMap</code>的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code>和JDK 1.8之前的<code>HashMap</code>的底层数据结构类似，都是采用<strong>数组+链表</strong>的形式，数组是主体，链表则是主要为了解决哈希冲突而存在。</li>
<li>实现线程安全的方式（重要）：<ul>
<li>在JDK 1.7的时候，<code>ConcurrentHashMap</code>（分段锁） 对整个桶数组进行了<strong>分割分段（Segment）</strong>，每一把锁只锁容器中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。到了JDK 1.8的时候已经摒弃了Segment的概念，而是直接用<strong>Node数组+链表+红黑树</strong>的数据结构来实现，并发控制使用<code>synchronized</code>和<code>CAS</code>来操作（JDK 1.6以后对<code>synchronized</code>锁做了很多优化），整个看起来就像是优化过且线程安全的<code>HashMap</code>，虽然在JDK 1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本。</li>
<li><code>Hashtable</code>(同一把锁) 使用<code>synchronized</code>来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用<code>put()</code>添加元素，另一个线程不能使用<code>put()</code>添加元素，也不能使用<code>get()</code>，竞争会越来越激烈，效率也越来越低。</li>
</ul>
</li>
</ul>
<p><code>Hashtable</code>：</p>
<p><img src="images/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable全表锁"></p>
<p>JDK 1.7的<code>ConcurrentHashMap</code>：</p>
<p><img src="images/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg.png" alt="ConcurrentHashMap分段锁.jpg"></p>
<p>JDK 1.8的<code>ConcurrentHashMap</code>：</p>
<p><img src="images/java8_concurrenthashmap.c9951bb5.png" alt="java8_concurrenthashmap.c9951bb5"></p>
<p>JDK 1.8的<code>ConcurrentHashMap</code>不再是<strong>Segment数组+HashEntry数组+链表</strong>，而是<strong>Node数组+链表/红黑树</strong>。不过，<code>Node</code>只能用于链表的情况，红黑树的情况需要使用<code>TreeNode</code>，当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><p>JDK 1.7：</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><code>ConcurrentHashMap</code>是由<strong>Segment数组+HashEntry数组+链表</strong>组成。</p>
<p><code>Segment</code>继承了<code>ReentrantLock</code>,所以<code>Segment</code>是一种可重入锁，扮演锁的角色。<code>HashEntry</code>用于存储键值对数据。</p>
<p>一个<code>ConcurrentHashMap</code>里包含一个<code>Segment</code>数组。<code>Segment</code>的结构和<code>HashMap</code>类似，是一种数组和链表结构，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment的锁。</p>
<p>JDK 1.8：</p>
<p><code>ConcurrentHashMap</code>取消了Segment分段锁，采用<code>CAS</code>和<code>synchronized</code>来保证并发安全。数据结构跟1.8的HashMap结构类似，<strong>数组+链表/红黑二叉树</strong>。链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p><code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 工具类常用方法:</p>
<ul>
<li>排序</li>
<li>查找，替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ul>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><pre><code class="java">// 反转
void reverse(List list);
// 随机排序
void shuffle(List list);
// 按自然排序的升序排序
void sort(List list);
// 定制排序，由Comparator控制排序逻辑
void sort(List list, Comparator c);
// 交换两个索引位置的元素
void swap(List list, int i , int j);
// 旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
void rotate(List list, int distance);</code></pre>
<h3 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h3><pre><code class="java">// 对List进行二分查找，返回索引，注意List必须是有序的
int binarySearch(List list, Object key);
// 根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll);
// 根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
int max(Collection coll, Comparator c);
// 用指定的元素代替指定list中的所有元素
void fill(List list, Object obj);
// 统计元素出现次数
int frequency(Collection c, Object o);
//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
int indexOfSubList(List list, List target);
// 用新元素替换旧元素
boolean replaceAll(List list, Object oldVal, Object newVal);</code></pre>
<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p><code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>，<code>LinkedList</code>，<code>HashMap</code>，<code>TreeMap</code>都是线程不安全的。<code>Collections</code>提供了多个静态方法<code>synchronizedXxx()</code>，可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>但最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用JUC包下的并发集合。</p>
<pre><code class="java">// 返回指定 collection 支持的同步（线程安全的）collection
synchronizedCollection(Collection&lt;T&gt;  c);
// 返回指定列表支持的同步（线程安全的）List
synchronizedList(List&lt;T&gt; list);
// 返回由指定映射支持的同步（线程安全的）Map
synchronizedMap(Map&lt;K,V&gt; m);
// 返回指定set支持的同步（线程安全的）set
synchronizedSet(Set&lt;T&gt; s);</code></pre>
<h2 id="集合使用注意事项"><a href="#集合使用注意事项" class="headerlink" title="集合使用注意事项"></a>集合使用注意事项</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-precautions-for-use.html#%E9%9B%86%E5%90%88%E5%88%A4%E7%A9%BA">Java集合使用注意事项总结</a></p>
</blockquote>
<h2 id="ArrayList源码-amp-扩容机制分析"><a href="#ArrayList源码-amp-扩容机制分析" class="headerlink" title="ArrayList源码 &amp; 扩容机制分析"></a>ArrayList源码 &amp; 扩容机制分析</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>JDK 1.8中<code>ArrayList</code>有三种方式来初始化，构造方法源码如下：</p>
<pre><code class="java">/**
 * 默认初始容量大小
 */
private static final int DEFAULT_CAPACITY = 10;


private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;

/**
 * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)
 */
public ArrayList() &#123;
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&#125;

/**
 * 带初始容量参数的构造函数。（用户自己指定容量）
 */
public ArrayList(int initialCapacity) &#123;
    if (initialCapacity &gt; 0) &#123;//初始容量大于0
        //创建initialCapacity大小的数组
        this.elementData = new Object[initialCapacity];
    &#125; else if (initialCapacity == 0) &#123;//初始容量等于0
        //创建空数组
        this.elementData = EMPTY_ELEMENTDATA;
    &#125; else &#123;//初始容量小于0，抛出异常
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    &#125;
&#125;


/**
 * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
 * 如果指定的集合为null，throws NullPointerException。
 */
public ArrayList(Collection&lt;? extends E&gt; c) &#123;
    elementData = c.toArray();
    if ((size = elementData.length) != 0) &#123;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, size, Object[].class);
    &#125; else &#123;
        // replace with empty array.
        this.elementData = EMPTY_ELEMENTDATA;
    &#125;
&#125;</code></pre>
<p>以无参数构造方法创建<code>ArrayList</code>时，实际上<strong>初始化赋值的是一个空数组</strong>。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为<code>10</code>。</p>
<p>补充：JDK 8之前new无参构造的<code>ArrayList</code>对象时，直接创建了长度是<code>10</code>的<code>Object[]</code>数组<code>elementData</code> 。</p>
<h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><pre><code class="java">/**
 * 将指定的元素追加到此列表的末尾。
 */
public boolean add(E e) &#123;
    //添加元素之前，先调用ensureCapacityInternal方法
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //这里看到ArrayList添加元素的实质就相当于为数组赋值
    elementData[size++] = e;
    return true;
&#125;</code></pre>
<p>注意：JDK 11移除了<code>ensureCapacityInternal()</code>和<code>ensureExplicitCapacity()</code>方法。</p>
<h3 id="ensureCapacityInternal方法"><a href="#ensureCapacityInternal方法" class="headerlink" title="ensureCapacityInternal方法"></a>ensureCapacityInternal方法</h3><pre><code class="java">//得到最小扩容量
private void ensureCapacityInternal(int minCapacity) &#123;
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
        // 获取默认的容量和传入参数的较大值
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    &#125;

    ensureExplicitCapacity(minCapacity);
&#125;</code></pre>
<p>当要add进第1个元素时，<code>minCapacity</code>为1，在<code>Math.max()</code>方法比较后，<code>minCapacity</code>变化为<code>10</code>。</p>
<h3 id="ensureExplicitCapacity方法"><a href="#ensureExplicitCapacity方法" class="headerlink" title="ensureExplicitCapacity方法"></a>ensureExplicitCapacity方法</h3><pre><code class="java">//判断是否需要扩容
private void ensureExplicitCapacity(int minCapacity) &#123;
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)
        //调用grow方法进行扩容，调用此方法代表已经开始扩容了
        grow(minCapacity);
&#125;</code></pre>
<p>只要调用<code>ensureCapacityInternal()</code>方法就一定会进入（执行）这个方法。</p>
<ul>
<li>当要add进第1个元素到<code>ArrayList</code>时，<code>elementData.length</code>为<code>0</code>（因为还是一个空的 list），因为执行了ensureCapacityInternal()方法，所以minCapacity此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入<code>grow(minCapacity)</code>方法。</li>
<li>当add第2个元素时，<code>minCapacity</code>为<code>2</code>，此时<code>elementData.length</code>(容量)在添加第一个元素后扩容成10了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入（执行）<code>grow(minCapacity)</code>方法。</li>
<li>添加第 3、4···到第10个元素时，依然不会执行grow方法，数组容量都为<code>10</code>。</li>
<li>直到添加第11个元素，<code>minCapacity</code>(为<code>11</code>)比<code>elementData.length</code>（为<code>10</code>）要大。进入<code>grow(minCapacity)</code>方法进行扩容。</li>
</ul>
<h3 id="grow方法"><a href="#grow方法" class="headerlink" title="grow方法"></a>grow方法</h3><pre><code class="java">/**
 * 要分配的最大数组大小
 */
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

/**
 * ArrayList扩容的核心方法。
 */
private void grow(int minCapacity) &#123;
    // oldCapacity为旧容量，newCapacity为新容量
    int oldCapacity = elementData.length;
    // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，
    // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，
    // 如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;</code></pre>
<p><code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，所以<code>ArrayList</code>每次扩容之后容量都<strong>会变为原来的1.5倍左右</strong>（oldCapacity 为偶数就是1.5倍，否则是1.5倍左右，奇偶不同，比如10+10/2=15，33+33/2=49）！ </p>
<ul>
<li><code>&gt;&gt;</code>：<code>&gt;&gt;1</code>右移一位相当于除2，右移n位相当于除以2的n次方。对于大数据的2进制运算，位移运算符比那些普通运算符的运算要快很多，因为程序最终执行时就是读取二进制数据，仅仅移动一下而已不去计算，这样提高了效率，节省了资源。</li>
</ul>
<p>举例说明grow方法：</p>
<ul>
<li>当add第1个元素时，<code>oldCapacity</code>为<code>0</code>，经比较后第一个if判断成立，<code>newCapacity = minCapacity</code>(为<code>10</code>)。但是第二个if判断不会成立，即 <code>newCapacity</code>不比<code>MAX_ARRAY_SIZE</code>大，不会进入<code>hugeCapacity()</code>方法。数组容量为10，add方法中return true，size增为1。</li>
<li>当add第11个元素时，<code>newCapacity</code>为<code>15</code>，比<code>minCapacity</code>（为 11）大，第一个if判断不成立。新容量没有大于<code>MAX_ARRAY_SIZE</code>，不会进入<code>hugeCapacity()</code>方法。数组容量扩为15，add方法中return true，size增为11。</li>
<li>以此类推······</li>
</ul>
<p>补充：</p>
<ul>
<li><code>length</code>属性是针对数组说的，声明了一个数组，想知道这个数组的长度用到了<code>length</code>这个属性。</li>
<li><code>length()</code>方法是针对字符串说的，如果想看这个字符串的长度则用到<code>length()</code>这个方法。</li>
<li><code>size()</code>方法是针对泛型集合说的，如果想看这个泛型实际有多少个元素，就调用此方法来查看。</li>
</ul>
<h3 id="hugeCapacity方法"><a href="#hugeCapacity方法" class="headerlink" title="hugeCapacity方法"></a>hugeCapacity方法</h3><pre><code class="java">private static int hugeCapacity(int minCapacity) &#123;
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    //对minCapacity和MAX_ARRAY_SIZE进行比较
    //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小
    //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小
    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
    MAX_ARRAY_SIZE;
&#125;</code></pre>
<p>从上面<code>grow()</code>方法源码可知：如果新容量大于<code>MAX_ARRAY_SIZE</code>，进入(执行)<code>hugeCapacity()</code>方法来比较<code>minCapacity</code>和<code>MAX_ARRAY_SIZE</code>，如果<code>minCapacity</code>大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为MAX_ARRAY_SIZE即为Integer.MAX_VALUE - 8。</p>
<p>阅读源码发现<code>ArrayList</code>中大量调用两个方法：</p>
<h3 id="System-arraycopy和Arrays-copyOf方法"><a href="#System-arraycopy和Arrays-copyOf方法" class="headerlink" title="System.arraycopy和Arrays.copyOf方法"></a>System.arraycopy和Arrays.copyOf方法</h3><pre><code class="java">// System.arraycopy
/**
 *   复制数组
 * @param src 源数组
 * @param srcPos 源数组中的起始位置
 * @param dest 目标数组
 * @param destPos 目标数组中的起始位置
 * @param length 要复制的数组元素的数量
 */
public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);

// 使用场景
/**
 * 在此列表中的指定位置插入指定的元素。
 * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
 * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
 */
public void add(int index, E element) &#123;
    rangeCheckForAdd(index);
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    //arraycopy()方法实现数组自己复制自己
    //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；
    System.arraycopy(elementData, index, elementData, index + 1, size - index);
    elementData[index] = element;
    size++;
&#125;

// Arrays.copyOf
public static int[] copyOf(int[] original, int newLength) &#123;
    // 申请一个新的数组
    int[] copy = new int[newLength];
    // 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组
    System.arraycopy(original, 0, copy, 0,
                     Math.min(original.length, newLength));
    return copy;
&#125;

/**
 * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。
 */
public Object[] toArray() &#123;
    //elementData：要复制的数组；size：要复制的长度
    return Arrays.copyOf(elementData, size);
&#125;</code></pre>
<ul>
<li>两者的联系：看两者源代码可以发现<code>copyOf()</code>内部实际调用了<code>System.arraycopy()</code>方法</li>
<li>两者的区别：<code>arraycopy()</code>需要目标数组，将原数组拷贝到自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置；<code>copyOf()</code>是系统自动在内部新建一个数组，并返回该数组。</li>
</ul>
<h3 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h3><pre><code class="java">/**
 * 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。
 *
 * @param   minCapacity   所需的最小容量
 */
public void ensureCapacity(int minCapacity) &#123;
    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
        // any size if not default element table
        ? 0
        // larger than default for default empty table. It&#39;s already
        // supposed to be at default size.
        : DEFAULT_CAPACITY;

    if (minCapacity &gt; minExpand) &#123;
        ensureExplicitCapacity(minCapacity);
    &#125;
&#125;</code></pre>
<p>这个方法<code>ArrayList</code>内部没有被调用过，所以很显然是提供给用户调用的，最好在add大量元素之前用<code>ensureCapacity()</code>方法，以减少增量重新分配的次数。</p>
<h2 id="HashMap源码-amp-底层数据结构分析"><a href="#HashMap源码-amp-底层数据结构分析" class="headerlink" title="HashMap源码 &amp; 底层数据结构分析"></a>HashMap源码 &amp; 底层数据结构分析</h2><h3 id="JDK-1-8之前底层数据结构"><a href="#JDK-1-8之前底层数据结构" class="headerlink" title="JDK 1.8之前底层数据结构"></a>JDK 1.8之前底层数据结构</h3><p>JDK 1.8之前<code>HashMap</code>底层是<strong>数组+链表</strong>，也就是链表散列。</p>
<p><code>HashMap</code>通过key的<code>hashCode</code>经过扰动函数处理过后得到hash值，然后通过<code>(n - 1) &amp; hash</code>判断当前元素存放的位置（这里的<code>n</code>指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否equals，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是<code>HashMap</code>的<code>hash()</code>方法。使用<code>hash()</code>方法也就是扰动函数是为了防止一些实现比较差的<code>hashCode()</code>方法，换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>hash方法</strong>：</p>
<pre><code class="java">// JDK 1.7
static int hash(int h) &#123;
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
&#125;

// JDK 1.8
static final int hash(Object key) &#123;
    int h;
    // key.hashCode()：返回散列值也就是hashcode
    // ^ ：按位异或
    // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;</code></pre>
<h3 id="JDK-1-8之后底层数据结构"><a href="#JDK-1-8之后底层数据结构" class="headerlink" title="JDK 1.8之后底层数据结构"></a>JDK 1.8之后底层数据结构</h3><p>当链表长度大于阈值（默认为 8）时，会首先调用<code>treeifyBin()</code>方法。这个方法会根据<code>HashMap</code>数组来决定是否转换为红黑树。只有当数组长度大于或者等于<code>64</code>的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行<code>resize()</code>方法对数组扩容。</p>
<p><img src="images/treeify.webp" alt="treeify"></p>
<h3 id="HashMap类属性"><a href="#HashMap类属性" class="headerlink" title="HashMap类属性"></a>HashMap类属性</h3><pre><code class="java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;
    // 序列号
    private static final long serialVersionUID = 362498820763181265L;
    // 默认的初始容量是16
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;
    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
    // 默认的填充因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 当桶(bucket)上的结点数大于这个值时会转成红黑树
    static final int TREEIFY_THRESHOLD = 8;
    // 当桶(bucket)上的结点数小于这个值时树转链表
    static final int UNTREEIFY_THRESHOLD = 6;
    // 桶中结构转化为红黑树对应的table的最小容量
    static final int MIN_TREEIFY_CAPACITY = 64;
    // 存储元素的数组，总是2的幂次倍
    transient Node&lt;k,v&gt;[] table;
    // 存放具体元素的集
    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;
    // 存放元素的个数，注意这个不等于数组的长度。
    transient int size;
    // 每次扩容和更改map结构的计数器
    transient int modCount;
    // 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容
    int threshold;
    // 加载因子
    final float loadFactor;
&#125;</code></pre>
<p><strong>loadFactor加载因子</strong>：</p>
<p><code>loadFactor</code>加载因子是控制数组存放数据的疏密程度。<code>loadFactor</code>越趋近于<code>1</code>，那么数组中存放的数据（<code>entry</code>）也就越多，也就越密，也就是会让链表的长度增加；<code>loadFactor</code>越小，也就是趋近于<code>0</code>，数组中存放的数据（<code>entry</code>）也就越少，也就越稀疏。</p>
<p><code>loadFactor</code>太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<code>loadFactor</code>的默认值为<code>0.75f</code>是官方给出的一个比较好的临界值。</p>
<p>给定的默认容量为<code>16</code>，负载因子为<code>0.75</code>。Map在使用过程中不断的往里面存放数据，当数量达到了<code>16 * 0.75 = 12</code>就需要将当前16的容量进行扩容，而扩容这个过程涉及到<strong>rehash</strong>、<strong>复制数据</strong>等操作，所以非常消耗性能。</p>
<p><strong>threshold</strong>：</p>
<p><code>threshold = capacity * loadFactor</code>，当<code>size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，<code>threshold</code>是衡量数组是否需要扩增的一个标准。</p>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><pre><code class="java">// 默认构造函数。
public HashMap() &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted
&#125;

// 包含另一个“Map”的构造函数
public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);//下面会分析到这个方法
&#125;

// 指定“容量大小”的构造函数
public HashMap(int initialCapacity) &#123;
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
&#125;

// 指定“容量大小”和“加载因子”的构造函数
public HashMap(int initialCapacity, float loadFactor) &#123;
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
&#125;</code></pre>
<h3 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a>putMapEntries方法</h3><pre><code class="java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;
    int s = m.size();
    if (s &gt; 0) &#123;
        // 判断table是否已经初始化
        if (table == null) &#123; // pre-size
            // 未初始化，s为m的实际元素个数
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                    (int)ft : MAXIMUM_CAPACITY);
            // 计算得到的t大于阈值，则初始化阈值
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        &#125;
        // 已初始化，并且m元素个数大于阈值，进行扩容处理
        else if (s &gt; threshold)
            resize();
        // 将m中的所有元素添加至HashMap中
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="JDK-1-8的put方法"><a href="#JDK-1-8的put方法" class="headerlink" title="JDK 1.8的put方法"></a>JDK 1.8的put方法</h3><p><code>HashMap</code>只提供给调用者<code>put()</code>用于添加元素，<code>putVal()</code>方法只是给<code>put()</code>调用的一个方法，并没有提供给用户使用。</p>
<p>putVal()添加元素的过程：</p>
<ul>
<li>如果定位到的数组位置没有元素就直接插入。</li>
<li>如果定位到的数组位置有元素就和要插入的<strong>key</strong>比较，如果key相同(hashCode和equals都为true)就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表<strong>采用尾插法插入元素</strong>。</li>
</ul>
<p><img src="images/put%E6%96%B9%E6%B3%95.png" alt="put方法"></p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // table未初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 桶中已经存在元素
    else &#123;
        Node&lt;K,V&gt; e; K k;
        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                // 将第一个元素赋值给e，用e来记录
                e = p;
        // hash值不相等，即key不相等；为红黑树结点
        else if (p instanceof TreeNode)
            // 放入树中
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 为链表结点
        else &#123;
            // 在链表最末插入结点
            for (int binCount = 0; ; ++binCount) &#123;
                // 到达链表的尾部
                if ((e = p.next) == null) &#123;
                    // 在尾部插入新结点
                    p.next = newNode(hash, key, value, null);
                    // 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法
                    // 这个方法会根据 HashMap 数组来决定是否转换为红黑树。
                    // 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    // 跳出循环
                    break;
                &#125;
                // 判断链表中结点的key值与插入的元素的key值是否相等
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    // 相等，跳出循环
                    break;
                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                p = e;
            &#125;
        &#125;
        // 表示在桶中找到key值、hash值与插入元素相等的结点
        if (e != null) &#123;
            // 记录e的value
            V oldValue = e.value;
            // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null)
                //用新值替换旧值
                e.value = value;
            // 访问后回调
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        &#125;
    &#125;
    // 结构性修改
    ++modCount;
    // 实际大小大于阈值则扩容
    if (++size &gt; threshold)
        resize();
    // 插入后回调
    afterNodeInsertion(evict);
    return null;
&#125;</code></pre>
<h3 id="JDK-1-7的put方法"><a href="#JDK-1-7的put方法" class="headerlink" title="JDK 1.7的put方法"></a>JDK 1.7的put方法</h3><p>过程与1.8类似：</p>
<ul>
<li>如果定位到的数组位置没有元素 就直接插入。</li>
<li>如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就<strong>采用头插法插入元素</strong>。</li>
</ul>
<pre><code class="java">public V put(K key, V value)
    if (table == EMPTY_TABLE) &#123;
    inflateTable(threshold);
&#125;
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;

    modCount++;
    addEntry(hash, key, value, i);  // 再插入
    return null;
&#125;</code></pre>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        // 数组元素相等
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 桶中不止一个节点
        if ((e = first.next) != null) &#123;
            // 在树中get
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            // 在链表中get
            do &#123;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;

</code></pre>
<h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123;
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else &#123;
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    // 计算新的resize上限
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123;
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123;
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        // 原索引+oldCap
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;</code></pre>
<p>进行扩容会伴随着一次rehash，并且会遍历hash表中所有的元素，过程非常耗时的。因此在编写程序中，要尽量避免resize。</p>
<h2 id="ConcurrentHashMap源码-amp-底层数据结构分析"><a href="#ConcurrentHashMap源码-amp-底层数据结构分析" class="headerlink" title="ConcurrentHashMap源码 &amp; 底层数据结构分析"></a>ConcurrentHashMap源码 &amp; 底层数据结构分析</h2><h3 id="JDK-1-7的ConcurrentHashMap"><a href="#JDK-1-7的ConcurrentHashMap" class="headerlink" title="JDK 1.7的ConcurrentHashMap"></a>JDK 1.7的ConcurrentHashMap</h3><p><strong>存储结构</strong>：</p>
<p><img src="images/image-20200405151029416.49a48864.png" alt="image-20200405151029416.49a48864"></p>
<p>Java 7中<code>ConcurrnetHashMap</code>由很多个<code>Segment</code>组合，而每一个<code>Segment</code>是一个类似于<code>HashMap</code>的结构，所以每一个<code>HashMap</code>的内部可以进行扩容。但是 <code>Segment</code>的个数一旦初始化就不能改变，默认是<code>16</code>个，也可以认为<code>ConcurrentHashMap</code>默认支持最多16个线程并发。</p>
<p><strong>初始化</strong>：</p>
<p>无参构造函数：</p>
<pre><code class="java">/**
 * Creates a new, empty map with a default initial capacity (16),
 * load factor (0.75) and concurrencyLevel (16).
 */
public ConcurrentHashMap() &#123;
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
&#125;

// 无参构造中调用了有参构造，传入了三个参数的默认值
/**
 * 默认初始化容量
 */
static final int DEFAULT_INITIAL_CAPACITY = 16;

/**
 * 默认负载因子
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;

/**
 * 默认并发级别
 */
static final int DEFAULT_CONCURRENCY_LEVEL = 16;</code></pre>
<p>调用的有参构造函数：</p>
<pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)
public ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel) &#123;
    // 参数校验
    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
        throw new IllegalArgumentException();
    // 校验并发级别大小，大于 1&lt;&lt;16，重置为 65536
    if (concurrencyLevel &gt; MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    // 2的多少次方
    int sshift = 0;
    int ssize = 1;
    // 这个循环可以找到 concurrencyLevel 之上最近的 2的次方值
    while (ssize &lt; concurrencyLevel) &#123;
        ++sshift;
        ssize &lt;&lt;= 1;
    &#125;
    // 记录段偏移量
    this.segmentShift = 32 - sshift;
    // 记录段掩码
    this.segmentMask = ssize - 1;
    // 设置容量
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // c = 容量 / ssize ，默认 16 / 16 = 1，这里是计算每个 Segment 中的类似于 HashMap 的容量
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    //Segment 中的类似于 HashMap 的容量至少是2或者2的倍数
    while (cap &lt; c)
        cap &lt;&lt;= 1;
    // create segments and segments[0]
    // 创建 Segment 数组，设置 segments[0]
    Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
&#125;</code></pre>
<p>初始化逻辑为：</p>
<ol>
<li>必要参数校验。</li>
<li>校验并发级别<code>concurrencyLevel</code>大小，如果大于最大值，重置为最大值。无参构造默认值是<code>16</code>。</li>
<li>寻找并发级别<code>concurrencyLevel</code>之上最近的2的幂次方值，作为初始化容量大小，默认是<code>16</code>。</li>
<li>记录<code>segmentShift</code>偏移量，这个值为「容量 = 2的N次方」中的<strong>N</strong>，在后面put时计算位置时会用到。默认是<code>32 - sshift = 28</code>。</li>
<li>记录<code>segmentMask</code>，默认是<code>ssize - 1 = 16 -1 = 15</code>。</li>
<li>初始化<code>segments[0]</code>，默认大小为<code>2</code>，负载因子<code>0.75</code>，扩容阀值<code>2*0.75=1.5</code>，插入第二个值时才会进行扩容。</li>
</ol>
<p><strong>put方法</strong>：</p>
<pre><code class="java">/**
 * Maps the specified key to the specified value in this table.
 * Neither the key nor the value can be null.
 *
 * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method
 * with a key that is equal to the original key.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
 *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;
 * @throws NullPointerException if the specified key or value is null
 */
public V put(K key, V value) &#123;
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    // hash 值无符号右移 28位（初始化时获得），然后与 segmentMask=15 做与运算
    // 其实也就是把高4位与segmentMask（1111）做与运算
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        // 如果查找到的 Segment 为空，初始化
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
&#125;

/**
 * Returns the segment for the given index, creating it and
 * recording in segment table (via CAS) if not already present.
 *
 * @param k the index
 * @return the segment
 */
@SuppressWarnings(&quot;unchecked&quot;)
private Segment&lt;K,V&gt; ensureSegment(int k) &#123;
    final Segment&lt;K,V&gt;[] ss = this.segments;
    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset
    Segment&lt;K,V&gt; seg;
    // 判断 u 位置的 Segment 是否为null
    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123;
        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype
        // 获取0号 segment 里的 HashEntry&lt;K,V&gt; 初始化长度
        int cap = proto.table.length;
        // 获取0号 segment 里的 hash 表里的扩容负载因子，所有的 segment 的 loadFactor 是相同的
        float lf = proto.loadFactor;
        // 计算扩容阀值
        int threshold = (int)(cap * lf);
        // 创建一个 cap 容量的 HashEntry 数组
        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];
        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) &#123; // recheck
            // 再次检查 u 位置的 Segment 是否为null，因为这时可能有其他线程进行了操作
            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);
            // 自旋检查 u 位置的 Segment 是否为null
            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
                   == null) &#123;
                // 使用CAS 赋值，只会成功一次
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            &#125;
        &#125;
    &#125;
    return seg;
&#125;</code></pre>
<p>上面的源码分析了<code>ConcurrentHashMap</code>在put一个数据时的处理流程，下面梳理下具体流程。</p>
<ol>
<li><p>计算要put的key的位置，获取指定位置的<code>Segment</code>。</p>
</li>
<li><p>如果指定位置的<code>Segment</code>为空，则初始化这个<code>Segment</code>。初始化流程为：</p>
<ol>
<li>检查计算得到的位置的<code>Segment</code>是否为<code>null</code>。</li>
<li>为<code>null</code>继续初始化，使用<code>Segment[0]</code>的容量和负载因子创建一个<code>HashEntry</code>数组。</li>
<li>再次检查计算得到的指定位置的<code>Segment</code>是否为<code>null</code>。</li>
<li>使用创建的<code>HashEntry</code>数组初始化这个<code>Segment</code>。</li>
<li>自旋判断计算得到的指定位置的<code>Segment</code>是否为<code>null</code>，使用<code>CAS</code>在这个位置赋值为<code>Segment</code>。</li>
</ol>
</li>
<li><p><code>Segment.put</code>插入key，value值。</p>
</li>
</ol>
<p>上面探究了获取Segment段和初始化Segment段的操作。最后一行的Segment的put方法还没有查看，继续分析。</p>
<pre><code class="java">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;
    // 获取 ReentrantLock 独占锁，获取不到，scanAndLockForPut 获取。
    HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value);
    V oldValue;
    try &#123;
        HashEntry&lt;K,V&gt;[] tab = table;
        // 计算要put的数据位置
        int index = (tab.length - 1) &amp; hash;
        // CAS 获取 index 坐标的值
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        for (HashEntry&lt;K,V&gt; e = first;;) &#123;
            if (e != null) &#123;
                // 检查是否 key 已经存在，如果存在，则遍历链表寻找位置，找到后替换 value
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;
                    oldValue = e.value;
                    if (!onlyIfAbsent) &#123;
                        e.value = value;
                        ++modCount;
                    &#125;
                    break;
                &#125;
                e = e.next;
            &#125;
            else &#123;
                // first 有值没说明 index 位置已经有值了，有冲突，链表头插法。
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                // 容量大于扩容阀值，小于最大容量，进行扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    // index 位置赋值 node，node 可能是一个元素，也可能是一个链表的表头
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            &#125;
        &#125;
    &#125; finally &#123;
        unlock();
    &#125;
    return oldValue;
&#125;</code></pre>
<p>由于<code>Segment</code>继承了<code>ReentrantLock</code>，所以<code>Segment</code>内部可以很方便的获取锁，<code>put</code>流程就用到了这个功能。</p>
<ol>
<li><p><code>tryLock()</code>获取锁，获取不到使用<code>scanAndLockForPut</code>方法继续获取。</p>
</li>
<li><p>计算put的数据要放入的index位置，然后获取这个位置上的<code>HashEntry</code>。</p>
</li>
<li><p>遍历put新元素，为什么要遍历？因为这里获取的<code>HashEntry</code>可能是一个空元素，也可能是链表已存在，所以要区别对待。</p>
<ul>
<li>如果这个位置上的HashEntry不存在：如果当前容量大于扩容阀值，小于最大容量，进行扩容。然后直接头插法插入。</li>
<li>如果这个位置上的HashEntry存在：判断链表当前元素key和hash值是否和要put的key和hash值一致，一致则替换值；不一致则获取链表下一个节点，直到发现相同进行值替换，如果链表遍历完毕没有相同的，此时容量大于扩容阀值，小于最大容量，进行扩容。然后直接头插法插入。</li>
</ul>
</li>
<li><p>如果要插入的位置之前已经存在，替换后返回旧值，否则返回<code>null</code>。</p>
</li>
</ol>
<p><code>scanAndLockForPut</code>操作这里没有介绍，这个方法做的操作就是不断的自旋<code>tryLock()</code>获取锁。当自旋次数大于指定次数时，使用<code>lock()</code>阻塞获取锁。在自旋时顺表获取下hash位置的<code>HashEntry</code>。</p>
<pre><code class="java">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;
    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);
    HashEntry&lt;K,V&gt; e = first;
    HashEntry&lt;K,V&gt; node = null;
    int retries = -1; // negative while locating node
    // 自旋获取锁
    while (!tryLock()) &#123;
        HashEntry&lt;K,V&gt; f; // to recheck first below
        if (retries &lt; 0) &#123;
            if (e == null) &#123;
                if (node == null) // speculatively create node
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);
                retries = 0;
            &#125;
            else if (key.equals(e.key))
                retries = 0;
            else
                e = e.next;
        &#125;
        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;
            // 自旋达到指定次数后，阻塞等到只到获取到锁
            lock();
            break;
        &#125;
        else if ((retries &amp; 1) == 0 &amp;&amp;
                 (f = entryForHash(this, hash)) != first) &#123;
            e = first = f; // re-traverse if entry changed
            retries = -1;
        &#125;
    &#125;
    return node;
&#125;
</code></pre>
<p><strong>扩容rehash</strong>：</p>
<p><code>ConcurrentHashMap</code>的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为<code>index + oldSize</code>，参数里的<code>node</code>会在扩容之后使用链表头插法插入到指定位置。</p>
<pre><code class="java">private void rehash(HashEntry&lt;K,V&gt; node) &#123;
    HashEntry&lt;K,V&gt;[] oldTable = table;
    // 老容量
    int oldCapacity = oldTable.length;
    // 新容量，扩大两倍
    int newCapacity = oldCapacity &lt;&lt; 1;
    // 新的扩容阀值 
    threshold = (int)(newCapacity * loadFactor);
    // 创建新的数组
    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];
    // 新的掩码，默认2扩容后是4，-1是3，二进制就是11。
    int sizeMask = newCapacity - 1;
    for (int i = 0; i &lt; oldCapacity ; i++) &#123;
        // 遍历老数组
        HashEntry&lt;K,V&gt; e = oldTable[i];
        if (e != null) &#123;
            HashEntry&lt;K,V&gt; next = e.next;
            // 计算新的位置，新的位置只可能是不便或者是老的位置+老的容量。
            int idx = e.hash &amp; sizeMask;
            if (next == null)   //  Single node on list
                // 如果当前位置还不是链表，只是一个元素，直接赋值
                newTable[idx] = e;
            else &#123; // Reuse consecutive sequence at same slot
                // 如果是链表了
                HashEntry&lt;K,V&gt; lastRun = e;
                int lastIdx = idx;
                // 新的位置只可能是不便或者是老的位置+老的容量。
                // 遍历结束后，lastRun 后面的元素位置都是相同的
                for (HashEntry&lt;K,V&gt; last = next; last != null; last = last.next) &#123;
                    int k = last.hash &amp; sizeMask;
                    if (k != lastIdx) &#123;
                        lastIdx = k;
                        lastRun = last;
                    &#125;
                &#125;
                // ，lastRun 后面的元素位置都是相同的，直接作为链表赋值到新位置。
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;
                    // 遍历剩余元素，头插法到指定 k 位置。
                    V v = p.value;
                    int h = p.hash;
                    int k = h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
                &#125;
            &#125;
        &#125;
    &#125;
    // 头插法插入新的节点
    int nodeIndex = node.hash &amp; sizeMask; // add the new node
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
&#125;</code></pre>
<p><strong>get方法</strong>：</p>
<pre><code class="java">public V get(Object key) &#123;
    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
    HashEntry&lt;K,V&gt;[] tab;
    int h = hash(key);
    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    // 计算得到 key 的存放位置
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
        (tab = s.table) != null) &#123;
        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e != null; e = e.next) &#123;
            // 如果是链表，遍历查找到相同 key 的 value。
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                return e.value;
        &#125;
    &#125;
    return null;
&#125;</code></pre>
<ol>
<li>计算得到key的存放位置。</li>
<li>遍历指定位置查找相同key的value值。</li>
</ol>
<h3 id="JDK-1-8的ConcurrentHashMap"><a href="#JDK-1-8的ConcurrentHashMap" class="headerlink" title="JDK 1.8的ConcurrentHashMap"></a>JDK 1.8的ConcurrentHashMap</h3><p>Java 8的ConcurrentHashMap相对于Java 7来说变化比较大，不再是之前的<code>Segment数组 + HashEntry数组 + 链表</code>，而是<code>Node 数组 + 链表 / 红黑树</code>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><strong>初始化initTable</strong>：</p>
<pre><code class="java">/**
 * Initializes table, using the size recorded in sizeCtl.
 */
private final Node&lt;K,V&gt;[] initTable() &#123;
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) &#123;
        ／／　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。
        if ((sc = sizeCtl) &lt; 0)
            // 让出 CPU 使用权
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;
            try &#123;
                if ((tab = table) == null || tab.length == 0) &#123;
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    @SuppressWarnings(&quot;unchecked&quot;)
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                &#125;
            &#125; finally &#123;
                sizeCtl = sc;
            &#125;
            break;
        &#125;
    &#125;
    return tab;
&#125;</code></pre>
<p>从源码中可以发现ConcurrentHashMap的初始化是通过自旋和CAS操作完成的。里面需要注意的是变量<code>sizeCtl</code>，它的值决定着当前的初始化状态：</p>
<ul>
<li><code>-1</code>：说明正在初始化</li>
<li><code>-N</code>：说明有N-1个线程正在进行扩容</li>
<li>如果table没有初始化：表示table 初始化大小</li>
<li>如果table已经初始化：表示table容量</li>
</ul>
<p><strong>put方法</strong>：</p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(key, value, false);
&#125;

/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) &#123;
    // key 和 value 不能为空
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node&lt;K,V&gt;[] tab = table;;) &#123;
        // f = 目标位置元素
        Node&lt;K,V&gt; f; int n, i, fh;// fh 后面存放目标位置的元素 hash 值
        if (tab == null || (n = tab.length) == 0)
            // 数组桶为空，初始化数组桶（自旋+CAS)
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;
            // 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出
            if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))
                break;  // no lock when adding to empty bin
        &#125;
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        else &#123;
            V oldVal = null;
            // 使用 synchronized 加锁加入节点
            synchronized (f) &#123;
                if (tabAt(tab, i) == f) &#123;
                    // 说明是链表
                    if (fh &gt;= 0) &#123;
                        binCount = 1;
                        // 循环加入新的或者覆盖节点
                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            &#125;
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) &#123;
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break;
                            &#125;
                        &#125;
                    &#125;
                    else if (f instanceof TreeBin) &#123;
                        // 红黑树
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                       value)) != null) &#123;
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        &#125;
                    &#125;
                &#125;
            &#125;
            if (binCount != 0) &#123;
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            &#125;
        &#125;
    &#125;
    addCount(1L, binCount);
    return null;
&#125;</code></pre>
<ol>
<li>根据key计算出<code>hashCode</code>。</li>
<li>判断是否需要进行初始化。</li>
<li>即为当前key定位出<code>Node</code>，如果为空表示当前位置可以写入数据，利用<code>CAS</code>尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的<code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用<code>synchronized</code>锁写入数据。</li>
<li>如果数量大于<code>TREEIFY_THRESHOLD</code>则要执行树化方法，在treeifyBin中会首先判断当前数组长度≥64时才会将链表转换为红黑树。</li>
</ol>
<p><strong>get方法</strong>：</p>
<pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
    // key 所在的 hash 位置
    int h = spread(key.hashCode());
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;
        // 如果指定位置元素存在，头结点hash值相同
        if ((eh = e.hash) == h) &#123;
            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                // key hash 值相等，key值相同，直接返回元素 value
                return e.val;
        &#125;
        else if (eh &lt; 0)
            // 头结点hash值小于0，说明正在扩容或者是红黑树，find查找
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) &#123;
            // 是链表，遍历查找
            if (e.hash == h &amp;&amp;
                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                return e.val;
        &#125;
    &#125;
    return null;
&#125;</code></pre>
<ol>
<li>根据hash值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的value。</li>
<li>如果头节点hash值小于0，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol>
<blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://javaguide.cn/">JavaGuide</a></p>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2023年01月01日 20:00</p>
        <p>原始链接： <a class="post-url" href="/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/" title="Java基础八股文">http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/</a></p>
        <footer>
            <a href="http://muquanrui.com">
                <img src="/images/logo.png" alt="MU Quanrui">
                MU Quanrui
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/&title=《Java基础八股文》 — Quanrui's Blog&pic=cover.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/&title=《Java基础八股文》 — Quanrui's Blog&source=Carpe diem." data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Java基础八股文》 — Quanrui's Blog&url=http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/&via=http://muquanrui.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://muquanrui.com/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Programming/" class="color2">Programming</a>
      
    <a href="/tags/Java-Tutorial/" class="color4">Java Tutorial</a>
      
    <a href="/tags/Java基础/" class="color2">Java基础</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
        <div class= "post-toc-name">Table of Contents</div>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="post-toc-text">1 基础概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JVM-vs-JRE-vs-JDK"><span class="post-toc-text">JVM vs JRE vs JDK</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java-bytecode"><span class="post-toc-text">Java bytecode</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="post-toc-text">2 基本语法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="post-toc-text">基本数据类型和包装类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">基本类型与包装类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="post-toc-text">包装类型的缓存机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="post-toc-text">自动装箱与拆箱</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">字符型常量和字符串常量的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="post-toc-text">什么是可变长参数？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="post-toc-text">为什么Java中只有值传递？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BD%A2%E5%8F%82-amp-%E5%AE%9E%E5%8F%82"><span class="post-toc-text">形参&amp;实参</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92-amp-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="post-toc-text">值传递&amp;引用传递</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="post-toc-text">为什么Java只有值传递？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">3 面向对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="post-toc-text">面向对象三大特征</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">成员变量与局部变量的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">重载与重写的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="post-toc-text">静态方法为什么不能调用非静态成员?</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">静态方法和实例方法的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="post-toc-text">接口和抽象类的共同点和区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">深拷贝、浅拷贝、引用拷贝</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="post-toc-text">4 常用类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Object%E7%B1%BB"><span class="post-toc-text">Object类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">&#x3D;&#x3D;和equals()的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hashCode"><span class="post-toc-text">hashCode()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="post-toc-text">什么重写equals()时必须重写hashCode()方法？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#String%E7%B1%BB"><span class="post-toc-text">String类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-text">String、StringBuffer、StringBuilder的区别？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="post-toc-text">String 为什么是不可变的?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="post-toc-text">字符串常量池的作用了解吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#intern%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="post-toc-text">intern方法有什么作用?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#String-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F%E5%81%9A%E2%80%9C-%E2%80%9D%E8%BF%90%E7%AE%97%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="post-toc-text">String 类型的变量和常量做“+”运算时发生了什么？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BigDecimal-%E8%AF%A6%E8%A7%A3"><span class="post-toc-text">BigDecimal 详解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="post-toc-text">为什么浮点数运算会有精度丢失风险？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BigDecimal%E7%9A%84%E7%94%A8%E5%A4%84"><span class="post-toc-text">BigDecimal的用处</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-%E5%BC%82%E5%B8%B8"><span class="post-toc-text">5 异常</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-text">Exception和Error有什么区别？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Checked-Exception%E5%92%8CUnchecked-Exception%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-text">Checked Exception和Unchecked Exception有什么区别？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="post-toc-text">Throwable 类常用方法有哪些？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#finally"><span class="post-toc-text">finally</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8try-with-resources%E4%BB%A3%E6%9B%BFtry-catch-finally%EF%BC%9F"><span class="post-toc-text">如何使用try-with-resources代替try-catch-finally？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="post-toc-text">异常使用有哪些需要注意的地方？</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-I-O"><span class="post-toc-text">6 I&#x2F;O</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="post-toc-text">获取用键盘输入常用的两种方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java%E4%B8%ADI-O%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D"><span class="post-toc-text">Java中I&#x2F;O流分为几种?</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#I-O%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="post-toc-text">I&#x2F;O模型详解</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java%E4%B8%AD3%E7%A7%8D%E5%B8%B8%E8%A7%81I-O%E6%A8%A1%E5%9E%8B"><span class="post-toc-text">Java中3种常见I&#x2F;O模型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BIO-Blocking-I-O"><span class="post-toc-text">BIO (Blocking I&#x2F;O)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#NIO-Non-blocking-New-I-O"><span class="post-toc-text">NIO (Non-blocking&#x2F;New I&#x2F;O)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AIO-Asynchronous-I-O"><span class="post-toc-text">AIO (Asynchronous I&#x2F;O)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3"><span class="post-toc-text">Java序列化详解</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="post-toc-text">什么是序列化、反序列化?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="post-toc-text">Java序列化中如果有些字段不想进行序列化怎么办？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E5%88%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="post-toc-text">实际开发中有哪些用到序列化和反序列化的场景？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%AF%94"><span class="post-toc-text">常见序列化协议对比</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="post-toc-text">JDK 自带的序列化方式</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-%E5%8F%8D%E5%B0%84"><span class="post-toc-text">7 反射</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="post-toc-text">反射的作用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="post-toc-text">反射的缺点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="post-toc-text">类的加载过程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="post-toc-text">获取Class实例的几种方式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">代理模式和动态代理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86"><span class="post-toc-text">什么是代理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">代理模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">静态代理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">JDK动态代理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="post-toc-text">CGLIB动态代理</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#8-%E9%9B%86%E5%90%88"><span class="post-toc-text">8 集合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="post-toc-text">集合概述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#List-Set-Queue-Map%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">List, Set, Queue, Map四者的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-text">集合框架底层数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#List"><span class="post-toc-text">List</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Set"><span class="post-toc-text">Set</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Queue"><span class="post-toc-text">Queue</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map"><span class="post-toc-text">Map</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%9F"><span class="post-toc-text">为什么要使用集合？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3-List"><span class="post-toc-text">Collection子接口 - List</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList%E7%AE%80%E4%BB%8B"><span class="post-toc-text">ArrayList简介</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList%E4%B8%8EVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">ArrayList与Vector的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayList%E4%B8%8ELinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">ArrayList与LinkedList的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9%EF%BC%9ARandomAccess%E6%8E%A5%E5%8F%A3"><span class="post-toc-text">补充内容：RandomAccess接口</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3-Set"><span class="post-toc-text">Collection子接口 - Set</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Comparable%E4%B8%8EComparator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">Comparable与Comparator的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%97%A0%E5%BA%8F%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E7%9A%84%E5%90%AB%E4%B9%89"><span class="post-toc-text">无序性和不可重复性的含义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%AF%94%E8%BE%83HashSet%E3%80%81LinkedHashSet%E5%92%8CTreeSet%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="post-toc-text">比较HashSet、LinkedHashSet和TreeSet三者的异同</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collection%E5%AD%90%E6%8E%A5%E5%8F%A3-Queue"><span class="post-toc-text">Collection子接口 - Queue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Queue%E4%B8%8EDeque%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">Queue与Deque的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayDeque%E4%B8%8ELinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">ArrayDeque与LinkedList的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#PriorityQueue"><span class="post-toc-text">PriorityQueue</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="post-toc-text">Map接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">HashMap和Hashtable的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E5%92%8CHashSet%E5%8C%BA%E5%88%AB"><span class="post-toc-text">HashMap和HashSet区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E5%92%8CTreeMap%E5%8C%BA%E5%88%AB"><span class="post-toc-text">HashMap和TreeMap区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="post-toc-text">HashSet如何检查重复</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">HashMap的底层实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9"><span class="post-toc-text">HashMap的长度为什么是2的幂次方</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="post-toc-text">HashMap多线程操作导致死循环问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="post-toc-text">HashMap有哪几种常见的遍历方式?</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ConcurrentHashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">ConcurrentHashMap和Hashtable的区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ConcurrentHashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="post-toc-text">Collections 工具类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="post-toc-text">排序操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="post-toc-text">查找，替换操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="post-toc-text">同步控制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="post-toc-text">集合使用注意事项</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ArrayList%E6%BA%90%E7%A0%81-amp-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="post-toc-text">ArrayList源码 &amp; 扩容机制分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="post-toc-text">构造器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#add%E6%96%B9%E6%B3%95"><span class="post-toc-text">add方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ensureCapacityInternal%E6%96%B9%E6%B3%95"><span class="post-toc-text">ensureCapacityInternal方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ensureExplicitCapacity%E6%96%B9%E6%B3%95"><span class="post-toc-text">ensureExplicitCapacity方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#grow%E6%96%B9%E6%B3%95"><span class="post-toc-text">grow方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#hugeCapacity%E6%96%B9%E6%B3%95"><span class="post-toc-text">hugeCapacity方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#System-arraycopy%E5%92%8CArrays-copyOf%E6%96%B9%E6%B3%95"><span class="post-toc-text">System.arraycopy和Arrays.copyOf方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ensureCapacity%E6%96%B9%E6%B3%95"><span class="post-toc-text">ensureCapacity方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HashMap%E6%BA%90%E7%A0%81-amp-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="post-toc-text">HashMap源码 &amp; 底层数据结构分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-1-8%E4%B9%8B%E5%89%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-text">JDK 1.8之前底层数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-1-8%E4%B9%8B%E5%90%8E%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-text">JDK 1.8之后底层数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HashMap%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="post-toc-text">HashMap类属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-1"><span class="post-toc-text">构造器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#putMapEntries%E6%96%B9%E6%B3%95"><span class="post-toc-text">putMapEntries方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-1-8%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="post-toc-text">JDK 1.8的put方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-1-7%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="post-toc-text">JDK 1.7的put方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="post-toc-text">get方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#resize%E6%96%B9%E6%B3%95"><span class="post-toc-text">resize方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ConcurrentHashMap%E6%BA%90%E7%A0%81-amp-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="post-toc-text">ConcurrentHashMap源码 &amp; 底层数据结构分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-1-7%E7%9A%84ConcurrentHashMap"><span class="post-toc-text">JDK 1.7的ConcurrentHashMap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JDK-1-8%E7%9A%84ConcurrentHashMap"><span class="post-toc-text">JDK 1.8的ConcurrentHashMap</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2022/05/04/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9ATCP%E7%AF%87/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          图解网络笔记：TCP篇
        
      </span>
    </a>
  
  
    <a href="/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">图解网络笔记：HTTP篇</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="Programming/Java Tutorial/Java基础/Java基础八股文" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyvaQ34l4';
        var conf = 'dfbc2f31fdc91ffc75e2035195b4426d';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    |
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
    <div class="theme-info">
</p>


      <span class="post-count">本站博文总字数：724.9k</span>
      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2018~2023 MU Quanrui<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!--加载prettify代码高亮js-->
  <script type="text/javascript" src="/google-code-prettify/prettify.js"></script>
  <script type="text/javascript">
    $(document).ready(function(){
      $('pre').addClass('prettyprint linenums');
      $('code').addClass('prettyprint');
      prettyPrint();
    })
  </script>

<script>
  var mihoConfig = {
      root: "http://muquanrui.com",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Blog/">Blog</a><a class="category-link" href="/categories/Data-Structures-Algorithms/">Data Structures & Algorithms</a><a class="category-link" href="/categories/Database/">Database</a><a class="category-link" href="/categories/ENSEEIHT/">ENSEEIHT</a><a class="category-link" href="/categories/Framework/">Framework</a><a class="category-link" href="/categories/Java-Project/">Java Project</a><a class="category-link" href="/categories/Java-Tutorial/">Java Tutorial</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/Methodology/">Methodology</a><a class="category-link" href="/categories/Middleware/">Middleware</a><a class="category-link" href="/categories/Network/">Network</a><a class="category-link" href="/categories/Operating-System/">Operating System</a><a class="category-link" href="/categories/Photography/">Photography</a><a class="category-link" href="/categories/Problem-Solving/">Problem Solving</a><a class="category-link" href="/categories/Software/">Software</a><a class="category-link" href="/categories/Tech-Note/">Tech Note</a><a class="category-link" href="/categories/macOS/">macOS</a><a class="category-link" href="/categories/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/">墓畔回忆录</a><a class="category-link" href="/categories/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/">我的大学</a><a class="category-link" href="/categories/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/">法语学习</a><a class="category-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 17.5px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">法语学习</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.88px;">读书笔记</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/categories">
                    <i class="fa fa-book"></i><span>Categories</span>
                </a>
            </li>
            
            <li>
                <a  href="/tags">
                    <i class="fa fa-tags"></i><span>Tags</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 17.5px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">法语学习</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.88px;">读书笔记</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>









  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400,"vOffset":-30},"mobile":{"show":false},"react":{"opacity":0.8},"log":false});</script></body>
</html>



