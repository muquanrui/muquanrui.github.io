<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>图解网络笔记：HTTP篇 | Quanrui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="Quanrui's Blog" />
  
  <meta name="description" content="1 HTTP基本概念1.1 HTTP介绍HTTP（HyperText Transfer Protocol）是超文本传输协议。  协议：两个及以上参与者对一种行为的约定和规范。计算机世界里尤其是网络世界里协议无处不在，HTTP就是其中一种专门用来在两点之间交流通信、传输数据的约定和规范。 传输：一堆东西从A位置挪到B位置，或从B位置挪到A位置。这代表HTTP是一个双向协议，客户端可以通过HTTP发送">
<meta property="og:type" content="article">
<meta property="og:title" content="图解网络笔记：HTTP篇">
<meta property="og:url" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/index.html">
<meta property="og:site_name" content="Quanrui&#39;s Blog">
<meta property="og:description" content="1 HTTP基本概念1.1 HTTP介绍HTTP（HyperText Transfer Protocol）是超文本传输协议。  协议：两个及以上参与者对一种行为的约定和规范。计算机世界里尤其是网络世界里协议无处不在，HTTP就是其中一种专门用来在两点之间交流通信、传输数据的约定和规范。 传输：一堆东西从A位置挪到B位置，或从B位置挪到A位置。这代表HTTP是一个双向协议，客户端可以通过HTTP发送">
<meta property="og:locale">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/1cb6bc37597e4af8adfef412bfc57a42.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/%E7%BC%93%E5%AD%98etag.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/d92026ce085b401c95cf02b7ce9b7fae.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/tls1.2and1.3.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/19-HTTPS%E4%B8%8EHTTP.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/26-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/push.png">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/0-rtt.gif">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/http3quic.jpeg">
<meta property="og:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/http3frame.webp">
<meta property="article:published_time" content="2022-05-01T03:17:42.000Z">
<meta property="article:modified_time" content="2023-01-01T10:41:03.671Z">
<meta property="article:author" content="MU Quanrui">
<meta property="article:tag" content="Computer Science">
<meta property="article:tag" content="Network">
<meta property="article:tag" content="图解网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/images/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

  
<link rel="stylesheet" href="/css/style.css">


 <!--加载prettify代码高亮样式-->
<link href="/google-code-prettify/tranquil-heart.css" type="text/css" rel="stylesheet" />

  
<script src="/js/pace.min.js"></script>

  

  
  


  <!--加载条样式-->
  <style>
    .pace .pace-progress {
    	background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%);
    	height: 3px;
    }
    .pace .pace-progress-inner {
     	box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
    	border-top-color: #1E92FB;	/*上边框颜色*/
    	border-left-color: #1E92FB;	/*左边框颜色*/
    }
  </style>

<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div id="background"></div><!--背景颜色/图片-->
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">

        <div id="header-menu" class="header-menu-pos animated">


<a target="_blank" rel="noopener" href="https://github.com/muquanrui" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FFA500; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">Quanrui&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/categories">
                        <i class="fa fa-book"></i>
                        <span>Categories</span>
                    </a>
                    
                    <a  href="/tags">
                        <i class="fa fa-tags"></i>
                        <span>Tags</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.png" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        Quanrui&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        Carpe diem.
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="Home" target="_blank" href="//muquanrui.com">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/muquanrui">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Google" target="_blank" href="//google.com">
                            <i class="fa fa-google fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-Computer Science/Network/图解网络/图解网络笔记：HTTP篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      图解网络笔记：HTTP篇
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/Network/">Network</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2022-05-01
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>          
        </li>
      </ul>
       <span class="post-count">文章字数:14.3k字 &nbsp &nbsp  
         阅读时长:51分钟</span>
    </div>
  
        
          
      </header>
    

    <div class="article-entry post-content" itemprop="articleBody">

    
    



      
            
            <h1 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1 HTTP基本概念"></a>1 HTTP基本概念</h1><h2 id="1-1-HTTP介绍"><a href="#1-1-HTTP介绍" class="headerlink" title="1.1 HTTP介绍"></a>1.1 HTTP介绍</h2><p><strong>HTTP</strong>（HyperText Transfer Protocol）是超文本传输协议。</p>
<ul>
<li><strong>协议</strong>：<strong>两个及以上参与者</strong>对一种<strong>行为的约定和规范</strong>。计算机世界里尤其是网络世界里协议无处不在，HTTP就是其中一种专门用来在两点之间交流通信、传输数据的约定和规范。</li>
<li><strong>传输</strong>：一堆东西从A位置挪到B位置，或从B位置挪到A位置。这代表HTTP是一个<strong>双向协议</strong>，客户端可以通过HTTP发送请求给服务器端，服务器端也可以通过HTTP发送响应给客户端。</li>
<li><strong>超文本</strong>：文本是简单的字符或经过处理的图片、视频、压缩包。超文本是这些文本的混合体，还包括超链接功能，能从一个超文本跳跃到另一个超文本，HTML就是一种常见的超文本。HTTP传输的内容就是超文本。</li>
</ul>
<h2 id="1-2-HTTP报文格式"><a href="#1-2-HTTP报文格式" class="headerlink" title="1.2 HTTP报文格式"></a>1.2 HTTP报文格式</h2><p>参考<a target="_blank" rel="noopener" href="http://vor.ink/2022/03/20/Java/JavaWeb%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/#2-HTTP%E5%8D%8F%E8%AE%AE">JavaWeb知识点整理：HTTP协议</a>。</p>
<h2 id="1-3-HTTP常见的状态码"><a href="#1-3-HTTP常见的状态码" class="headerlink" title="1.3 HTTP常见的状态码"></a>1.3 HTTP常见的状态码</h2><p><img src="images/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="6-五大类HTTP状态码"></p>
<h3 id="1-3-1-状态码1xx"><a href="#1-3-1-状态码1xx" class="headerlink" title="1.3.1 状态码1xx"></a>1.3.1 状态码1xx</h3><p><strong>提示信息</strong>，是协议处理中的一种<strong>中间状态</strong>，实际用到的比较少。</p>
<h3 id="1-3-2-状态码2xx"><a href="#1-3-2-状态码2xx" class="headerlink" title="1.3.2 状态码2xx"></a>1.3.2 状态码2xx</h3><p>表示<strong>服务器成功处理了客户端的请求</strong>，也是我们最愿意看到的状态。</p>
<ul>
<li><code>200 OK</code>：最常见的成功状态码，表示一切正常。只要是非HEAD请求（HEAD请求表示只请求页面首部），服务器返回的响应都有会有响应体数据。</li>
<li><code>204 No Content</code>：也很常见，与200基本相同，区别是204没有响应体，使用场景可以是”save and continue editing” functionality。</li>
<li><code>206 Partial Content</code>：表示响应体的数据并不是资源的全部，只是其中的一部分，常用来做HTTP分块下载或断点续传。</li>
</ul>
<h3 id="1-3-3-状态码3xx"><a href="#1-3-3-状态码3xx" class="headerlink" title="1.3.3 状态码3xx"></a>1.3.3 状态码3xx</h3><p>这一类状态码表示请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li><code>301 Moved Permanently</code>：永久重定向，说明请求的资源已经不在了，需要改用新的URL重新发送请求获取资源。</li>
<li><code>302 Found</code>：临时重定向。说明请求的资源还在，只是这一次请求暂时用另一个URL来访问。</li>
</ul>
<p>301和302都会在响应报文的响应头中使用<code>Location</code>字段，指明后续要重定向到的URL，浏览器就能自动跳转到新的请求URL。</p>
<ul>
<li><code>304 Not Modified</code>：不具备跳转的含义，表示资源未修改，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li>
</ul>
<h3 id="1-3-4-状态码4xx"><a href="#1-3-4-状态码4xx" class="headerlink" title="1.3.4 状态码4xx"></a>1.3.4 状态码4xx</h3><p>经常会看到的错误状态码，表示<strong>客户端请求报文有误</strong>，服务器无法处理。</p>
<ul>
<li><code>400 Bad Request</code>：客户端请求的报文有错误，但只是个笼统的没具体分类的错误。</li>
<li><code>403 Forbidden</code>：请求没出错，但是服务器端禁止访问该资源。</li>
<li><code>404 Not Found</code>：特别常见，表示请求的资源在服务器上找不到或不存在，所以无法提供给客户端。</li>
</ul>
<h3 id="1-3-5-状态码5xx"><a href="#1-3-5-状态码5xx" class="headerlink" title="1.3.5 状态码5xx"></a>1.3.5 状态码5xx</h3><p>也是错误状态码，表示客户端请求报文没有问题，是<strong>服务器内部处理时发生了错误</strong>。</p>
<ul>
<li><code>500 Internal Server Error</code>：类似于400，是个笼统的通用的错误码，没法知道服务器具体发生啥错误。</li>
<li><code>501 Not Implemented</code>：客户端请求的功能暂时还不被支持。</li>
<li><code>502 Bad Gateway</code>：通常是服务器作为网关服务器或代理服务器时返回的错误码。表示服务器自身工作正常，但是后端服务器发生了错误。</li>
<li><code>503 Service Unavailable</code>：服务器当前很忙，暂时无法响应。</li>
</ul>
<h2 id="1-4-HTTP请求头和响应头的常见字段"><a href="#1-4-HTTP请求头和响应头的常见字段" class="headerlink" title="1.4 HTTP请求头和响应头的常见字段"></a>1.4 HTTP请求头和响应头的常见字段</h2><h3 id="1-4-1-请求头字段"><a href="#1-4-1-请求头字段" class="headerlink" title="1.4.1 请求头字段"></a>1.4.1 请求头字段</h3><pre><code>Host: www.A.com</code></pre>
<p><code>Host</code>字段：不同的域名通过A记录或者CNAME方式可以连接都同一个IP下，同一个IP也可以设置多个不同站点，因此当我们访问不同的域名时实际上可能被转发到同一IP，怎么区分这些不同的站点呢？就是用的Host字段，Host字段被用来<strong>在客户端请求报文中指定服务器的域名</strong>，从而可以把请求发往同一台服务器（同一IP地址）上的不同网站。</p>
<pre><code>Connection: keep-alive</code></pre>
<p><code>Connection</code>字段：最常用于客户端请求报文<strong>要求服务器使用TCP持久连接</strong>，以便其他请求复用同一个连接。HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定该首部字段的值为<code>Keep-Alive</code>。</p>
<pre><code>Accept: */*</code></pre>
<p><code>Accept</code>字段：表示客户端可以接收的响应数据格式，上面字段值表示客户端接收任何格式的数据。</p>
<h3 id="1-4-2-响应头字段"><a href="#1-4-2-响应头字段" class="headerlink" title="1.4.2 响应头字段"></a>1.4.2 响应头字段</h3><pre><code>Content-Length: 1000</code></pre>
<p><code>Content-Length</code>字段：用于服务器响应报文中标明此次响应的数据长度。</p>
<pre><code>Content-Type: text/html; charset=utf-8</code></pre>
<p><code>Content-Type</code>字段：服务器响应时告诉客户端本次响应数据的格式，客户端可以接收的格式见上文<code>Accept</code>。</p>
<pre><code>Content-Encoding: gzip</code></pre>
<p><code>Content-Encoding</code>字段：说明数据的压缩方式。客户端可以接受的压缩方式由请求报文的<code>Accept-Encoding</code>指定。</p>
<h1 id="2-GET与POST"><a href="#2-GET与POST" class="headerlink" title="2 GET与POST"></a>2 GET与POST</h1><h2 id="2-1-GET与POST简介"><a href="#2-1-GET与POST简介" class="headerlink" title="2.1 GET与POST简介"></a>2.1 GET与POST简介</h2><p><code>GET</code>在RFC规范中的定义是<strong>从服务器获取指定的资源</strong>，这给资源可以是文本、页面、音视频等。GET的请求参数直接以<strong>Query String</strong>的形式<strong>拼接在URL后面</strong>。URL规定只支持ASCII，所以GET的请求参数也只能是ASCII字符，HTTP本身对URL长度没有规定，但是浏览器会限制，所以GET的请求参数大小是有限的。</p>
<p><code>POST</code>在RFC规范中的定义是根据<strong>Request Payload</strong>即请求负荷对指定的资源做出处理，具体的处理方式根据资源的不同而变化。POST的请求参数<strong>写在请求报文体中</strong>，数据格式可以任意，只要客户端与服务器端协商好就行，而且浏览器也不会对报文体的大小做限制，即POST的请求参数大小没有限制。</p>
<h2 id="2-2-GET与POST的安全和幂等"><a href="#2-2-GET与POST的安全和幂等" class="headerlink" title="2.2 GET与POST的安全和幂等"></a>2.2 GET与POST的安全和幂等</h2><p><strong>安全</strong>指请求方法不会破坏服务器上的资源，<strong>幂等</strong>表示多次执行同样的操作，得到的结果也都是相同的。</p>
<p>从RFC的语义定义上分析：</p>
<ul>
<li><strong>GET方法是安全且幂等的</strong>。它是<strong>只读</strong>的操作，在服务器端不发生改变的情况下，无论操作多少次，服务器上的数据都是安全的，得到的响应结果也都是相同的。所以<strong>可以对GET请求的数据做缓存</strong>，这个缓存可以做到浏览器本身上（彻底避免浏览器发送请求），也可以做到代理服务器上（比如Nginx），GET请求在浏览器中也可以被保存为书签。</li>
<li><strong>POST方法不安全且不幂等</strong>。POST是<strong>新增或提交</strong>数据的操作，会修改服务器上的资源，所以是不安全的，多次提交数据就会多次修改或创建资源，所以也是不幂等的。所以浏览器一般<strong>不会对POST请求做缓存</strong>，也不能把POST请求保存为书签。</li>
</ul>
<p>实际开发过程中，开发者不一定会按照RFC规范定义来实现GET和POST方法，比如可以用GET来实现增删，POST实现查询等。</p>
<h1 id="3-HTTP缓存技术"><a href="#3-HTTP缓存技术" class="headerlink" title="3 HTTP缓存技术"></a>3 HTTP缓存技术</h1><p>一些HTTP请求是有重复性的，如果每次请求得到的数据都是一样的，我们可以把这对请求-响应的数据都<strong>缓存在本地</strong>，下一次需要的时候直接读取本地数据，不必再通过网络请求服务器了，这使得HTTP/1.1的性能肉眼可见的提升。</p>
<p>通过<strong>缓存技术</strong>可以避免发送HTTP请求，HTTP设计者在很早就考虑到缓存的应用所以设计了不少针对缓存字段在HTTP协议的头部。具体来说，HTTP缓存的实现方式有两种：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p>
<h2 id="3-1-强制缓存"><a href="#3-1-强制缓存" class="headerlink" title="3.1 强制缓存"></a>3.1 强制缓存</h2><p><strong>强制缓存</strong>指的是决定是否使用缓存的主动性在浏览器这边，<strong>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</strong>。</p>
<p><img src="images/1cb6bc37597e4af8adfef412bfc57a42.png" alt="1cb6bc37597e4af8adfef412bfc57a42"></p>
<p>上图中返回200成功的状态码，标识了from disk cache，意思就是使用了强制缓存。</p>
<p>强制缓存的实现依靠的是HTTP Response Header的两个字段实现，它们都<strong>表示资源在客户端缓存的有效期</strong>：</p>
<ul>
<li><code>Cache-Control</code>：相对时间。</li>
<li><code>Expires</code>：绝对时间。</li>
</ul>
<p>如果响应头中两个字段都存在的话，<code>Cache-Control</code>的优先级更高。<code>Cache-Control</code>的选项也更多，设置可以更加精细，推荐使用它来实现强制缓存，具体流程是：</p>
<ol>
<li>浏览器第一次请求访问服务器资源时，服务器在返回这个资源的同时，在响应头中加上<code>Cache-Control</code>字段，并为这个字段设置值为过期时间大小。</li>
<li>浏览器再次请求同一资源时，会先通过请求资源的时间与<code>Cache-Control</code>中设置的过期时间大小来<strong>计算出该资源是否过期</strong>，如果没有直接使用缓存，过期才重新请求服务器。</li>
<li>服务器收到再次请求后，更新响应头的<code>Cache-Control</code>字段值。</li>
</ol>
<h2 id="3-2-协商缓存"><a href="#3-2-协商缓存" class="headerlink" title="3.2 协商缓存"></a>3.2 协商缓存</h2><p><strong>协商缓存</strong>指的是决定是否使用缓存的主动权在服务器这边，上文提到的状态码<code>304</code>就是服务器在告诉客户端浏览器可以使用本地缓存资源。所以协商缓存就是<strong>浏览器与服务器端协商过后，通过协商结果来判断是否使用本地缓存</strong>。</p>
<p><img src="images/%E7%BC%93%E5%AD%98etag.png" alt="缓存etag"></p>
<p>协商缓存可以基于两种头部实现：</p>
<ol>
<li>Request Header里的<code>If-Modified-Since</code>字段和Response Header里的<code>Last-Modified</code>字段，二者的值都是GMT格式的时间字符串：<ul>
<li>浏览器第一次请求服务器资源时，响应头中带上<code>Last-Modified</code>字段，标识这个资源在服务器端的最后修改时间。</li>
<li>浏览器收到响应后将资源换存在本地，下一次请求时在请求头中带上<code>If-Modified-Since</code>字段，这个字段值就是之前得到的<code>Last-Modified</code>字段值，询问服务器这个资源是否已经被修改更新了。</li>
<li>浏览器收到请求后通过比较<code>If-Modified-Since</code>字段值和被请求资源在服务器上的最后修改时间判断是否需要重新响应资源。如果该资源没有被修改服务器会直接返回<code>304 Not Modified</code>，不会带上资源内容，也不会添加<code>Last-Modified</code>字段；如果资源更新了，就正常响应资源<code>200 OK</code>，并带上新的<code>Last-Modified</code>。</li>
</ul>
</li>
<li>Request Header里的<code>If-None-Match</code>字段和Response Header里的<code>ETag</code>字段，二者的值是由服务器为每一个资源生成的唯一标识串，只要资源发生改变，这个标识串也会发生改变：<ul>
<li>浏览器第一次请求服务器资源时，服务器可以通过文件本身计算出一个Hash并在响应头添加<code>ETag</code>字段把这个标识串返回给浏览器。</li>
<li>浏览器再次请求该资源时会在请求头带上<code>If-None-Match</code>字段，这个值就是之前收到响应中的<code>ETag</code>字段，服务器收到后通过比较两者是否一致来判定文件内容是否被改变。</li>
<li>与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于在服务器上<code>ETag</code>重新计算过，response header中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化。</li>
</ul>
</li>
</ol>
<p>HTTP/1.1中<code>ETag</code>的出现主要是为了解决几个<code>Last-Modified</code>比较难解决的问题：</p>
<ul>
<li>一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候使用<code>ETag</code>可以避免重新响应资源内容。</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，比如1s内修改N次，<code>If-Modified-Since</code>能检查到的粒度是秒级的，这时就不够用了，但是<code>Etag</code>就能够保证这种需求下客户端在1秒内能刷新N次Cache。</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>
<p>因此如果两个字段同时存在，<code>ETag</code>的优先级比<code>If-Modified-Since</code>要高。优先级的顺序如下：</p>
<p><code>Cache-Control</code> &gt; <code>Expires</code> &gt; <code>ETag</code> &gt; <code>Last-Modified</code></p>
<h2 id="3-3-缓存实现的流程"><a href="#3-3-缓存实现的流程" class="headerlink" title="3.3 缓存实现的流程"></a>3.3 缓存实现的流程</h2><p><img src="images/d92026ce085b401c95cf02b7ce9b7fae.png" alt="d92026ce085b401c95cf02b7ce9b7fae"></p>
<p>注意：协商缓存的字段都要配合强制缓存中的<code>Cache-Control</code>来使用，<strong>只有在未能命中强制缓存时才会发起带有协商缓存字段的请求</strong>。</p>
<h1 id="4-HTTP特性"><a href="#4-HTTP特性" class="headerlink" title="4 HTTP特性"></a>4 HTTP特性</h1><h2 id="4-1-HTTP-1-1的优点"><a href="#4-1-HTTP-1-1的优点" class="headerlink" title="4.1 HTTP/1.1的优点"></a>4.1 HTTP/1.1的优点</h2><p>HTTP（这里指1.1版本）最凸出的优点是简单、灵活和易于扩展、应用广泛和跨平台。</p>
<ol>
<li>简单：HTTP的基本报文格式就是Header + Body的形式，Header的格式是Key-Value键值对的简单文本形式，易于理解。</li>
<li>灵活和易于扩展：HTTP协议里的请求方法、URL/URI、状态码、头字段等组成要求都不是固定似的，允许开发人员自定义扩充。HTTP工作在应用层，它的下层可以随意变化，比如HTTPS就是在HTTP和TCP之间增加了SSL/TLS安全传输层，HTTP/3甚至把TCP替换成了基于UDP的QUIC。</li>
<li>应用广泛和跨平台：HTTP的应用范围随着互联网的发展不断变化，从PC的浏览器到手机上各种APP，应用遍地开花，同时天然具有跨平台的优点。</li>
</ol>
<h2 id="4-2-HTTP-1-1的缺点"><a href="#4-2-HTTP-1-1的缺点" class="headerlink" title="4.2 HTTP/1.1的缺点"></a>4.2 HTTP/1.1的缺点</h2><p>HTTP协议的所谓的缺点有的其实是双刃剑，如无状态、明文传输，同时还有一大缺点：不安全！</p>
<ol>
<li><strong>无状态</strong>：</li>
</ol>
<p>优点：服务器不会去记忆HTTP的状态，不需要额外的资源来记录状态信息，这能减轻服务器的负担，从而把更多的CPU和内存等资源用来对外提供服务。</p>
<p>缺点：服务器没有记忆会使得在完成关联操作时非常麻烦。</p>
<ul>
<li>例如登陆 -&gt; 添加购物车 -&gt; 下单 -&gt; 结算 -&gt; 支付，这一系列操作都基于同一个用户的身份，但是服务器不知道这些请求是关联操纵，每一次都要询问确认一遍用户的身份信息。</li>
</ul>
<p>对于无状态的问题，解决方案很多，比较简单的方式是使用<code>Cookie</code>技术。</p>
<p><code>Cookie</code>通过在请求和响应报文中写入Cookie信息来控制客户端的状态，这样客户端第一次请求被服务器下发<code>Cookie</code>后，后续请求再带上这个<code>Cookie</code>就能被服务器识别了。</p>
<ol start="2">
<li><strong>明文传输</strong>：</li>
</ol>
<p>明文的意思是传输过程中HTTP携带的所有信息都能被阅读到，比如浏览器的控制台和Wireshark抓包后都可以直接肉眼查看，方便了调试，但同时也让HTTP的所有信息都暴露咋光天化日之下，毫无安全和隐私可言。</p>
<ol start="3">
<li><strong>不安全</strong>：</li>
</ol>
<p>HTTP的严重缺电就是不安全问题，主要有：</p>
<ul>
<li>通信使用<strong>不加密明文传输</strong>，内容很容易被<strong>窃听</strong>，比如账号信息泄漏。</li>
<li><strong>无法验证报文的完整性</strong>，判断不了是否被<strong>篡改</strong>，比如网页上植入垃圾广告。</li>
<li><strong>不验证通信方的身份</strong>，有可能遭遇<strong>冒充</strong>，比如访问假的淘宝。</li>
</ul>
<p>HTTP不安全的问题将通过HTTPS的方式来解决。</p>
<h2 id="4-3-HTTP-1-1的性能"><a href="#4-3-HTTP-1-1的性能" class="headerlink" title="4.3 HTTP/1.1的性能"></a>4.3 HTTP/1.1的性能</h2><p>HTTP协议基于<strong>TCP/IP</strong>协议栈，使用了<strong>Request - Response</strong>通信模式，评价其性能关键就基于这两点。</p>
<ol>
<li><strong>长连接</strong>（Keep-Alive）：</li>
</ol>
<p>早起HTTP/1.0性能的一大问题在于每次发器一个请求，都要重新建立一次TCP连接（三次握手），而且是串行请求，这种短连接形式做了无谓的TCP连接建立和断开，增加了通信开销。</p>
<p>HTTP/1.1提出了长连接（持久连接）通信方式，这种方式减少了TCP连接的重复建立和断开的额外开销，减轻了服务器负载。</p>
<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则一直保持TCP连接状态。此外如果某个HTTP长连接在一定时间内和服务器没有任何数据交互，服务器也会主动断开这个连接。</p>
<p><img src="images/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="16-短连接与长连接"></p>
<p>HTTP/1.0中也有长连接，但是默认关闭，要打开需要在请求包头中添加<code>Connection: Keep-Alive</code>，服务端接收到后做出的响应报文中也会添加同样的字段，这样就能打开长连接功能了。</p>
<p>从HTTP/1.1开始，Keep-Alive是被默认开启的，如果要关闭该功能可以在HTTP请求头添加<code>Connection: close</code>。</p>
<p>为了避免没有传输数据的长连接存在浪费资源，Web浏览器一般会提供<code>keepalive_timeout</code>参数用来指定HTTP长连接的超时时间，定时器会在超时后触发回调函数来释放该连接。</p>
<ol start="2">
<li><strong>管道网络传输</strong>：</li>
</ol>
<p>HTTP/1.1的长连接方式使得管道（Pipeline）网络传输成为可能，即在一个TCP连接里面，客户端可以发起多个请求，而不必等一个请求收到响应再发送下一个，减少整体的响应时间。</p>
<p>但是<strong>服务器必须要按照接收请求的顺序来对这些管道化请求做响应</strong>。这就导致如果处理某一个请求耗时比较长，在它后面的请求都会在服务器端被阻塞，也就是队头阻塞。</p>
<ol start="3">
<li><strong>队头阻塞</strong></li>
</ol>
<p>Request - Response的通信模式加剧了HTTP的性能问题，<strong>HTTP/1.1管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p>
<h1 id="5-HTTPS"><a href="#5-HTTPS" class="headerlink" title="5 HTTPS"></a>5 HTTPS</h1><h2 id="5-1-HTTP与HTTPS的区别"><a href="#5-1-HTTP与HTTPS的区别" class="headerlink" title="5.1 HTTP与HTTPS的区别"></a>5.1 HTTP与HTTPS的区别</h2><ul>
<li>HTTP信息是明文传输，存在严重的安全问题，HTTPS是为了解决HTTP的安全问题而提出的，在HTTP和TCP之间加入了SSL/TLS安全协议，使得报文能够加密传输，</li>
<li>HTTP连接建立相对简单，TCP三次握手建立连接后就直接进行HTTP请求和响应的报文传输，而HTTPS在TCP三次握手建立连接后还要加入SSL/TLS的握手过程，然后进行加密报文的传输。</li>
<li>HTTP的端口号是80，HTTPS是443。</li>
<li>HTTPS需要向CA（Certificate Authority）即证书权威机构申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<h2 id="5-2-HTTPS解决了HTTP哪些问题"><a href="#5-2-HTTPS解决了HTTP哪些问题" class="headerlink" title="5.2 HTTPS解决了HTTP哪些问题"></a>5.2 HTTPS解决了HTTP哪些问题</h2><p>上文提过，HTTP的明文传输、不验证通信方、无法验证报文完整性带来的安全问题主要有：</p>
<ul>
<li>窃听风险</li>
<li>篡改风险</li>
<li>冒充风险</li>
</ul>
<p>HTTPS通过引入<code>SSL/TLS</code>协议，SSL (Secure Sockets Layer) 和TLS（Transport Layer Security）是安全协议的不同版本，SSL是TLS的前身，<code>SSL/TLS</code>协议使用以下手段分别解决了上述三个问题：</p>
<ul>
<li><strong>信息加密</strong>：<strong>混合加密</strong>的方式实现信息的机密性。</li>
<li><strong>校验机制</strong>：<strong>摘要算法</strong>为数据生成独一无二的指纹校验完整性。</li>
<li><strong>身份证书</strong>：服务器的公钥放入到<strong>数字证书</strong>中。</li>
</ul>
<ol>
<li><strong>混合加密</strong>：</li>
</ol>
<p>HTTPS采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的混合加密方式。</p>
<ul>
<li>通信建立过程中采用非对称加密的方式交换会话密钥，后续不再使用非对称加密。</li>
<li>通信过程中全部使用对称加密的会话密钥方式加密明文数据。</li>
</ul>
<p>之所以采用混合加密是因为：</p>
<ul>
<li>对称加密<strong>只使用一个密钥</strong>，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li>非对称加密<strong>使用公钥和私钥</strong>，公钥可以任意分发而私钥保密，解决了密钥交换问题，但是速度比较慢。</li>
</ul>
<ol start="2">
<li><strong>摘要算法</strong>：</li>
</ol>
<p>客户端在发送明文之前会通过摘要算法算出明文的<strong>指纹</strong>，发送的时候<strong>把指纹+明文一同加密成密文</strong>发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的指纹和当前算出的指纹做比较，若指纹相同，则说明数据是完整的。</p>
<ol start="3">
<li><strong>数字证书</strong>：</li>
</ol>
<p>客户端先向服务器索要公钥，用公钥加密信息，服务器收到秘文后，用自己的私钥解密。这个过程的问题在于，如何保证服务器的公钥没有被篡改且可信呢？</p>
<p>这需要借助于第三方权威机构<strong>CA</strong>，将服务器公钥放在由CA颁发的数字证书中，只要证书是可信的，公钥就是可信的。通过数字证书的方式保证公钥的身份，从而避免冒充风险。</p>
<h2 id="5-3-HTTPS使用RSA建立连接"><a href="#5-3-HTTPS使用RSA建立连接" class="headerlink" title="5.3 HTTPS使用RSA建立连接"></a>5.3 HTTPS使用RSA建立连接</h2><p>HTTPS是应用层协议，首先需要完成TCP的连接建立，然后就是SSL/TLS的建立过程，也就是TLS握手阶段，涉及四次通信，也就是2个RTT。</p>
<p>SSL/TLS协议基本流程是：</p>
<ol>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商产生会话密钥。</li>
<li>双方都采用会话密钥进行加密通信。</li>
</ol>
<p>考虑到性能问题，在传输数据的阶段双方加密信息使用的是<strong>对称加密</strong>，对称加密密钥不能被泄漏，即使数据信息被窃取，因为没有对称加密密钥，信息也无法被解密。但是接收方却需要对称加密密钥来解密，如何保证对称加密的密钥能安全传送给接收方呢？这个过程使用<strong>非对称加密</strong>的方式来保护对密钥的协商，具体工作就由<strong>密钥交换（或协商）算法</strong>完成。</p>
<p>事实上，不同的密钥交换算法，TLS握手过程会有一些区别。</p>
<h3 id="5-3-1-RSA握手过程"><a href="#5-3-1-RSA握手过程" class="headerlink" title="5.3.1 RSA握手过程"></a>5.3.1 RSA握手过程</h3><p>传统的TLS握手使用的是<strong>RSA密钥协商算法</strong>来实现密钥交换。TLS证书部署在服务器端时，证书文件包含<strong>一对公私钥</strong>，公钥会在TLS握手阶段传递给客户端，私钥则一直保留在服务器端，一定要确保私钥不被窃取。</p>
<p>在RSA密钥协商算法中，客户端生成随机密钥，使用服务器端的公钥加密后，传输回服务器，根据非对称加密算法的要求，<strong>公钥加密的消息只能通过对应的私钥解密</strong>，服务器端解密后，双方就得到了相同的密钥，再用这个密钥加密之后要互相传递的消息。详细过程如下：</p>
<p><img src="images/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpeg" alt="23-HTTPS工作流程"></p>
<ol>
<li><strong>TLS第一次握手</strong></li>
</ol>
<p>首先，客户端向服务器发起加密通信请求，也就是<strong>ClientHello</strong>：</p>
<ul>
<li>客户端支持的SSL/TLS协议<code>Version</code>，如TLS 1.2版本。</li>
<li>客户端产生的随机数<code>Client Random</code>，后续将用于生成会话密钥。</li>
<li>客户端支持的密码套件列表<code>Cipher Suites</code>，如RSA加密算法等。</li>
</ul>
<ol start="2">
<li><strong>TLS第二次握手</strong></li>
</ol>
<p>服务器收到客户端请求后，向客户端发出响应，也就是<strong>ServerHello</strong>：</p>
<ul>
<li>确认是否支持SSL/TLS协议<code>Version</code>，如果浏览器不支持，加密通信将被关闭。</li>
<li>服务器产生的随机数<code>Server Random</code>，后续将用于生成会话密钥。</li>
<li>确认要使用的密码套件<code>Cipher Suite</code>，如<code>TLS_RSA_WITH_AES_128_GCM_SHA256</code>，表示握手时的密钥交换算法使用RSA，证书验证的签名算法使用RSA（因为WITH前只有一个字段），握手后使用AES对称加密算法，密钥长度128位，分组模式GCM，用于消息认证和产生随机数的摘要算法使用SHA256。</li>
</ul>
<p>然后服务器端为了证明自己的身份，发送消息<strong>Certificate</strong>：</p>
<ul>
<li>服务器的数字证书信息<code>Certificates</code>。</li>
</ul>
<p>再之后服务器端发送消息<strong>Server Hello Done</strong>，表示我该给你的给完了，本次打招呼完毕。</p>
<ol start="3">
<li><strong>TLS第三次握手</strong></li>
</ol>
<p>客户端收到响应后，首先通过浏览器或操作系统中的CA公钥，<strong>确认服务器的数字证书的真实性</strong>。</p>
<p>如果证书没问题，客户端从数字证书中取出服务器的公钥，发送消息<strong>Client Key Exchange</strong>：</p>
<ul>
<li>客户端再次产生的一个随机数<code>Pre-Master Secret</code>，并使用服务器端提供的RSA公钥加密该随机数。服务端收到后，用自己的RSA私钥解密也得到该随机数。</li>
</ul>
<p>自此服务器和客户端有了三个随机数：<code>Client Random</code>、<code>Server Random</code>、<code>Pre-Master Secret</code>，接着就用双方协商的加密算法，生成主密钥<code>Master Secret</code>，本次通信的<strong>会话秘钥</strong><code>Session Key</code>就由<code>Master Secret</code>生成，会话密钥是对称加密密钥，用于对后续的HTTP请求和响应的数据加密解密。</p>
<p>生成完会话密钥后，客户端发送消息<strong>Change Cipher Spec</strong>：</p>
<ul>
<li>加密通信算法改变的通知，表示随后的信息都将用会话密钥加密通信。</li>
</ul>
<p>再然后，客户端发送消息<strong>Encrypted Handshake Message</strong>：</p>
<ul>
<li>客户端握手结束的通知，表示客户端的握手阶段已经结束，同时把之前所有内容发生的数据做摘要，再用会话密钥加密一下，用来供服务器端校验，验证加密通信是否可用以及之前。</li>
</ul>
<ol start="4">
<li><strong>TLS第四次握手</strong></li>
</ol>
<p>服务器端的操作也是一样，发送<strong>Change Cipher Spec</strong>和<strong>Encrypted Handshake Message</strong>，如果双方加密解密都没问题，握手就正式完成。</p>
<h3 id="5-3-2-RSA算法的缺陷"><a href="#5-3-2-RSA算法的缺陷" class="headerlink" title="5.3.2 RSA算法的缺陷"></a>5.3.2 RSA算法的缺陷</h3><p>使用RSA密钥协商算法的最大问题是<strong>不支持前向保密</strong>。</p>
<p>正如前文所说，服务器端有一对公私钥，随机数<code>Pre-Master Secret</code>在客户端用公钥加密，回到服务器端被私钥解密，这个过程的安全基于的前提是服务器端的私钥没有被泄漏，而如果服务器端的私钥被泄漏，第三方便可以生成同样的<code>Master Secret</code>和会话密钥，之前被截获的所有消息密文就都能被破解了。</p>
<h2 id="5-4-HTTPS使用ECDHE建立连接"><a href="#5-4-HTTPS使用ECDHE建立连接" class="headerlink" title="5.4 HTTPS使用ECDHE建立连接"></a>5.4 HTTPS使用ECDHE建立连接</h2><h3 id="5-4-1-DH算法和DHE算法"><a href="#5-4-1-DH算法和DHE算法" class="headerlink" title="5.4.1 DH算法和DHE算法"></a>5.4.1 DH算法和DHE算法</h3><p><strong>DH算法</strong>（Diffie–Hellman key exchange）是一种非对称加密算法，可以用于密钥交换，该算法的核心思想是<strong>离散对数</strong>：</p>
<p><img src="images/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" alt="离散对数"></p>
<p>底数a和模数p是离散对数的公共参数，也就是公开的，b是真数，i是对数，知道i可以轻易求b，但是知道b却很难推算出i，尤其是当p是一个很大的质数的时候。</p>
<p>DH算法的过程：</p>
<ol>
<li>首先确定使用的公共参数：底数G，模数P；</li>
<li>客户端和服务器端分别生成一个随机整数a和b作为各自的私钥；</li>
<li>客户端的公钥为：A = G ^ a ( mod P )，服务器端的公钥为：B = G ^ b ( mod P )；</li>
<li>双方交换各自的公钥，客户端得到B，服务器端得到A；</li>
<li>客户端执行运算B ^ a ( mod P )，服务器端执行运算A ^ b ( mod P )，根据幂运算的规律显然两个结果相等，记为K；</li>
<li>K就是生成的对称加密密钥，作为后续的会话密钥使用。</li>
</ol>
<p>因为离散对数的运算规律双方的私钥a和b很难被获取，因此DH密钥交换算法是安全的。</p>
<p>根据私钥的生成方式，DH算法有两种实现：</p>
<ul>
<li>static DH算法（已废弃）：<strong>一方的私钥是静态的</strong>，通常是服务器端，只有客户端的私钥随机生成，黑客截获海量的密钥协商过程然后暴力破解是可能获取服务器的私钥的，然后就能计算出会话密钥了，之前的加密数据都都能被破解，所以<strong>static DH算法也不具备前向安全性</strong>。</li>
<li>DHE算法（常用）：<strong>双方的私钥在每次密钥交换时都随机生成</strong>，E就代表ephemeral，即使黑客破解了一次通信的私钥，其他通信过程依然是安全，这样就<strong>保证了前向安全</strong>。</li>
</ul>
<h3 id="5-4-2-ECDHE算法"><a href="#5-4-2-ECDHE算法" class="headerlink" title="5.4.2 ECDHE算法"></a>5.4.2 ECDHE算法</h3><p>DHE算法因为要做大量乘法存在计算性能问题，所以现在最广泛应用的密钥交换算法<strong>ECDHE算法</strong>被提出。ECDHE算法在DHE算法的基础上使用了ECC椭圆曲线的特性，可以用更少的计算量计算出公钥以及最终的会话密钥。</p>
<p>ECDHE算法的过程：</p>
<ol>
<li>客户端和服务器协商确定好使用哪种椭圆曲线，和曲线上的基点G，这两个参数都是公开的；</li>
<li>双方针对此次通信随机生成自己的私钥d1和d2；</li>
<li>双方计算出自己的公钥，Q1 = d1 * G，Q2 = d2 * G；</li>
<li>双方交换各自的公钥；</li>
<li>客户端计算点(x1, y1) = d1 * Q2，服务器计算点(x2, y2) = d2 * Q1，很明显计算结果的x1和x2是相同的，这个结果就是生成的会话密钥。</li>
</ol>
<h3 id="5-4-3-ECDHE握手过程"><a href="#5-4-3-ECDHE握手过程" class="headerlink" title="5.4.3 ECDHE握手过程"></a>5.4.3 ECDHE握手过程</h3><ol>
<li><strong>TLS第一次握手</strong></li>
</ol>
<p>客户端发送消息<strong>Client Hello</strong>：</p>
<ul>
<li>客户端使用的TLS <code>Version</code>。</li>
<li>生成的随机数<code>Client Random</code>。</li>
<li>支持的密码套件列表<code>Cipher Suites</code>。</li>
</ul>
<ol start="2">
<li><strong>TLS第二次握手</strong></li>
</ol>
<p>服务器端收到客户端打招呼后，也发送消息<strong>Server Hello</strong>：</p>
<ul>
<li>确认TLS <code>Version</code>。</li>
<li>生成的随机数<code>Server Random</code>。</li>
<li>选择使用的密码套件<code>Cipher Suite</code>，比如<code>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</code>，表示密钥协商算法使用ECDHE，签名算法使用RSA，握手后使用对成加密算法AES，密钥长度256位，分组模式GCM，摘要算法使用SHA384。</li>
</ul>
<p>然后服务器端为了证明自己的身份，发送消息<strong>Certificate</strong>：</p>
<ul>
<li>服务器的数字证书信息<code>Certificates</code>。</li>
</ul>
<p>此时，因为服务器端选择了使用ECDHE密钥协商算法，所以证书发送完毕后，服务器端要做的事有：</p>
<ul>
<li><strong>确定要使用的椭圆曲线</strong>，目的是确定基点G，这个信息会公开给客户端。</li>
<li><strong>生成一个随机数作为服务器端椭圆曲线的私钥</strong>，保存在本地。</li>
<li>根据基点G和私钥<strong>计算出服务器端的椭圆曲线公钥</strong>，也会公开给客户端。</li>
</ul>
<p>完成上述步骤后，服务器发送消息<strong>Server Key Exchange</strong>，其中主要信息是<code>Server Params</code>：</p>
<ul>
<li>使用的椭圆曲线<code>Named Curve</code>，比如<code>x25519</code>。</li>
<li>服务器端椭圆曲线公钥<code>Pubkey</code>。</li>
<li>为了保证这个<code>Pubkey</code>不被第三方篡改，还会用RSA签名算法给公钥做个签名，标明使用的签名算法<code>Signature Algorithm</code>和生成的签名<code>Signature</code>。</li>
</ul>
<p>再之后服务器端发送消息<strong>Server Hello Done</strong>，表示我该给你的给完了，本次打招呼完毕。</p>
<p>至此，TLS 两次握手已经完成，目前客户端和服务器端端通过明文共享了信息：<code>Client Random</code>、<code>Server Random</code> 、使用的椭圆曲线<code>Named Curve</code>及椭圆曲线基点G、服务端椭圆曲线的公钥<code>Pubkey</code>，这几个信息很重要，是后续生成会话密钥的材料。</p>
<ol start="3">
<li><strong>TLS第三次握手</strong></li>
</ol>
<p>客户端收到证书后，校验证书是否合法，确认无误后接着后面的操作：</p>
<ul>
<li><strong>生成一个随机数作为客户端椭圆曲线的私钥</strong>。</li>
<li>根据服务器端给的信息<strong>计算出客户端的椭圆曲线公钥</strong>。</li>
</ul>
<p>完成后发送消息<strong>Client Key Exchange</strong>，其中主要信息是<code>Client Params</code>：</p>
<ul>
<li>客户端椭圆曲线公钥<code>Pubkey</code>。</li>
</ul>
<p>至此，双方都有对方的椭圆曲线公钥，自己的椭圆曲线私钥，椭圆曲线基点G，于是就能计算出点(x, y)了，前文提到此处<code>x</code>就是后续的主密钥<code>Master Key</code>，但实际并非如此。</p>
<p>注意到目前为止之前的两个随机数<code>Client Random</code>和<code>Server Random</code>都还没使用到，<code>x</code>在这里可以当作RSA握手中的第三个随机数<code>Pre-Master Secret</code>，于RSA类似，实际上最终就是[<code>Client Random</code>+<code>Server Random</code>+<code>x</code>]这三个材料共同计算生成的主密钥<code>Master Secret</code>！这是因为TLS设计者不信任单个伪随机数的可靠性，于是把三个不可靠的随机数混合起来，达到高程度的随机，提高安全性。</p>
<p>通过主密钥计算好会话密钥后，客户端发送消息<strong>Change Cipher Spec</strong>和<strong>Encrypted Handshake Message</strong>。</p>
<ol start="4">
<li><strong>TLS第四次握手</strong></li>
</ol>
<p>和客户端一样，服务器端也发送消息<strong>Change Cipher Spec</strong>和<strong>Encrypted Handshake Message</strong>，如果双方验证加密解密都没问题，握手正式完成，之后正常收发加密的HTTP请求和响应。</p>
<p>值得注意的是，<strong>使用ECDHE的时候，在第四次握手之前，客户端已经发送了加密的HTTP数据</strong>，而RSA握手必须在四次完成后再传输应用数据。所以ECDHE相比RSA握手过程帮后面省去了一个消息往返时间，这个过程被称为<strong>TLS False Start</strong>，类似于<strong>TCP Fast Open</strong>，都是在连接没有完全建立时就开始发送应用数据。</p>
<h2 id="5-5-HTTPS如何优化"><a href="#5-5-HTTPS如何优化" class="headerlink" title="5.5 HTTPS如何优化"></a>5.5 HTTPS如何优化</h2><p>HTTPS的性能消耗主要存在于两个环节：</p>
<ol>
<li>TLS协议的握手过程；</li>
<li>握手后的对称加密报文传输。</li>
</ol>
<p>对于第二个环节现在主流的对称加密算法AES等性能都还不错，一些CPU厂商也有针对它们的硬件级别优化，这个环节的性能消耗非常地小。</p>
<p>主要的消耗来自于第一个环节，握手过程不仅增加了网络延时（最长2个RTT），而且握手过程中的步骤也会产生性能损耗：</p>
<ul>
<li>对于ECDHE密钥协商算法，握手过程中客户端和服务器端都需要临时生成椭圆曲线私钥然后计算生成公钥。</li>
<li>客户端验证证书会访问CA获取CRL护着OCSP，目的是验证证书是否被吊销。</li>
<li>客户端和服务器端都需要计算产生Master Secret。</li>
</ul>
<p>对症下药，主要有三个方向的优化：</p>
<ol>
<li><strong>硬件优化</strong></li>
</ol>
<p>计算机世界中软件都跑在物理硬件上，硬件越厉害软件跑得就越快。如上文所述HTTPS协议中存在大量计算过程，<strong>它是计算密集型，而不是I/O密集型</strong>，因此应该把硬件提升集中在CPU上。</p>
<p>此外，还应该选择支持AES-NI特性的CPU，这种CPU在指令级别优化了AES算法，加速了数据传输过程中的加密解密过程。</p>
<ol start="2">
<li><strong>软件优化</strong></li>
</ol>
<p>软件优化的方向有两种，一个是软件升级，一个是协议优化。</p>
<p>软件升级就是把正在使用的软件升级到最新版本，新版本不仅提供新的特性，也优化了之前存在的问题和性能。但这对于成百上千的服务器来说也要消耗大量人力物力时间，还存在一定风险。</p>
<ol start="3">
<li><strong>协议优化</strong></li>
</ol>
<p>现有条件下最现实也是改动最小的优化应该还是协议优化，主要包括：</p>
<ul>
<li>密钥交换算法：TLS 1.2版本使用RSA密钥交换算法，需要4次握手也就是2个RTT才能进行应用数据的传输，而且RSA还没有前向安全性。因此<strong>尽可能选择ECDHE密钥交换算法</strong>替换RSA，它支持<strong>Flase Start</strong>，客户端在TLS协议第3次握手后第4次握手前九发送加密的应用数据，省去了一个RTT，还具备前向安全性。ECDHE的不同椭圆曲线性能也不同，目前最快的椭圆曲线是<code>x25519</code>。</li>
<li>对称加密算法：如果对安全性的要求不是特别高，选择AES_128_GCM代替AES_256_GCM会更快一些，因为密钥的长度更短。</li>
<li>TLS升级：TLS 1.3版本相对TLS 1.2版本大幅度简化了握手步骤，<strong>完成TLS握手只需要1RTT</strong>，而且安全性更高。</li>
</ul>
<p><img src="images/tls1.2and1.3.png" alt="tls1.2and1.3"></p>
<p>观察上图可以发现，<strong>TLS 1.3把Hello和公钥交换两个消息合并成了一个消息，于是用1个RTT完成了TLS握手</strong>。</p>
<p>具体的做法是，<strong>客户端在Client Hello消息里直接带上了支持的椭圆曲线和这些椭圆曲线对应的公钥</strong>，服务器收到后选定一个曲线，返回消息时也带上了自己的公钥。于是1RTT双方手上就已经有了生成Master Secret的所有材料，从而计算生成会话密钥后就可以进行数据的加密传输了。</p>
<p>此外，TLS 1.3对密码套件做了删减，<strong>直接移除了不具备前向安全性的RSA和DH算法，只支持ECDHE算法</strong>。因为TLS 1.2支持的太多古老且不安全的套件，容易被中间人用不安全的套件伪造Client Hello消息，迫使服务器用不安全的密码套件进行HTTPS连接，从而破解密文。</p>
<ol start="4">
<li><strong>证书优化</strong></li>
</ol>
<p>TLS握手过程中服务器端会把自己的证书发送给客户端来证明自己的身份，因此对于证书的优化也有两个方向。</p>
<ul>
<li>证书传输：减小证书的大小可以节约带宽便于传输，也能减少客户端的运算量。所以服务器可以尽量选择椭圆曲线（ESDSA）证书，而不是RSA证书，相同安全强度下，ECC密钥比RSA短很多。</li>
<li>证书验证：客户端验证证书的过程比较复杂，会走证书链逐级验证，验证过程不仅需要用CA公钥解密证书和用签名算法验证证书完整性，而且为了确定证书是否被CA吊销还需要访问CA下载CRL和OCSP数据，这个过程通过HTTP访问会产生一系列网络通信的开销，比如DNS查询、建立连接、收发数据。可以选择使用<code>OCSP Stapling</code>来解决这个问题。<ul>
<li>CRL：证书吊销列表（Certificate Revocation List）由CA定期更新，内容是被撤销信任的证书序号。CRL由CA维护，定期更新，实时性较差，而且随着吊销证书的增多，列表越来越大，下载的速度就越来越慢。</li>
<li>OCSP：在线证书状态协议（Online Certificate Status Protocol），现在更常用的查询证书有效性的方法。工作方式是向CA发送查询请求，让CA返回证书的有效状态。但是依然要发送网络请求，而且得看CA服务器的实时状态，如果服务器繁忙，延时会变大。</li>
<li>OCSP Stapling：为了解决OCSP的网络请求问题，出现了OCSP Stapling，服务器向CA周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它，并在TLS握手过程中发给客户端，由于签名的存在服务器也无法篡改这个结果，客户端不需要自己去查询就能知道证书是否已经被吊销。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>会话复用</strong></li>
</ol>
<p>会话复用（TLS Session Resumption）是将TLS握手协商产生的对称加密密钥缓存起来，下次再需要建立连接的时候直接复用这个密钥，就避免重复握手的开销。</p>
<p>会话复用有两种实现：</p>
<ul>
<li><code>Session ID</code>：客户端和服务器首次TLS握手连接后，双方会在内存缓存会话密钥，并用唯一的Session ID标识，即Session ID和会话密钥的Key-Value。客户端再次连接时，直接在hello消息里带上Session ID，服务器收到后直接从内存找（为了安全考虑，内存中会话密钥会定期失效），找到后用该会话密钥恢复会话状态，一个RTT建立加密通信。这个方法缺点在于，服务器对每一个客户端都保存一个会话密钥，客户端一多，服务器的内存压力就上去了；此外，现在的网站服务一般都是集群的多台服务器通过负载均衡提供服务，客户端再次连接时不一定就能命中上一次访问过的服务器，这个Session ID的存在也失去了意义。</li>
<li><code>Session Ticket</code>：服务器不再缓存每个客户端的密钥，缓存的工作只由客户端负责，类似于HTTP的Cookie。工作方式是客户端与服务器首次建立连接时服务器加密会话密钥作为Ticket发给客户端，客户端缓存这个Ticket。客户端再次连接服务器时带上这个Ticket，服务器解密后直接获取了上一次的会话密钥，只要还在有效期就可以恢复会话开始加密通信。对于集群服务器，要确保每台服务器加密会话密钥的密钥一致，这样命中任意一台服务器都能被正确解密。<code>Session ID</code>和<code>Session Ticket</code>都不具备前向安全性，一旦加密会话密钥的密钥被破解或者泄漏，前面的所有通信秘文都会被破解，因此要对会话密钥设定一个合理的过期时间。</li>
<li><code>Pre-shared Key</code>：TLS 1.3提出了<code>Pre-shared Key</code>，用0RTT就可以实现重连，原理类似Ticket，不过重连时客户端直接把Ticket和HTTP请求报文一起发送。它也不具备前向安全性。</li>
</ul>
<h1 id="6-HTTP的演变"><a href="#6-HTTP的演变" class="headerlink" title="6 HTTP的演变"></a>6 HTTP的演变</h1><h2 id="6-1-HTTP-1-0-gt-HTTP-1-1"><a href="#6-1-HTTP-1-0-gt-HTTP-1-1" class="headerlink" title="6.1 HTTP/1.0 -&gt; HTTP/1.1"></a>6.1 HTTP/1.0 -&gt; HTTP/1.1</h2><p>HTTP/1.1相比HTTP/1.0在性能上的改进：</p>
<ul>
<li>使用TCP长连接改善了HTTP/1.0短连接重复建立和断开连接的性能开销。</li>
<li>支持管道（Pipeline）网络传输，可以连续发送请求，不必等其响应，减少整体响应时间。</li>
</ul>
<p>但是HTTP/1.0还是存在性能瓶颈：</p>
<ul>
<li><strong>HTTP首部巨大且重复</strong>：只能压缩Body部分，Request/Response Header未经压缩就发送，首部信息越多报文就越大延迟也就越严重，冗长的首部每次互相发送造成的浪费较多。</li>
<li><strong>队头阻塞</strong>：虽然客户端可以管道传输请求，但是服务器端必须按序进行响应，如果一个请求响应很慢，后面的请求都在服务器端被阻塞，客户端一直请求不到数据，也就是队头阻塞问题。而且没有请求优先级控制。</li>
<li><strong>不支持服务器推送消息</strong>：请求只能由客户端发起，服务器只能被动响应。</li>
</ul>
<p>在不改变HTTP版本的情况下，针对HTTP/1.1的优化思路可以有以下几个方向：</p>
<ol>
<li><strong>尽量避免发送HTTP请求</strong></li>
</ol>
<p>如前文所写，避免发送HTTP请求的方法是通过<strong>缓存技术</strong>，缓存又分为强制缓存和协商缓存。</p>
<ol start="2">
<li><strong>减少HTTP的请求次数</strong></li>
</ol>
<ul>
<li>减少重定向请求次数：把重定向的工作交由代理服务器完成。</li>
<li>合并请求：合并资源，比如webpack，以大资源的请求替换多个小资源的请求。</li>
<li>延迟发送请求：需要资源的时候才进行请求，比如购物网站页面下拉过程的显示。</li>
</ul>
<ol start="3">
<li><strong>减少HTTP响应数据的大小</strong></li>
</ol>
<ul>
<li>无损压缩：适合文本文件、程序可执行文件、程序源码，比如gzip。</li>
<li>有损压缩：适合图片、音视频，比如Google的WebP格式。</li>
</ul>
<h2 id="6-2-HTTP-1-1-gt-HTTP-2"><a href="#6-2-HTTP-1-1-gt-HTTP-2" class="headerlink" title="6.2 HTTP/1.1 -&gt; HTTP/2"></a>6.2 HTTP/1.1 -&gt; HTTP/2</h2><p>HTTP/2也是基于HTTPS，所以安全性同样得到保障。</p>
<p><img src="images/19-HTTPS%E4%B8%8EHTTP.jpeg" alt="19-HTTPS与HTTP"></p>
<h3 id="6-2-1-兼容HTTP-1-1"><a href="#6-2-1-兼容HTTP-1-1" class="headerlink" title="6.2.1 兼容HTTP/1.1"></a>6.2.1 兼容HTTP/1.1</h3><p>HTTP/2兼容了老版本HTTP/1.1：</p>
<ol>
<li>HTTP/2没有在URI里引入新的协议名，仍然使用的是<code>http://</code>表示明文协议，<code>https://</code>表示加密协，这样服务器和浏览器在背后自动升级协议，用户不需要感知，实现了协议的平滑升级。</li>
<li>HTTP/2只在应用层做了改变，还是基于TCP协议传输。</li>
<li>应用层上为了保证功能的兼容，HTTP/2把HTTP分解成了语义和语法两个部分，语义部分和HTTP/1.1完全一致，比如请求方法、状态码、头字段等规则。但是在语法层HTTP/2做了很多改变，基本改变了HTTP报文的传输格式。</li>
</ol>
<h3 id="6-2-2-头部压缩"><a href="#6-2-2-头部压缩" class="headerlink" title="6.2.2 头部压缩"></a>6.2.2 头部压缩</h3><p>HTTP协议的报文由Header+Body构成。在Body部分前文提到HTTP/1.1就使用了Header的字段<code>Content-Encoding</code>来指定压缩方式，比如gzip，这样使报文体变小，节约带宽，提升传输速率。</p>
<p>但对于Header部分，HTTP/1.1没有针对它的优化，存在一些问题：</p>
<ul>
<li><strong>含有很多固定字段</strong>：比如<code>Cookie</code>，<code>User Agent</code>，<code>Accept</code>，有必要压缩。</li>
<li><strong>大量报文中的重复字段</strong>：重复的请求和响应的报文中字段值也是重复的，占有了不必要的带宽，需要避免重复性。</li>
<li><strong>字段是ASCII编码的字符</strong>：方便人类阅读，不方便机器读取，可以改为二进制编码。</li>
</ul>
<p>因此HTTP/2对Header使用了<strong>HPACK算法</strong>来压缩头部，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，提高了报文传输的速度。</p>
<p>HPACK算法主要有三个部分：</p>
<ul>
<li><p>静态字典：为高频出现的头部字符串和字段建立的静态表，写入到HTTP/2的框架中，不会变化，一共有61组，以Index-Header Value的Key-Value形式存储，实际上是三个表项：Index - Header Name（查询时不需要） - Header Valu，比如<code>2 - :method - GET</code>，有的Index对应的Header Value是空的，因为这些Value是变化的，会经过Huffman编码后才会发送出去。</p>
</li>
<li><p>动态字典：不在静态字典中的头部字符串比如<code>User-Agent</code>，会经过Huffman编码后从Index 62开始构建动态表，并发送出去，这样客户端和服务器都更新了自己的动态表，下次再发送这个字段时就直接发送1个字节的Index就行。所以使用动态字典的前提是必须在同一个连接上传输完全相同的HTTP头部。如果每次字段都在变化，动态表的意义就不大了。</p>
</li>
<li><p>Huffman编码：压缩算法</p>
</li>
</ul>
<h3 id="6-2-3-二进制帧"><a href="#6-2-3-二进制帧" class="headerlink" title="6.2.3 二进制帧"></a>6.2.3 二进制帧</h3><p>HTTP/2不再使用1.1里的纯文本形式报文，而是全面采用二进制格式，头信息和数据体都是二进制，并且统称为帧（Frame）：<strong>头信息帧</strong>（Headers Frame）和<strong>数据帧</strong>(Data Frame)。</p>
<p><img src="images/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.webp" alt="二进制帧"></p>
<p>这样虽然对人不友好，但是对计算机很友好，因为计算机只懂二进制，收到报文后，无需再将明文的报文转成二进制而是可以直接解析，增加了数据传输的速率。</p>
<p>比如状态码200，在1.1是’2’，’0’，’0’三个字符（3 bytes）来表示，到HTTP/2就直接用数字200（二进制11001000，1 byte）来表示了。</p>
<h3 id="6-2-4-并发传输与多路复用"><a href="#6-2-4-并发传输与多路复用" class="headerlink" title="6.2.4 并发传输与多路复用"></a>6.2.4 并发传输与多路复用</h3><p>HTTP/2实现了并发传输与多路复用，可以在一个连接中<strong>并发多个请求或响应</strong>，而不用按照顺序一次请求一次响应。这样一来，就避免了HTTP/1.1的串行化请求，不需要排队等待，也就不再会发生队头阻塞，<strong>降低了等待延迟，大幅度提高了连接的利用率</strong>。</p>
<p>比如在一个TCP连接中服务器收到了客户端的请求A和B，在请求A的处理过程中服务器发现非常耗时，就先先响应请求A已经处理好的部分，接着响应请求B，完成后再响应A请求剩下的部分。</p>
<p><img src="images/26-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg" alt="26-多路复用"></p>
<p>基于原理是HTTP/2设计的<strong>Stream</strong>，多个Stream复用一条TCP连接，达到并发传输的效果，解决了HTTP/1.1的队头阻塞问题，提高了HTTP传输的吞吐量。</p>
<p><strong>对于不同的Stream，帧可以乱序发送</strong>，因此在同一个TCP连接里连续的报文不一定属于同一个请求或响应，为了保证各个Stream之间的传输不乱套，需要对每个数据包做标记，明确指出它们所属的流，即每个帧头部携带的独一无二的标记编号<strong>Stream ID</strong>，接收端通过Stream ID有序组装HTTP消息，由此可以并发不同的Stream。</p>
<p>但是<strong>在同一个Stream内部，帧必须要是严格有序的</strong>，因为对于同一个流内的帧接收端是按顺序处理的。</p>
<p>客户端和服务器都可以建立Stream，客户端建立的Stream必须是奇数号的Stream ID，服务器端建立的必须是偶数号。同一个TCP连接中的Stream ID是不能复用的，只能顺序递增，所以当Stream ID耗尽时，需要发一个控制帧<code>GOAWAY</code>来关闭当前TCP连接，重新建立新的连接。</p>
<p>在HTTP/2中客户端还可以<strong>指定Stream的优先级</strong>，优先级高的请求会率先得到服务器响应。</p>
<h3 id="6-2-5-服务器推送"><a href="#6-2-5-服务器推送" class="headerlink" title="6.2.5 服务器推送"></a>6.2.5 服务器推送</h3><p>只能由客户端发起的请求-应答模式也在一定程度上被改善，服务器不只是被动响应了，还可以主动向客户端发送消息。</p>
<p>比如客户端通过HTTP/1.1请求从服务器获取HTML文件，浏览解析HTML文件时发现需要依赖CSS来渲染，于是再次发起对CSS文件的请求，就有了两次消息往返，但是在HTTP/2中，客户端请求HTML时服务器就主动推送了CSS文件，减少了消息的传递次数。</p>
<p><img src="images/push.png" alt="push"></p>
<p>HTTP/2的推送实现原理还是Stream。客户端发起的请求必须使用奇数ID的Stream，服务器主动推送，使用的是自己建立的偶数ID的Stream，服务器推送资源时通过<code>PUSH_PROMISE</code>帧传输HTTP头部，通过该帧中的<code>Promised Stream ID</code>字段告诉客户端，接下来在哪个偶数号Stream中发送包体。</p>
<h3 id="6-2-6-HTTP-2的缺陷"><a href="#6-2-6-HTTP-2的缺陷" class="headerlink" title="6.2.6 HTTP/2的缺陷"></a>6.2.6 HTTP/2的缺陷</h3><ol>
<li><strong>TCP层的队头阻塞问题</strong>。</li>
</ol>
<p>Stream的出现大幅度提高了HTTP的并发能力，客户端和服务器端的队头阻塞似乎都得到了解决，但其实这个问题还是存在于HTTP的下一层，即TCP这一层。</p>
<p>HTTP/2依然是基于TCP协议来传输数据的，TCP是字节流协议，<strong>TCP的可靠传输必须保证收到的字节数据是完整且连续的，然后内核才能将缓冲区的数据返回给HTTP应用</strong>，如果前面的字节没有到达，后续收到的字节也只能放在内核缓冲区里，一直等到这个字节到达，才会把数据推给HTTP应用，这就是HTTP/2依然存在的队头阻塞问题。</p>
<p>所以丢包一旦发生，TCP的重传机制被触发，一个TCP连接中的所有HTTP请求都得等待这个丢掉的包被重传回来。</p>
<ol start="2">
<li><strong>TCP与TLS握手时的延迟</strong></li>
</ol>
<p>发起HTTP请求时，需要经过TCP三次握手和TLS四次握手的过程，共需要3个RTT才能发出请求数据，此外每次建立连接还需要经过TCP的Slow Start过程，会产生减速效果。</p>
<ol start="3">
<li><strong>网络迁移需要重新连接</strong></li>
</ol>
<p>HTTP/1和HTTP/2都基于TCP协议传输，TCP通过源IP、源端口、目的IP、目的端口的四元组确定一条TCP连接，当移动设备网络从运营商网络切换到WiFi时，IP地址发生变化，TCP连接就必须被断开然后重新建立连接，建立连接的过程又是TCP三次握手和TLS四次握手，再加上TCP的慢启动，连接的迁移成本很高，用户体验到的就是网络突然产生卡顿。</p>
<h2 id="6-3-HTTP-2-gt-HTTP-3"><a href="#6-3-HTTP-2-gt-HTTP-3" class="headerlink" title="6.3 HTTP/2 -&gt; HTTP/3"></a>6.3 HTTP/2 -&gt; HTTP/3</h2><h3 id="6-3-1-QUIC"><a href="#6-3-1-QUIC" class="headerlink" title="6.3.1 QUIC"></a>6.3.1 QUIC</h3><p>上文提到的HTTP/2的缺陷和不足都是由TCP引发，因此<strong>HTTP/3不破不立直接把下层的TCP协议换成了UDP</strong>！</p>
<p>UDP是不可靠传输，只管传输数据，不管包的顺序也不管丢包，所以避免了TCP丢包重传带来的队头阻塞。<strong>同时，为了使得UDP有一定的可靠性，HTTP/3使用了基于UDP的QUIC协议</strong>。</p>
<p>QUIC主要有3个特点：</p>
<ol>
<li><strong>无队头阻塞</strong></li>
</ol>
<p>QUIC协议也有类似HTTP/2 Stream和多路复用的机制，可以在同一连接上并发传输多个Stream，一个Stream可以认为是一条HTTP请求。</p>
<p>QUIC保证传输可靠性的机制是：给一个流中的每个数据包都给一个序号唯一标识，一旦某个数据包丢失，即使该流的其他数据包到达了，数据也无法被上层HTTP/3读取，必须等到QUIC重传丢失的报文，数据才会交给HTTP/3。</p>
<p>在保证可靠性的同时，QUIC还避免了队头阻塞：当某个Stream发生丢包时只有这一个Stream被阻塞，其他流不会受到影响，只要其他流的数据报文被完整接受，HTTP/3就可以读取这些流的数据，所以可以认为QUIC连接上的多个Stream互相是独立的！</p>
<ol start="2">
<li><strong>更快建立连接</strong></li>
</ol>
<p>在HTTP/1和HTTP/2中，<strong>TCP和SSL/TLS是分层的，分别属于内核实现的传输层、openSSL库实现的表示层</strong>，难以合并在一起，需要分批握手建立连接，先是TCP三次握手，然后是TLS四次握手。</p>
<p>HTTP/3在传输数据前先经过QUIC协议握手，整个握手只需要1RTT，握手的目的是确认双方的连接ID（连接迁移就是基于连接ID实现）。而且QUIC协议没有与TLS分层，QUIC内部就包含了TLS，它在自己的帧中携带TLS的记录，再加上QUIC使用的是TLS/1.3，因此<strong>1个RTT同时完成了连接建立和密钥协商</strong>。甚至在第二次连接时，应用数据包可以和QUIC握手信息（连接信息+TLS信息）一起发送，达到0RTT的效果。</p>
<p><img src="images/0-rtt.gif" alt="0-rtt"></p>
<ol start="3">
<li><strong>连接迁移</strong></li>
</ol>
<p>之前的HTTP/1和HTTP/2都基于TCP协议传输，TCP通过源IP、源端口、目的IP、目的端口的四元组确定一条TCP连接，当移动设备网络从运营商网络切换到WiFi时，IP地址发生变化，TCP连接就必须被断开然后重新建立连接，建立连接的过程又是TCP三次握手和TLS四次握手，再加上TCP的慢启动，连接的迁移成本很高，用户体验到的就是网络突然产生卡顿。</p>
<p>如上文提到的，QUIC不是用四元组来绑定连接的，而是用<strong>连接ID</strong>来标记一组连接中通信的两端，客户端和服务器各自选择一组ID来标记自己，即使移动设备的网络发生变化导致IP地址变了，只要上下文信息（连接ID、TLS密钥等）仍然保留，就能无缝复用原有的连接，消除重新建立连接的成本，达到连接迁移的目的。</p>
<p>总之，QUIC是一个基于UDP的类似TCP可靠传输+TLS+HTTP/2的多路复用协议。</p>
<p><img src="images/http3quic.jpeg" alt="http3quic"></p>
<p>但是这样的一个新协议同样带来了问题，很多网络设备根本不知道QUIC，只把它当作UDP，甚至有的网络设备会丢弃UDP传输过来的包，所以HTTP/3的普及进度依然很缓慢。</p>
<h3 id="6-3-2-HTTP层的改变"><a href="#6-3-2-HTTP层的改变" class="headerlink" title="6.3.2 HTTP层的改变"></a>6.3.2 HTTP层的改变</h3><ol>
<li><strong>更简单的帧结构</strong></li>
</ol>
<p>HTTP/3和HTTP/2一样使用二进制帧的结构，但是HTTP/3不用在帧结构中定义Stream相关的字段，因为它直接使用的是QUIC的Stream。</p>
<p><img src="images/http3frame.webp" alt="http3frame"></p>
<p>由上图可知，HTTP/3的帧头只有两个字段：Type（数据帧，控制帧）和Length。</p>
<ol start="2">
<li><strong>新的头部压缩算法</strong></li>
</ol>
<p>HTTP/3使用了<strong>QPACK</strong>作为头部压缩算法，类似于HPACK，它也包括静态表、动态表和Huffman编码，但是它的静态表扩大到了91项，动态表的编码解码方式也不同，使用只有一端可以发送消息的单向流确保双方的动态表同步更新，编码方收到解码方更新确认的通知后才使用动态表编码HTTP头部，避免了因为丢包产生的解码方没来得及建立动态表就已经收到编码方数据包而无法正确解码的尴尬。</p>
<hr>
<blockquote>
<p>原著：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/">小林coding图解网络</a></p>
</blockquote>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2023年01月01日 18:41</p>
        <p>原始链接： <a class="post-url" href="/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/" title="图解网络笔记：HTTP篇">http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/</a></p>
        <footer>
            <a href="http://muquanrui.com">
                <img src="/images/logo.png" alt="MU Quanrui">
                MU Quanrui
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/&title=《图解网络笔记：HTTP篇》 — Quanrui's Blog&pic=cover.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/&title=《图解网络笔记：HTTP篇》 — Quanrui's Blog&source=Carpe diem." data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《图解网络笔记：HTTP篇》 — Quanrui's Blog&url=http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/&via=http://muquanrui.com" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://muquanrui.com/2022/05/01/Computer%20Science/Network/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%EF%BC%9AHTTP%E7%AF%87/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Computer-Science/" class="color2">Computer Science</a>
      
    <a href="/tags/Network/" class="color3">Network</a>
      
    <a href="/tags/图解网络/" class="color5">图解网络</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
        <div class= "post-toc-name">Table of Contents</div>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="post-toc-text">1 HTTP基本概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-1-HTTP%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">1.1 HTTP介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-2-HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="post-toc-text">1.2 HTTP报文格式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-3-HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="post-toc-text">1.3 HTTP常见的状态码</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-1-%E7%8A%B6%E6%80%81%E7%A0%811xx"><span class="post-toc-text">1.3.1 状态码1xx</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-2-%E7%8A%B6%E6%80%81%E7%A0%812xx"><span class="post-toc-text">1.3.2 状态码2xx</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-3-%E7%8A%B6%E6%80%81%E7%A0%813xx"><span class="post-toc-text">1.3.3 状态码3xx</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-4-%E7%8A%B6%E6%80%81%E7%A0%814xx"><span class="post-toc-text">1.3.4 状态码4xx</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-5-%E7%8A%B6%E6%80%81%E7%A0%815xx"><span class="post-toc-text">1.3.5 状态码5xx</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-4-HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="post-toc-text">1.4 HTTP请求头和响应头的常见字段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-1-%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%AD%97%E6%AE%B5"><span class="post-toc-text">1.4.1 请求头字段</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-2-%E5%93%8D%E5%BA%94%E5%A4%B4%E5%AD%97%E6%AE%B5"><span class="post-toc-text">1.4.2 响应头字段</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-GET%E4%B8%8EPOST"><span class="post-toc-text">2 GET与POST</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-GET%E4%B8%8EPOST%E7%AE%80%E4%BB%8B"><span class="post-toc-text">2.1 GET与POST简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-GET%E4%B8%8EPOST%E7%9A%84%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89"><span class="post-toc-text">2.2 GET与POST的安全和幂等</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="post-toc-text">3 HTTP缓存技术</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="post-toc-text">3.1 强制缓存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="post-toc-text">3.2 协商缓存</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="post-toc-text">3.3 缓存实现的流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-HTTP%E7%89%B9%E6%80%A7"><span class="post-toc-text">4 HTTP特性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-HTTP-1-1%E7%9A%84%E4%BC%98%E7%82%B9"><span class="post-toc-text">4.1 HTTP&#x2F;1.1的优点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-HTTP-1-1%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="post-toc-text">4.2 HTTP&#x2F;1.1的缺点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-3-HTTP-1-1%E7%9A%84%E6%80%A7%E8%83%BD"><span class="post-toc-text">4.3 HTTP&#x2F;1.1的性能</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-HTTPS"><span class="post-toc-text">5 HTTPS</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-1-HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">5.1 HTTP与HTTPS的区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-2-HTTPS%E8%A7%A3%E5%86%B3%E4%BA%86HTTP%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="post-toc-text">5.2 HTTPS解决了HTTP哪些问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-3-HTTPS%E4%BD%BF%E7%94%A8RSA%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="post-toc-text">5.3 HTTPS使用RSA建立连接</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-1-RSA%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="post-toc-text">5.3.1 RSA握手过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-3-2-RSA%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="post-toc-text">5.3.2 RSA算法的缺陷</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-4-HTTPS%E4%BD%BF%E7%94%A8ECDHE%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="post-toc-text">5.4 HTTPS使用ECDHE建立连接</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-1-DH%E7%AE%97%E6%B3%95%E5%92%8CDHE%E7%AE%97%E6%B3%95"><span class="post-toc-text">5.4.1 DH算法和DHE算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-2-ECDHE%E7%AE%97%E6%B3%95"><span class="post-toc-text">5.4.2 ECDHE算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-4-3-ECDHE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="post-toc-text">5.4.3 ECDHE握手过程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-5-HTTPS%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="post-toc-text">5.5 HTTPS如何优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-HTTP%E7%9A%84%E6%BC%94%E5%8F%98"><span class="post-toc-text">6 HTTP的演变</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-1-HTTP-1-0-gt-HTTP-1-1"><span class="post-toc-text">6.1 HTTP&#x2F;1.0 -&gt; HTTP&#x2F;1.1</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-2-HTTP-1-1-gt-HTTP-2"><span class="post-toc-text">6.2 HTTP&#x2F;1.1 -&gt; HTTP&#x2F;2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-1-%E5%85%BC%E5%AE%B9HTTP-1-1"><span class="post-toc-text">6.2.1 兼容HTTP&#x2F;1.1</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-2-%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="post-toc-text">6.2.2 头部压缩</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7"><span class="post-toc-text">6.2.3 二进制帧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-4-%E5%B9%B6%E5%8F%91%E4%BC%A0%E8%BE%93%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="post-toc-text">6.2.4 并发传输与多路复用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="post-toc-text">6.2.5 服务器推送</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-2-6-HTTP-2%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="post-toc-text">6.2.6 HTTP&#x2F;2的缺陷</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-3-HTTP-2-gt-HTTP-3"><span class="post-toc-text">6.3 HTTP&#x2F;2 -&gt; HTTP&#x2F;3</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-1-QUIC"><span class="post-toc-text">6.3.1 QUIC</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-3-2-HTTP%E5%B1%82%E7%9A%84%E6%94%B9%E5%8F%98"><span class="post-toc-text">6.3.2 HTTP层的改变</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
    <a href="/2022/05/02/Programming/Java%20Tutorial/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1%E6%96%87/" id="article-nav-newer" class="article-nav-link-wrap">

      <span class="article-nav-title">
        <i class="fa fa-hand-o-left" aria-hidden="true"></i>
        
          Java基础八股文
        
      </span>
    </a>
  
  
    <a href="/2022/04/28/Notes/Software/Typora%E4%B8%BB%E9%A2%98Drake%E4%BF%AE%E6%94%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">Typora主题Drake修改</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
        <div id="SOHUCS" sid="Computer Science/Network/图解网络/图解网络笔记：HTTP篇" ></div>
<script type="text/javascript">
    (function(){
        var appid = 'cyvaQ34l4';
        var conf = 'dfbc2f31fdc91ffc75e2035195b4426d';
        var width = window.innerWidth || document.documentElement.clientWidth;
        if (width < 960) {
            window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    |
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
    <div class="theme-info">
</p>


      <span class="post-count">本站博文总字数：718.2k</span>
      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2018~2023 MU Quanrui<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!--加载prettify代码高亮js-->
  <script type="text/javascript" src="/google-code-prettify/prettify.js"></script>
  <script type="text/javascript">
    $(document).ready(function(){
      $('pre').addClass('prettyprint linenums');
      $('code').addClass('prettyprint');
      prettyPrint();
    })
  </script>

<script>
  var mihoConfig = {
      root: "http://muquanrui.com",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/Blog/">Blog</a><a class="category-link" href="/categories/Data-Structures-Algorithms/">Data Structures & Algorithms</a><a class="category-link" href="/categories/Database/">Database</a><a class="category-link" href="/categories/ENSEEIHT/">ENSEEIHT</a><a class="category-link" href="/categories/Framework/">Framework</a><a class="category-link" href="/categories/Java-Project/">Java Project</a><a class="category-link" href="/categories/Java-Tutorial/">Java Tutorial</a><a class="category-link" href="/categories/Linux/">Linux</a><a class="category-link" href="/categories/Methodology/">Methodology</a><a class="category-link" href="/categories/Middleware/">Middleware</a><a class="category-link" href="/categories/Network/">Network</a><a class="category-link" href="/categories/Operating-System/">Operating System</a><a class="category-link" href="/categories/Photography/">Photography</a><a class="category-link" href="/categories/Problem-Solving/">Problem Solving</a><a class="category-link" href="/categories/Software/">Software</a><a class="category-link" href="/categories/Tech-Note/">Tech Note</a><a class="category-link" href="/categories/macOS/">macOS</a><a class="category-link" href="/categories/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/">墓畔回忆录</a><a class="category-link" href="/categories/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/">我的大学</a><a class="category-link" href="/categories/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/">法语学习</a><a class="category-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 16.88px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">法语学习</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.25px;">读书笔记</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/categories">
                    <i class="fa fa-book"></i><span>Categories</span>
                </a>
            </li>
            
            <li>
                <a  href="/tags">
                    <i class="fa fa-tags"></i><span>Tags</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Blog/" style="font-size: 13.75px;">Blog</a> <a href="/tags/College/" style="font-size: 18.13px;">College</a> <a href="/tags/Computer-Science/" style="font-size: 18.75px;">Computer Science</a> <a href="/tags/Data-Structures-Algorithms/" style="font-size: 10.63px;">Data Structures & Algorithms</a> <a href="/tags/Database/" style="font-size: 13.13px;">Database</a> <a href="/tags/ENSEEIHT/" style="font-size: 14.38px;">ENSEEIHT</a> <a href="/tags/Framework/" style="font-size: 11.88px;">Framework</a> <a href="/tags/Java-Project/" style="font-size: 10px;">Java Project</a> <a href="/tags/Java-Tutorial/" style="font-size: 19.38px;">Java Tutorial</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 18.75px;">Java基础</a> <a href="/tags/Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I/" style="font-size: 15px;">Java核心技术卷I</a> <a href="/tags/Lifelong-Learning/" style="font-size: 16.88px;">Lifelong Learning</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Methodology/" style="font-size: 11.88px;">Methodology</a> <a href="/tags/Middleware/" style="font-size: 10.63px;">Middleware</a> <a href="/tags/MySQL/" style="font-size: 10.63px;">MySQL</a> <a href="/tags/Network/" style="font-size: 15.63px;">Network</a> <a href="/tags/Notes/" style="font-size: 16.25px;">Notes</a> <a href="/tags/Operating-System/" style="font-size: 13.75px;">Operating System</a> <a href="/tags/Photography/" style="font-size: 10px;">Photography</a> <a href="/tags/Problem-Solving/" style="font-size: 11.25px;">Problem Solving</a> <a href="/tags/Programming/" style="font-size: 20px;">Programming</a> <a href="/tags/Software/" style="font-size: 10.63px;">Software</a> <a href="/tags/Spring/" style="font-size: 10.63px;">Spring</a> <a href="/tags/Tech-Note/" style="font-size: 11.88px;">Tech Note</a> <a href="/tags/macOS/" style="font-size: 11.25px;">macOS</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91UML/" style="font-size: 11.88px;">【大学课程】UML</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10.63px;">【大学课程】操作系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" style="font-size: 11.88px;">【大学课程】数据库系统</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%9A%E4%BF%A1/" style="font-size: 11.88px;">【大学课程】计算机接口与通信</a> <a href="/tags/%E3%80%90%E5%A4%A7%E5%AD%A6%E8%AF%BE%E7%A8%8B%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.25px;">【大学课程】计算机网络</a> <a href="/tags/%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91Java/" style="font-size: 16.88px;">【尚硅谷】Java</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 12.5px;">【王道考研】操作系统</a> <a href="/tags/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.13px;">【王道考研】计算机网络</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%EF%BC%9A%E4%BB%8E%E7%A0%81%E5%86%9C%E5%88%B0%E5%B7%A5%E5%8C%A0/" style="font-size: 11.25px;">代码精进之路：从码农到工匠</a> <a href="/tags/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" style="font-size: 11.88px;">图解网络</a> <a href="/tags/%E5%A2%93%E7%95%94%E5%9B%9E%E5%BF%86%E5%BD%95/" style="font-size: 10.63px;">墓畔回忆录</a> <a href="/tags/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6/" style="font-size: 17.5px;">我的大学</a> <a href="/tags/%E6%B3%95%E8%AF%AD%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">法语学习</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 11.25px;">读书笔记</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>









  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":200,"height":400,"vOffset":-30},"mobile":{"show":false},"react":{"opacity":0.8},"log":false});</script></body>
</html>



